
." Process this file with
." groff -man -Tascii pigpio.3
."
.TH pigpio 3 2012-2018 Linux "pigpio archive"
.SH NAME
pigpio - A C library to manipulate the Pi's GPIO.

.SH SYNOPSIS

#include <pigpio.h>


gcc -Wall -pthread -o prog prog.c -lpigpio -lrt

sudo ./prog
.SH DESCRIPTION


.ad l

.nh

.br

.br
pigpio is a C library for the Raspberry which allows control of the GPIO.

.br

.br
.SS Features
.br

.br
o hardware timed PWM on any of GPIO 0-31

.br

.br
o hardware timed servo pulses on any of GPIO 0-31

.br

.br
o callbacks when any of GPIO 0-31 change state

.br

.br
o callbacks at timed intervals

.br

.br
o reading/writing all of the GPIO in a bank as one operation

.br

.br
o individually setting GPIO modes, reading and writing

.br

.br
o notifications when any of GPIO 0-31 change state

.br

.br
o the construction of output waveforms with microsecond timing

.br

.br
o rudimentary permission control over GPIO

.br

.br
o a simple interface to start and stop new threads

.br

.br
o I2C, SPI, and serial link wrappers

.br

.br
o creating and running scripts

.br

.br
.SS GPIO
.br

.br
ALL GPIO are identified by their Broadcom number.

.br

.br
.SS Credits
.br

.br
The PWM and servo pulses are timed using the DMA and PWM peripherals.

.br

.br
This use was inspired by Richard Hirst's servoblaster kernel module.

.br

.br
See \fBhttps://github.com/richardghirst/PiBits/tree/master/ServoBlaster\fP

.br

.br
.SS Usage
.br

.br
Include <pigpio.h> in your source files.

.br

.br
Assuming your source is in prog.c use the following command to build and
run the executable.

.br

.br

.EX
gcc -Wall -pthread -o prog prog.c -lpigpio -lrt
.br
sudo ./prog
.br

.EE

.br

.br
For examples of usage see the C programs within the pigpio archive file.

.br

.br
.SS Notes
.br

.br
All the functions which return an int return < 0 on error.

.br

.br
\fBgpioInitialise\fP must be called before all other library functions
with the following exceptions:

.br

.br

.EX
\fBgpioCfg*\fP
.br
\fBgpioVersion\fP
.br
\fBgpioHardwareRevision\fP
.br

.EE

.br

.br
If the library is not initialised all but the \fBgpioCfg*\fP,
\fBgpioVersion\fP, and \fBgpioHardwareRevision\fP functions will
return error PI_NOT_INITIALISED.

.br

.br
If the library is initialised the \fBgpioCfg*\fP functions will return
error PI_INITIALISED.

.br

.br
.SH FUNCTIONS

.IP "\fBint gpioInitialise(void)\fP"
.IP "" 4
Initialises the library.

.br

.br
Returns the pigpio version number if OK, otherwise PI_INIT_FAILED.

.br

.br
gpioInitialise must be called before using the other library functions
with the following exceptions:

.br

.br

.EX
\fBgpioCfg*\fP
.br
\fBgpioVersion\fP
.br
\fBgpioHardwareRevision\fP
.br

.EE

.br

.br
\fBExample\fP
.br

.EX
if (gpioInitialise() < 0)
.br
{
.br
   // pigpio initialisation failed.
.br
}
.br
else
.br
{
.br
   // pigpio initialised okay.
.br
}
.br

.EE

.IP "\fBvoid gpioTerminate(void)\fP"
.IP "" 4
Terminates the library.

.br

.br
Returns nothing.

.br

.br
Call before program exit.

.br

.br
This function resets the used DMA channels, releases memory, and
terminates any running threads.

.br

.br
\fBExample\fP
.br

.EX
gpioTerminate();
.br

.EE

.IP "\fBint gpioSetMode(unsigned gpio, unsigned mode)\fP"
.IP "" 4
Sets the GPIO mode, typically input or output.

.br

.br

.EX
gpio: 0-53
.br
mode: 0-7
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_MODE.

.br

.br
Arduino style: pinMode.

.br

.br
\fBExample\fP
.br

.EX
gpioSetMode(17, PI_INPUT);  // Set GPIO17 as input.
.br

.br
gpioSetMode(18, PI_OUTPUT); // Set GPIO18 as output.
.br

.br
gpioSetMode(22,PI_ALT0);    // Set GPIO22 to alternative mode 0.
.br

.EE

.br

.br
See \fBhttp://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf\fP page 102 for an overview of the modes.

.IP "\fBint gpioGetMode(unsigned gpio)\fP"
.IP "" 4
Gets the GPIO mode.

.br

.br

.EX
gpio: 0-53
.br

.EE

.br

.br
Returns the GPIO mode if OK, otherwise PI_BAD_GPIO.

.br

.br
\fBExample\fP
.br

.EX
if (gpioGetMode(17) != PI_ALT0)
.br
{
.br
   gpioSetMode(17, PI_ALT0);  // set GPIO17 to ALT0
.br
}
.br

.EE

.IP "\fBint gpioSetPullUpDown(unsigned gpio, unsigned pud)\fP"
.IP "" 4
Sets or clears resistor pull ups or downs on the GPIO.

.br

.br

.EX
gpio: 0-53
.br
 pud: 0-2
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_PUD.

.br

.br
\fBExample\fP
.br

.EX
gpioSetPullUpDown(17, PI_PUD_UP);   // Sets a pull-up.
.br

.br
gpioSetPullUpDown(18, PI_PUD_DOWN); // Sets a pull-down.
.br

.br
gpioSetPullUpDown(23, PI_PUD_OFF);  // Clear any pull-ups/downs.
.br

.EE

.IP "\fBint gpioRead(unsigned gpio)\fP"
.IP "" 4
Reads the GPIO level, on or off.

.br

.br

.EX
gpio: 0-53
.br

.EE

.br

.br
Returns the GPIO level if OK, otherwise PI_BAD_GPIO.

.br

.br
Arduino style: digitalRead.

.br

.br
\fBExample\fP
.br

.EX
printf("GPIO24 is level %d", gpioRead(24));
.br

.EE

.IP "\fBint gpioWrite(unsigned gpio, unsigned level)\fP"
.IP "" 4
Sets the GPIO level, on or off.

.br

.br

.EX
 gpio: 0-53
.br
level: 0-1
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_LEVEL.

.br

.br
If PWM or servo pulses are active on the GPIO they are switched off.

.br

.br
Arduino style: digitalWrite

.br

.br
\fBExample\fP
.br

.EX
gpioWrite(24, 1); // Set GPIO24 high.
.br

.EE

.IP "\fBint gpioPWM(unsigned user_gpio, unsigned dutycycle)\fP"
.IP "" 4
Starts PWM on the GPIO, dutycycle between 0 (off) and range (fully on).
Range defaults to 255.

.br

.br

.EX
user_gpio: 0-31
.br
dutycycle: 0-range
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_DUTYCYCLE.

.br

.br
Arduino style: analogWrite

.br

.br
This and the servo functionality use the DMA and PWM or PCM peripherals
to control and schedule the pulse lengths and dutycycles.

.br

.br
The \fBgpioSetPWMrange\fP function may be used to change the default
range of 255.

.br

.br
\fBExample\fP
.br

.EX
gpioPWM(17, 255); // Sets GPIO17 full on.
.br

.br
gpioPWM(18, 128); // Sets GPIO18 half on.
.br

.br
gpioPWM(23, 0);   // Sets GPIO23 full off.
.br

.EE

.IP "\fBint gpioGetPWMdutycycle(unsigned user_gpio)\fP"
.IP "" 4
Returns the PWM dutycycle setting for the GPIO.

.br

.br

.EX
user_gpio: 0-31
.br

.EE

.br

.br
Returns between 0 (off) and range (fully on) if OK, otherwise
PI_BAD_USER_GPIO or PI_NOT_PWM_GPIO.

.br

.br
For normal PWM the dutycycle will be out of the defined range
for the GPIO (see \fBgpioGetPWMrange\fP).

.br

.br
If a hardware clock is active on the GPIO the reported dutycycle
will be 500000 (500k) out of 1000000 (1M).

.br

.br
If hardware PWM is active on the GPIO the reported dutycycle
will be out of a 1000000 (1M).

.br

.br
Normal PWM range defaults to 255.

.IP "\fBint gpioSetPWMrange(unsigned user_gpio, unsigned range)\fP"
.IP "" 4
Selects the dutycycle range to be used for the GPIO.  Subsequent calls
to gpioPWM will use a dutycycle between 0 (off) and range (fully on).

.br

.br

.EX
user_gpio: 0-31
.br
    range: 25-40000
.br

.EE

.br

.br
Returns the real range for the given GPIO's frequency if OK,
otherwise PI_BAD_USER_GPIO or PI_BAD_DUTYRANGE.

.br

.br
If PWM is currently active on the GPIO its dutycycle will be scaled
to reflect the new range.

.br

.br
The real range, the number of steps between fully off and fully
on for each frequency, is given in the following table.

.br

.br

.EX
  25,   50,  100,  125,  200,  250,  400,   500,   625,
.br
 800, 1000, 1250, 2000, 2500, 4000, 5000, 10000, 20000
.br

.EE

.br

.br
The real value set by \fBgpioPWM\fP is (dutycycle * real range) / range.

.br

.br
\fBExample\fP
.br

.EX
gpioSetPWMrange(24, 2000); // Now 2000 is fully on
.br
                           //     1000 is half on
.br
                           //      500 is quarter on, etc.
.br

.EE

.IP "\fBint gpioGetPWMrange(unsigned user_gpio)\fP"
.IP "" 4
Returns the dutycycle range used for the GPIO if OK, otherwise
PI_BAD_USER_GPIO.

.br

.br

.EX
user_gpio: 0-31
.br

.EE

.br

.br
If a hardware clock or hardware PWM is active on the GPIO
the reported range will be 1000000 (1M).

.br

.br
\fBExample\fP
.br

.EX
r = gpioGetPWMrange(23);
.br

.EE

.IP "\fBint gpioGetPWMrealRange(unsigned user_gpio)\fP"
.IP "" 4
Returns the real range used for the GPIO if OK, otherwise
PI_BAD_USER_GPIO.

.br

.br

.EX
user_gpio: 0-31
.br

.EE

.br

.br
If a hardware clock is active on the GPIO the reported real
range will be 1000000 (1M).

.br

.br
If hardware PWM is active on the GPIO the reported real range
will be approximately 250M divided by the set PWM frequency.

.br

.br
\fBExample\fP
.br

.EX
rr = gpioGetPWMrealRange(17);
.br

.EE

.IP "\fBint gpioSetPWMfrequency(unsigned user_gpio, unsigned frequency)\fP"
.IP "" 4
Sets the frequency in hertz to be used for the GPIO.

.br

.br

.EX
user_gpio: 0-31
.br
frequency: >=0
.br

.EE

.br

.br
Returns the numerically closest frequency if OK, otherwise
PI_BAD_USER_GPIO.

.br

.br
If PWM is currently active on the GPIO it will be
switched off and then back on at the new frequency.

.br

.br
Each GPIO can be independently set to one of 18 different PWM
frequencies.

.br

.br
The selectable frequencies depend upon the sample rate which
may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).

.br

.br
The frequencies for each sample rate are:

.br

.br

.EX
                       Hertz
.br

.br
       1: 40000 20000 10000 8000 5000 4000 2500 2000 1600
.br
           1250  1000   800  500  400  250  200  100   50
.br

.br
       2: 20000 10000  5000 4000 2500 2000 1250 1000  800
.br
            625   500   400  250  200  125  100   50   25
.br

.br
       4: 10000  5000  2500 2000 1250 1000  625  500  400
.br
            313   250   200  125  100   63   50   25   13
.br
sample
.br
 rate
.br
 (us)  5:  8000  4000  2000 1600 1000  800  500  400  320
.br
            250   200   160  100   80   50   40   20   10
.br

.br
       8:  5000  2500  1250 1000  625  500  313  250  200
.br
            156   125   100   63   50   31   25   13    6
.br

.br
      10:  4000  2000  1000  800  500  400  250  200  160
.br
            125   100    80   50   40   25   20   10    5
.br

.EE

.br

.br
\fBExample\fP
.br

.EX
gpioSetPWMfrequency(23, 0); // Set GPIO23 to lowest frequency.
.br

.br
gpioSetPWMfrequency(24, 500); // Set GPIO24 to 500Hz.
.br

.br
gpioSetPWMfrequency(25, 100000); // Set GPIO25 to highest frequency.
.br

.EE

.IP "\fBint gpioGetPWMfrequency(unsigned user_gpio)\fP"
.IP "" 4
Returns the frequency (in hertz) used for the GPIO if OK, otherwise
PI_BAD_USER_GPIO.

.br

.br

.EX
user_gpio: 0-31
.br

.EE

.br

.br
For normal PWM the frequency will be that defined for the GPIO by
\fBgpioSetPWMfrequency\fP.

.br

.br
If a hardware clock is active on the GPIO the reported frequency
will be that set by \fBgpioHardwareClock\fP.

.br

.br
If hardware PWM is active on the GPIO the reported frequency
will be that set by \fBgpioHardwarePWM\fP.

.br

.br
\fBExample\fP
.br

.EX
f = gpioGetPWMfrequency(23); // Get frequency used for GPIO23.
.br

.EE

.IP "\fBint gpioServo(unsigned user_gpio, unsigned pulsewidth)\fP"
.IP "" 4
Starts servo pulses on the GPIO, 0 (off), 500 (most anti-clockwise) to
2500 (most clockwise).

.br

.br

.EX
 user_gpio: 0-31
.br
pulsewidth: 0, 500-2500
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_PULSEWIDTH.

.br

.br
The range supported by servos varies and should probably be determined
by experiment.  A value of 1500 should always be safe and represents
the mid-point of rotation.  You can DAMAGE a servo if you command it
to move beyond its limits.

.br

.br
The following causes an on pulse of 1500 microseconds duration to be
transmitted on GPIO 17 at a rate of 50 times per second. This will
command a servo connected to GPIO 17 to rotate to its mid-point.

.br

.br
\fBExample\fP
.br

.EX
gpioServo(17, 1000); // Move servo to safe position anti-clockwise.
.br

.br
gpioServo(23, 1500); // Move servo to centre position.
.br

.br
gpioServo(25, 2000); // Move servo to safe position clockwise.
.br

.EE

.br

.br
OTHER UPDATE RATES:

.br

.br
This function updates servos at 50Hz.  If you wish to use a different
update frequency you will have to use the PWM functions.

.br

.br

.EX
PWM Hz    50   100  200  400  500
.br
1E6/Hz 20000 10000 5000 2500 2000
.br

.EE

.br

.br
Firstly set the desired PWM frequency using \fBgpioSetPWMfrequency\fP.

.br

.br
Then set the PWM range using \fBgpioSetPWMrange\fP to 1E6/frequency.
Doing this allows you to use units of microseconds when setting
the servo pulsewidth.

.br

.br
E.g. If you want to update a servo connected to GPIO25 at 400Hz

.br

.br

.EX
gpioSetPWMfrequency(25, 400);
.br

.br
gpioSetPWMrange(25, 2500);
.br

.EE

.br

.br
Thereafter use the PWM command to move the servo,
e.g. gpioPWM(25, 1500) will set a 1500 us pulse.

.IP "\fBint gpioGetServoPulsewidth(unsigned user_gpio)\fP"
.IP "" 4
Returns the servo pulsewidth setting for the GPIO.

.br

.br

.EX
user_gpio: 0-31
.br

.EE

.br

.br
Returns 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise)
if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERVO_GPIO.

.IP "\fBint gpioSetAlertFunc(unsigned user_gpio, gpioAlertFunc_t f)\fP"
.IP "" 4
Registers a function to be called (a callback) when the specified
GPIO changes state.

.br

.br

.EX
user_gpio: 0-31
.br
        f: the callback function
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO.

.br

.br
One callback may be registered per GPIO.

.br

.br
The callback is passed the GPIO, the new level, and the tick.

.br

.br

.EX
Parameter   Value    Meaning
.br

.br
GPIO        0-31     The GPIO which has changed state
.br

.br
level       0-2      0 = change to low (a falling edge)
.br
                     1 = change to high (a rising edge)
.br
                     2 = no level change (a watchdog timeout)
.br

.br
tick        32 bit   The number of microseconds since boot
.br
                     WARNING: this wraps around from
.br
                     4294967295 to 0 roughly every 72 minutes
.br

.EE

.br

.br
The alert may be cancelled by passing NULL as the function.

.br

.br
The GPIO are sampled at a rate set when the library is started.

.br

.br
If a value isn't specifically set the default of 5 us is used.

.br

.br
The number of samples per second is given in the following table.

.br

.br

.EX
              samples
.br
              per sec
.br

.br
         1  1,000,000
.br
         2    500,000
.br
sample   4    250,000
.br
rate     5    200,000
.br
(us)     8    125,000
.br
        10    100,000
.br

.EE

.br

.br
Level changes shorter than the sample rate may be missed.

.br

.br
The thread which calls the alert functions is triggered nominally
1000 times per second.  The active alert functions will be called
once per level change since the last time the thread was activated.
i.e. The active alert functions will get all level changes but there
will be a latency.

.br

.br
The tick value is the time stamp of the sample in microseconds, see
\fBgpioTick\fP for more details.

.br

.br
\fBExample\fP
.br

.EX
void aFunction(int gpio, int level, uint32_t tick)
.br
{
.br
   printf("GPIO %d became %d at %d", gpio, level, tick);
.br
}
.br

.br
// call aFunction whenever GPIO 4 changes state
.br

.br
gpioSetAlertFunc(4, aFunction);
.br

.EE

.IP "\fBint gpioSetAlertFuncEx(unsigned user_gpio, gpioAlertFuncEx_t f, void *userdata)\fP"
.IP "" 4
Registers a function to be called (a callback) when the specified
GPIO changes state.

.br

.br

.EX
user_gpio: 0-31
.br
        f: the callback function
.br
 userdata: pointer to arbitrary user data
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO.

.br

.br
One callback may be registered per GPIO.

.br

.br
The callback is passed the GPIO, the new level, the tick, and
the userdata pointer.

.br

.br

.EX
Parameter   Value    Meaning
.br

.br
GPIO        0-31     The GPIO which has changed state
.br

.br
level       0-2      0 = change to low (a falling edge)
.br
                     1 = change to high (a rising edge)
.br
                     2 = no level change (a watchdog timeout)
.br

.br
tick        32 bit   The number of microseconds since boot
.br
                     WARNING: this wraps around from
.br
                     4294967295 to 0 roughly every 72 minutes
.br

.br
userdata    pointer  Pointer to an arbitrary object
.br

.EE

.br

.br
See \fBgpioSetAlertFunc\fP for further details.

.br

.br
Only one of \fBgpioSetAlertFunc\fP or \fBgpioSetAlertFuncEx\fP can be
registered per GPIO.

.IP "\fBint gpioSetISRFunc(unsigned gpio, unsigned edge, int timeout, gpioISRFunc_t f)\fP"
.IP "" 4
Registers a function to be called (a callback) whenever the specified
GPIO interrupt occurs.

.br

.br

.EX
   gpio: 0-53
.br
   edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE
.br
timeout: interrupt timeout in milliseconds (<=0 to cancel)
.br
      f: the callback function
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_EDGE,
or PI_BAD_ISR_INIT.

.br

.br
One function may be registered per GPIO.

.br

.br
The function is passed the GPIO, the current level, and the
current tick.  The level will be PI_TIMEOUT if the optional
interrupt timeout expires.

.br

.br

.EX
Parameter   Value    Meaning
.br

.br
GPIO        0-53     The GPIO which has changed state
.br

.br
level       0-2      0 = change to low (a falling edge)
.br
                     1 = change to high (a rising edge)
.br
                     2 = no level change (interrupt timeout)
.br

.br
tick        32 bit   The number of microseconds since boot
.br
                     WARNING: this wraps around from
.br
                     4294967295 to 0 roughly every 72 minutes
.br

.EE

.br

.br
The underlying Linux sysfs GPIO interface is used to provide
the interrupt services.

.br

.br
The first time the function is called, with a non-NULL f, the
GPIO is exported, set to be an input, and set to interrupt
on the given edge and timeout.

.br

.br
Subsequent calls, with a non-NULL f, can vary one or more of the
edge, timeout, or function.

.br

.br
The ISR may be cancelled by passing a NULL f, in which case the
GPIO is unexported.

.br

.br
The tick is that read at the time the process was informed of
the interrupt.  This will be a variable number of microseconds
after the interrupt occurred.  Typically the latency will be of
the order of 50 microseconds.  The latency is not guaranteed
and will vary with system load.

.br

.br
The level is that read at the time the process was informed of
the interrupt, or PI_TIMEOUT if the optional interrupt timeout
expired.  It may not be the same as the expected edge as
interrupts happening in rapid succession may be missed by the
kernel (i.e. this mechanism can not be used to capture several
interrupts only a few microseconds apart).

.IP "\fBint gpioSetISRFuncEx(unsigned gpio, unsigned edge, int timeout, gpioISRFuncEx_t f, void *userdata)\fP"
.IP "" 4
Registers a function to be called (a callback) whenever the specified
GPIO interrupt occurs.

.br

.br

.EX
    gpio: 0-53
.br
    edge: RISING_EDGE, FALLING_EDGE, or EITHER_EDGE
.br
 timeout: interrupt timeout in milliseconds (<=0 to cancel)
.br
       f: the callback function
.br
userdata: pointer to arbitrary user data
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_EDGE,
or PI_BAD_ISR_INIT.

.br

.br
The function is passed the GPIO, the current level, the
current tick, and the userdata pointer.

.br

.br

.EX
Parameter   Value    Meaning
.br

.br
GPIO        0-53     The GPIO which has changed state
.br

.br
level       0-2      0 = change to low (a falling edge)
.br
                     1 = change to high (a rising edge)
.br
                     2 = no level change (interrupt timeout)
.br

.br
tick        32 bit   The number of microseconds since boot
.br
                     WARNING: this wraps around from
.br
                     4294967295 to 0 roughly every 72 minutes
.br

.br
userdata    pointer  Pointer to an arbitrary object
.br

.EE

.br

.br
Only one of \fBgpioSetISRFunc\fP or \fBgpioSetISRFuncEx\fP can be
registered per GPIO.

.br

.br
See \fBgpioSetISRFunc\fP for further details.

.IP "\fBint gpioNotifyOpen(void)\fP"
.IP "" 4
This function requests a free notification handle.

.br

.br
Returns a handle greater than or equal to zero if OK,
otherwise PI_NO_HANDLE.

.br

.br
A notification is a method for being notified of GPIO state changes
via a pipe or socket.

.br

.br
Pipe notifications for handle x will be available at the pipe
named /dev/pigpiox (where x is the handle number).  E.g. if the
function returns 15 then the notifications must be read
from /dev/pigpio15.

.br

.br
Socket notifications are returned to the socket which requested the
handle.

.br

.br
\fBExample\fP
.br

.EX
h = gpioNotifyOpen();
.br

.br
if (h >= 0)
.br
{
.br
   sprintf(str, "/dev/pigpio%d", h);
.br

.br
   fd = open(str, O_RDONLY);
.br

.br
   if (fd >= 0)
.br
   {
.br
      // Okay.
.br
   }
.br
   else
.br
   {
.br
      // Error.
.br
   }
.br
}
.br
else
.br
{
.br
   // Error.
.br
}
.br

.EE

.IP "\fBint gpioNotifyOpenWithSize(int bufSize)\fP"
.IP "" 4
This function requests a free notification handle.

.br

.br
It differs from \fBgpioNotifyOpen\fP in that the pipe size may be
specified, whereas \fBgpioNotifyOpen\fP uses the default pipe size.

.br

.br
See \fBgpioNotifyOpen\fP for further details.

.IP "\fBint gpioNotifyBegin(unsigned handle, uint32_t bits)\fP"
.IP "" 4
This function starts notifications on a previously opened handle.

.br

.br

.EX
handle: >=0, as returned by \fBgpioNotifyOpen\fP
.br
  bits: a bit mask indicating the GPIO of interest
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.br

.br
The notification sends state changes for each GPIO whose corresponding
bit in bits is set.

.br

.br
Each notification occupies 12 bytes in the fifo and has the
following structure.

.br

.br

.EX
typedef struct
.br
{
.br
   uint16_t seqno;
.br
   uint16_t flags;
.br
   uint32_t tick;
.br
   uint32_t level;
.br
} gpioReport_t;
.br

.EE

.br

.br
seqno: starts at 0 each time the handle is opened and then increments
by one for each report.

.br

.br
flags: three flags are defined, PI_NTFY_FLAGS_WDOG,
PI_NTFY_FLAGS_ALIVE, and PI_NTFY_FLAGS_EVENT.

.br

.br
If bit 5 is set (PI_NTFY_FLAGS_WDOG) then bits 0-4 of the flags
indicate a GPIO which has had a watchdog timeout.

.br

.br
If bit 6 is set (PI_NTFY_FLAGS_ALIVE) this indicates a keep alive
signal on the pipe/socket and is sent once a minute in the absence
of other notification activity.

.br

.br
If bit 7 is set (PI_NTFY_FLAGS_EVENT) then bits 0-4 of the flags
indicate an event which has been triggered.

.br

.br
tick: the number of microseconds since system boot.  It wraps around
after 1h12m.

.br

.br
level: indicates the level of each GPIO.  If bit 1<<x is set then
GPIO x is high.

.br

.br
\fBExample\fP
.br

.EX
// Start notifications for GPIO 1, 4, 6, 7, 10.
.br

.br
//                         1
.br
//                         0  76 4  1
.br
// (1234 = 0x04D2 = 0b0000010011010010)
.br

.br
gpioNotifyBegin(h, 1234);
.br

.EE

.IP "\fBint gpioNotifyPause(unsigned handle)\fP"
.IP "" 4
This function pauses notifications on a previously opened handle.

.br

.br

.EX
handle: >=0, as returned by \fBgpioNotifyOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.br

.br
Notifications for the handle are suspended until \fBgpioNotifyBegin\fP
is called again.

.br

.br
\fBExample\fP
.br

.EX
gpioNotifyPause(h);
.br

.EE

.IP "\fBint gpioNotifyClose(unsigned handle)\fP"
.IP "" 4
This function stops notifications on a previously opened handle
and releases the handle for reuse.

.br

.br

.EX
handle: >=0, as returned by \fBgpioNotifyOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.br

.br
\fBExample\fP
.br

.EX
gpioNotifyClose(h);
.br

.EE

.IP "\fBint gpioWaveClear(void)\fP"
.IP "" 4
This function clears all waveforms and any data added by calls to the
\fBgpioWaveAdd*\fP functions.

.br

.br
Returns 0 if OK.

.br

.br
\fBExample\fP
.br

.EX
gpioWaveClear();
.br

.EE

.IP "\fBint gpioWaveAddNew(void)\fP"
.IP "" 4
This function starts a new empty waveform.

.br

.br
You wouldn't normally need to call this function as it is automatically
called after a waveform is created with the \fBgpioWaveCreate\fP function.

.br

.br
Returns 0 if OK.

.br

.br
\fBExample\fP
.br

.EX
gpioWaveAddNew();
.br

.EE

.IP "\fBint gpioWaveAddGeneric(unsigned numPulses, gpioPulse_t *pulses)\fP"
.IP "" 4
This function adds a number of pulses to the current waveform.

.br

.br

.EX
numPulses: the number of pulses
.br
   pulses: an array of pulses
.br

.EE

.br

.br
Returns the new total number of pulses in the current waveform if OK,
otherwise PI_TOO_MANY_PULSES.

.br

.br
The pulses are interleaved in time order within the existing waveform
(if any).

.br

.br
Merging allows the waveform to be built in parts, that is the settings
for GPIO#1 can be added, and then GPIO#2 etc.

.br

.br
If the added waveform is intended to start after or within the existing
waveform then the first pulse should consist of a delay.

.br

.br
\fBExample\fP
.br

.EX
// Construct and send a 30 microsecond square wave.
.br

.br
gpioSetMode(gpio, PI_OUTPUT);
.br

.br
pulse[0].gpioOn = (1<<gpio);
.br
pulse[0].gpioOff = 0;
.br
pulse[0].usDelay = 15;
.br

.br
pulse[1].gpioOn = 0;
.br
pulse[1].gpioOff = (1<<gpio);
.br
pulse[1].usDelay = 15;
.br

.br
gpioWaveAddNew();
.br

.br
gpioWaveAddGeneric(2, pulse);
.br

.br
wave_id = gpioWaveCreate();
.br

.br
if (wave_id >= 0)
.br
{
.br
   gpioWaveTxSend(wave_id, PI_WAVE_MODE_REPEAT);
.br

.br
   // Transmit for 30 seconds.
.br

.br
   sleep(30);
.br

.br
   gpioWaveTxStop();
.br
}
.br
else
.br
{
.br
   // Wave create failed.
.br
}
.br

.EE

.IP "\fBint gpioWaveAddSerial(unsigned user_gpio, unsigned baud, unsigned data_bits, unsigned stop_bits, unsigned offset, unsigned numBytes, char *str)\fP"
.IP "" 4
This function adds a waveform representing serial data to the
existing waveform (if any).  The serial data starts offset
microseconds from the start of the waveform.

.br

.br

.EX
user_gpio: 0-31
.br
     baud: 50-1000000
.br
data_bits: 1-32
.br
stop_bits: 2-8
.br
   offset: >=0
.br
 numBytes: >=1
.br
      str: an array of chars (which may contain nulls)
.br

.EE

.br

.br
Returns the new total number of pulses in the current waveform if OK,
otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, PI_BAD_DATABITS,
PI_BAD_STOPBITS, PI_TOO_MANY_CHARS, PI_BAD_SER_OFFSET,
or PI_TOO_MANY_PULSES.

.br

.br
NOTES:

.br

.br
The serial data is formatted as one start bit, data_bits data bits, and
stop_bits/2 stop bits.

.br

.br
It is legal to add serial data streams with different baud rates to
the same waveform.

.br

.br
numBytes is the number of bytes of data in str.

.br

.br
The bytes required for each character depend upon data_bits.

.br

.br
For data_bits 1-8 there will be one byte per character.
.br
For data_bits 9-16 there will be two bytes per character.
.br
For data_bits 17-32 there will be four bytes per character.

.br

.br
\fBExample\fP
.br

.EX
#define MSG_LEN 8
.br

.br
int i;
.br
char *str;
.br
char data[MSG_LEN];
.br

.br
str = "Hello world!";
.br

.br
gpioWaveAddSerial(4, 9600, 8, 2, 0, strlen(str), str);
.br

.br
for (i=0; i<MSG_LEN; i++) data[i] = i;
.br

.br
// Data added is offset 1 second from the waveform start.
.br
gpioWaveAddSerial(4, 9600, 8, 2, 1000000, MSG_LEN, data);
.br

.EE

.IP "\fBint gpioWaveCreate(void)\fP"
.IP "" 4
This function creates a waveform from the data provided by the prior
calls to the \fBgpioWaveAdd*\fP functions.  Upon success a wave id
greater than or equal to 0 is returned, otherwise PI_EMPTY_WAVEFORM,
PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.

.br

.br
The data provided by the \fBgpioWaveAdd*\fP functions is consumed by this
function.

.br

.br
As many waveforms may be created as there is space available.  The
wave id is passed to \fBgpioWaveTxSend\fP to specify the waveform to transmit.

.br

.br
Normal usage would be

.br

.br
Step 1. \fBgpioWaveClear\fP to clear all waveforms and added data.

.br

.br
Step 2. \fBgpioWaveAdd*\fP calls to supply the waveform data.

.br

.br
Step 3. \fBgpioWaveCreate\fP to create the waveform and get a unique id

.br

.br
Repeat steps 2 and 3 as needed.

.br

.br
Step 4. \fBgpioWaveTxSend\fP with the id of the waveform to transmit.

.br

.br
A waveform comprises one of more pulses.  Each pulse consists of a
\fBgpioPulse_t\fP structure.

.br

.br

.EX
typedef struct
.br
{
.br
   uint32_t gpioOn;
.br
   uint32_t gpioOff;
.br
   uint32_t usDelay;
.br
} gpioPulse_t;
.br

.EE

.br

.br
The fields specify

.br

.br
1) the GPIO to be switched on at the start of the pulse.
.br
2) the GPIO to be switched off at the start of the pulse.
.br
3) the delay in microseconds before the next pulse.

.br

.br
Any or all the fields can be zero.  It doesn't make any sense to
set all the fields to zero (the pulse will be ignored).

.br

.br
When a waveform is started each pulse is executed in order with the
specified delay between the pulse and the next.

.br

.br
Returns the new waveform id if OK, otherwise PI_EMPTY_WAVEFORM,
PI_NO_WAVEFORM_ID, PI_TOO_MANY_CBS, or PI_TOO_MANY_OOL.

.IP "\fBint gpioWaveDelete(unsigned wave_id)\fP"
.IP "" 4
This function deletes the waveform with id wave_id.

.br

.br
The wave is flagged for deletion.  The resources used by the wave
will only be reused when either of the following apply.

.br

.br
- all waves with higher numbered wave ids have been deleted or have
been flagged for deletion.

.br

.br
- a new wave is created which uses exactly the same resources as
the current wave (see the C source for gpioWaveCreate for details).

.br

.br

.EX
wave_id: >=0, as returned by \fBgpioWaveCreate\fP
.br

.EE

.br

.br
Wave ids are allocated in order, 0, 1, 2, etc.

.br

.br
Returns 0 if OK, otherwise PI_BAD_WAVE_ID.

.IP "\fBint gpioWaveTxSend(unsigned wave_id, unsigned wave_mode)\fP"
.IP "" 4
This function transmits the waveform with id wave_id.  The mode
determines whether the waveform is sent once or cycles endlessly.
The SYNC variants wait for the current waveform to reach the
end of a cycle or finish before starting the new waveform.

.br

.br
WARNING: bad things may happen if you delete the previous
waveform before it has been synced to the new waveform.

.br

.br
NOTE: Any hardware PWM started by \fBgpioHardwarePWM\fP will be cancelled.

.br

.br

.EX
  wave_id: >=0, as returned by \fBgpioWaveCreate\fP
.br
wave_mode: PI_WAVE_MODE_ONE_SHOT, PI_WAVE_MODE_REPEAT,
.br
           PI_WAVE_MODE_ONE_SHOT_SYNC, PI_WAVE_MODE_REPEAT_SYNC
.br

.EE

.br

.br
Returns the number of DMA control blocks in the waveform if OK,
otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.

.IP "\fBint gpioWaveChain(char *buf, unsigned bufSize)\fP"
.IP "" 4
This function transmits a chain of waveforms.

.br

.br
NOTE: Any hardware PWM started by \fBgpioHardwarePWM\fP will be cancelled.

.br

.br
The waves to be transmitted are specified by the contents of buf
which contains an ordered list of \fBwave_id\fPs and optional command
codes and related data.

.br

.br

.EX
    buf: pointer to the wave_ids and optional command codes
.br
bufSize: the number of bytes in buf
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_CHAIN_NESTING, PI_CHAIN_LOOP_CNT, PI_BAD_CHAIN_LOOP, PI_BAD_CHAIN_CMD, PI_CHAIN_COUNTER,
PI_BAD_CHAIN_DELAY, PI_CHAIN_TOO_BIG, or PI_BAD_WAVE_ID.

.br

.br
Each wave is transmitted in the order specified.  A wave may
occur multiple times per chain.

.br

.br
A blocks of waves may be transmitted multiple times by using
the loop commands. The block is bracketed by loop start and
end commands.  Loops may be nested.

.br

.br
Delays between waves may be added with the delay command.

.br

.br
The following command codes are supported:

.br

.br
Name           Cmd & Data   Meaning
.br
Loop Start     255 0        Identify start of a wave block
.br
Loop Repeat    255 1 x y    loop x + y*256 times
.br
Delay          255 2 x y    delay x + y*256 microseconds
.br
Loop Forever   255 3        loop forever
.br

.br

.br
If present Loop Forever must be the last entry in the chain.

.br

.br
The code is currently dimensioned to support a chain with roughly
600 entries and 20 loop counters.

.br

.br
\fBExample\fP
.br

.EX
#include <stdio.h>
.br
#include <pigpio.h>
.br

.br
#define WAVES 5
.br
#define GPIO 4
.br

.br
int main(int argc, char *argv[])
.br
{
.br
   int i, wid[WAVES];
.br

.br
   if (gpioInitialise()<0) return -1;
.br

.br
   gpioSetMode(GPIO, PI_OUTPUT);
.br

.br
   printf("start piscope, press return"); getchar();
.br

.br
   for (i=0; i<WAVES; i++)
.br
   {
.br
      gpioWaveAddGeneric(2, (gpioPulse_t[])
.br
         {{1<<GPIO, 0,        20},
.br
          {0, 1<<GPIO, (i+1)*200}});
.br

.br
      wid[i] = gpioWaveCreate();
.br
   }
.br

.br
   gpioWaveChain((char []) {
.br
      wid[4], wid[3], wid[2],       // transmit waves 4+3+2
.br
      255, 0,                       // loop start
.br
         wid[0], wid[0], wid[0],    // transmit waves 0+0+0
.br
         255, 0,                    // loop start
.br
            wid[0], wid[1],         // transmit waves 0+1
.br
            255, 2, 0x88, 0x13,     // delay 5000us
.br
         255, 1, 30, 0,             // loop end (repeat 30 times)
.br
         255, 0,                    // loop start
.br
            wid[2], wid[3], wid[0], // transmit waves 2+3+0
.br
            wid[3], wid[1], wid[2], // transmit waves 3+1+2
.br
         255, 1, 10, 0,             // loop end (repeat 10 times)
.br
      255, 1, 5, 0,                 // loop end (repeat 5 times)
.br
      wid[4], wid[4], wid[4],       // transmit waves 4+4+4
.br
      255, 2, 0x20, 0x4E,           // delay 20000us
.br
      wid[0], wid[0], wid[0],       // transmit waves 0+0+0
.br

.br
      }, 46);
.br

.br
   while (gpioWaveTxBusy()) time_sleep(0.1);
.br

.br
   for (i=0; i<WAVES; i++) gpioWaveDelete(wid[i]);
.br

.br
   printf("stop piscope, press return"); getchar();
.br

.br
   gpioTerminate();
.br
}
.br

.EE

.IP "\fBint gpioWaveTxAt(void)\fP"
.IP "" 4
This function returns the id of the waveform currently being
transmitted.

.br

.br
Returns the waveform id or one of the following special values:

.br

.br
PI_WAVE_NOT_FOUND (9998) - transmitted wave not found.
.br
PI_NO_TX_WAVE (9999) - no wave being transmitted.

.IP "\fBint gpioWaveTxBusy(void)\fP"
.IP "" 4
This function checks to see if a waveform is currently being
transmitted.

.br

.br
Returns 1 if a waveform is currently being transmitted, otherwise 0.

.IP "\fBint gpioWaveTxStop(void)\fP"
.IP "" 4
This function aborts the transmission of the current waveform.

.br

.br
Returns 0 if OK.

.br

.br
This function is intended to stop a waveform started in repeat mode.

.IP "\fBint gpioWaveGetMicros(void)\fP"
.IP "" 4
This function returns the length in microseconds of the current
waveform.

.IP "\fBint gpioWaveGetHighMicros(void)\fP"
.IP "" 4
This function returns the length in microseconds of the longest waveform
created since \fBgpioInitialise\fP was called.

.IP "\fBint gpioWaveGetMaxMicros(void)\fP"
.IP "" 4
This function returns the maximum possible size of a waveform in
microseconds.

.IP "\fBint gpioWaveGetPulses(void)\fP"
.IP "" 4
This function returns the length in pulses of the current waveform.

.IP "\fBint gpioWaveGetHighPulses(void)\fP"
.IP "" 4
This function returns the length in pulses of the longest waveform
created since \fBgpioInitialise\fP was called.

.IP "\fBint gpioWaveGetMaxPulses(void)\fP"
.IP "" 4
This function returns the maximum possible size of a waveform in pulses.

.IP "\fBint gpioWaveGetCbs(void)\fP"
.IP "" 4
This function returns the length in DMA control blocks of the current
waveform.

.IP "\fBint gpioWaveGetHighCbs(void)\fP"
.IP "" 4
This function returns the length in DMA control blocks of the longest
waveform created since \fBgpioInitialise\fP was called.

.IP "\fBint gpioWaveGetMaxCbs(void)\fP"
.IP "" 4
This function returns the maximum possible size of a waveform in DMA
control blocks.

.IP "\fBint gpioSerialReadOpen(unsigned user_gpio, unsigned baud, unsigned data_bits)\fP"
.IP "" 4
This function opens a GPIO for bit bang reading of serial data.

.br

.br

.EX
user_gpio: 0-31
.br
     baud: 50-250000
.br
data_bits: 1-32
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD,
PI_BAD_DATABITS, or PI_GPIO_IN_USE.

.br

.br
The serial data is returned in a cyclic buffer and is read using
\fBgpioSerialRead\fP.

.br

.br
It is the caller's responsibility to read data from the cyclic buffer
in a timely fashion.

.IP "\fBint gpioSerialReadInvert(unsigned user_gpio, unsigned invert)\fP"
.IP "" 4
This function configures the level logic for bit bang serial reads.

.br

.br
Use PI_BB_SER_INVERT to invert the serial logic and PI_BB_SER_NORMAL for
normal logic.  Default is PI_BB_SER_NORMAL.

.br

.br

.EX
user_gpio: 0-31
.br
   invert: 0-1
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_GPIO_IN_USE,
PI_NOT_SERIAL_GPIO, or PI_BAD_SER_INVERT.

.br

.br
The GPIO must be opened for bit bang reading of serial data using
\fBgpioSerialReadOpen\fP prior to calling this function.

.IP "\fBint gpioSerialRead(unsigned user_gpio, void *buf, size_t bufSize)\fP"
.IP "" 4
This function copies up to bufSize bytes of data read from the
bit bang serial cyclic buffer to the buffer starting at buf.

.br

.br

.EX
user_gpio: 0-31, previously opened with \fBgpioSerialReadOpen\fP
.br
      buf: an array to receive the read bytes
.br
  bufSize: >=0
.br

.EE

.br

.br
Returns the number of bytes copied if OK, otherwise PI_BAD_USER_GPIO
or PI_NOT_SERIAL_GPIO.

.br

.br
The bytes returned for each character depend upon the number of
data bits \fBdata_bits\fP specified in the \fBgpioSerialReadOpen\fP command.

.br

.br
For \fBdata_bits\fP 1-8 there will be one byte per character.
.br
For \fBdata_bits\fP 9-16 there will be two bytes per character.
.br
For \fBdata_bits\fP 17-32 there will be four bytes per character.

.IP "\fBint gpioSerialReadClose(unsigned user_gpio)\fP"
.IP "" 4
This function closes a GPIO for bit bang reading of serial data.

.br

.br

.EX
user_gpio: 0-31, previously opened with \fBgpioSerialReadOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SERIAL_GPIO.

.IP "\fBint i2cOpen(unsigned i2cBus, unsigned i2cAddr, unsigned i2cFlags)\fP"
.IP "" 4
This returns a handle for the device at the address on the I2C bus.

.br

.br

.EX
  i2cBus: >=0
.br
 i2cAddr: 0-0x7F
.br
i2cFlags: 0
.br

.EE

.br

.br
No flags are currently defined.  This parameter should be set to zero.

.br

.br
Physically buses 0 and 1 are available on the Pi.  Higher numbered buses
will be available if a kernel supported bus multiplexor is being used.

.br

.br
The GPIO used are given in the following table.

.br

.br
        SDA   SCL
.br
I2C 0    0     1
.br
I2C 1    2     3
.br

.br

.br
Returns a handle (>=0) if OK, otherwise PI_BAD_I2C_BUS, PI_BAD_I2C_ADDR,
PI_BAD_FLAGS, PI_NO_HANDLE, or PI_I2C_OPEN_FAILED.

.br

.br
For the SMBus commands the low level transactions are shown at the end
of the function description.  The following abbreviations are used.

.br

.br

.EX
S      (1 bit) : Start bit
.br
P      (1 bit) : Stop bit
.br
Rd/Wr  (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.
.br
A, NA  (1 bit) : Accept and not accept bit.
.br
.br
.br
Addr   (7 bits): I2C 7 bit address.
.br
i2cReg (8 bits): Command byte, a byte which often selects a register.
.br
Data   (8 bits): A data byte.
.br
Count  (8 bits): A byte defining the length of a block operation.
.br

.br
[..]: Data sent by the device.
.br

.EE

.IP "\fBint i2cClose(unsigned handle)\fP"
.IP "" 4
This closes the I2C device associated with the handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.IP "\fBint i2cWriteQuick(unsigned handle, unsigned bit)\fP"
.IP "" 4
This sends a single bit (in the Rd/Wr bit) to the device associated
with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
   bit: 0-1, the value to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br
Quick command. SMBus 2.0 5.5.1

.EX
S Addr bit [A] P
.br

.EE

.IP "\fBint i2cWriteByte(unsigned handle, unsigned bVal)\fP"
.IP "" 4
This sends a single byte to the device associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
  bVal: 0-0xFF, the value to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br
Send byte. SMBus 2.0 5.5.2

.EX
S Addr Wr [A] bVal [A] P
.br

.EE

.IP "\fBint i2cReadByte(unsigned handle)\fP"
.IP "" 4
This reads a single byte from the device associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br

.EE

.br

.br
Returns the byte read (>=0) if OK, otherwise PI_BAD_HANDLE,
or PI_I2C_READ_FAILED.

.br

.br
Receive byte. SMBus 2.0 5.5.3

.EX
S Addr Rd [A] [Data] NA P
.br

.EE

.IP "\fBint i2cWriteByteData(unsigned handle, unsigned i2cReg, unsigned bVal)\fP"
.IP "" 4
This writes a single byte to the specified register of the device
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to write
.br
  bVal: 0-0xFF, the value to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br
Write byte. SMBus 2.0 5.5.4

.EX
S Addr Wr [A] i2cReg [A] bVal [A] P
.br

.EE

.IP "\fBint i2cWriteWordData(unsigned handle, unsigned i2cReg, unsigned wVal)\fP"
.IP "" 4
This writes a single 16 bit word to the specified register of the device
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to write
.br
  wVal: 0-0xFFFF, the value to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br
Write word. SMBus 2.0 5.5.4

.EX
S Addr Wr [A] i2cReg [A] wValLow [A] wValHigh [A] P
.br

.EE

.IP "\fBint i2cReadByteData(unsigned handle, unsigned i2cReg)\fP"
.IP "" 4
This reads a single byte from the specified register of the device
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to read
.br

.EE

.br

.br
Returns the byte read (>=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.

.br

.br
Read byte. SMBus 2.0 5.5.5

.EX
S Addr Wr [A] i2cReg [A] S Addr Rd [A] [Data] NA P
.br

.EE

.IP "\fBint i2cReadWordData(unsigned handle, unsigned i2cReg)\fP"
.IP "" 4
This reads a single 16 bit word from the specified register of the device
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to read
.br

.EE

.br

.br
Returns the word read (>=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.

.br

.br
Read word. SMBus 2.0 5.5.5

.EX
S Addr Wr [A] i2cReg [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P
.br

.EE

.IP "\fBint i2cProcessCall(unsigned handle, unsigned i2cReg, unsigned wVal)\fP"
.IP "" 4
This writes 16 bits of data to the specified register of the device
associated with handle and reads 16 bits of data in return.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to write/read
.br
  wVal: 0-0xFFFF, the value to write
.br

.EE

.br

.br
Returns the word read (>=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.

.br

.br
Process call. SMBus 2.0 5.5.6

.EX
S Addr Wr [A] i2cReg [A] wValLow [A] wValHigh [A]
.br
   S Addr Rd [A] [DataLow] A [DataHigh] NA P
.br

.EE

.IP "\fBint i2cWriteBlockData(unsigned handle, unsigned i2cReg, char *buf, unsigned count)\fP"
.IP "" 4
This writes up to 32 bytes to the specified register of the device
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to write
.br
   buf: an array with the data to send
.br
 count: 1-32, the number of bytes to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br
Block write. SMBus 2.0 5.5.7

.EX
S Addr Wr [A] i2cReg [A] count [A]
.br
   buf0 [A] buf1 [A] ... [A] bufn [A] P
.br

.EE

.IP "\fBint i2cReadBlockData(unsigned handle, unsigned i2cReg, char *buf)\fP"
.IP "" 4
This reads a block of up to 32 bytes from the specified register of
the device associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to read
.br
   buf: an array to receive the read data
.br

.EE

.br

.br
The amount of returned data is set by the device.

.br

.br
Returns the number of bytes read (>=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.

.br

.br
Block read. SMBus 2.0 5.5.7

.EX
S Addr Wr [A] i2cReg [A]
.br
   S Addr Rd [A] [Count] A [buf0] A [buf1] A ... A [bufn] NA P
.br

.EE

.IP "\fBint i2cBlockProcessCall(unsigned handle, unsigned i2cReg, char *buf, unsigned count)\fP"
.IP "" 4
This writes data bytes to the specified register of the device
associated with handle and reads a device specified number
of bytes of data in return.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to write/read
.br
   buf: an array with the data to send and to receive the read data
.br
 count: 1-32, the number of bytes to write
.br

.EE

.br

.br
Returns the number of bytes read (>=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.

.br

.br
The SMBus 2.0 documentation states that a minimum of 1 byte may be
sent and a minimum of 1 byte may be received.  The total number of
bytes sent/received must be 32 or less.

.br

.br
Block write-block read. SMBus 2.0 5.5.8

.EX
S Addr Wr [A] i2cReg [A] count [A] buf0 [A] ... bufn [A]
.br
   S Addr Rd [A] [Count] A [buf0] A ... [bufn] A P
.br

.EE

.IP "\fBint i2cReadI2CBlockData(unsigned handle, unsigned i2cReg, char *buf, unsigned count)\fP"
.IP "" 4
This reads count bytes from the specified register of the device
associated with handle .  The count may be 1-32.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to read
.br
   buf: an array to receive the read data
.br
 count: 1-32, the number of bytes to read
.br

.EE

.br

.br
Returns the number of bytes read (>0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.

.br

.br

.EX
S Addr Wr [A] i2cReg [A]
.br
   S Addr Rd [A] [buf0] A [buf1] A ... A [bufn] NA P
.br

.EE

.IP "\fBint i2cWriteI2CBlockData(unsigned handle, unsigned i2cReg, char *buf, unsigned count)\fP"
.IP "" 4
This writes 1 to 32 bytes to the specified register of the device
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
i2cReg: 0-255, the register to write
.br
   buf: the data to write
.br
 count: 1-32, the number of bytes to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br

.EX
S Addr Wr [A] i2cReg [A] buf0 [A] buf1 [A] ... [A] bufn [A] P
.br

.EE

.IP "\fBint i2cReadDevice(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This reads count bytes from the raw device into buf.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
   buf: an array to receive the read data bytes
.br
 count: >0, the number of bytes to read
.br

.EE

.br

.br
Returns count (>0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_READ_FAILED.

.br

.br

.EX
S Addr Rd [A] [buf0] A [buf1] A ... A [bufn] NA P
.br

.EE

.IP "\fBint i2cWriteDevice(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This writes count bytes from buf to the raw device.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
   buf: an array containing the data bytes to write
.br
 count: >0, the number of bytes to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.

.br

.br

.EX
S Addr Wr [A] buf0 [A] buf1 [A] ... [A] bufn [A] P
.br

.EE

.IP "\fBvoid i2cSwitchCombined(int setting)\fP"
.IP "" 4
This sets the I2C (i2c-bcm2708) module "use combined transactions"
parameter on or off.

.br

.br

.EX
setting: 0 to set the parameter off, non-zero to set it on
.br

.EE

.br

.br

.br

.br
NOTE: when the flag is on a write followed by a read to the same
slave address will use a repeated start (rather than a stop/start).

.IP "\fBint i2cSegments(unsigned handle, pi_i2c_msg_t *segs, unsigned numSegs)\fP"
.IP "" 4
This function executes multiple I2C segments in one transaction by
calling the I2C_RDWR ioctl.

.br

.br

.EX
 handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
   segs: an array of I2C segments
.br
numSegs: >0, the number of I2C segments
.br

.EE

.br

.br
Returns the number of segments if OK, otherwise PI_BAD_I2C_SEG.

.IP "\fBint i2cZip(unsigned handle, char *inBuf, unsigned inLen, char *outBuf, unsigned outLen)\fP"
.IP "" 4
This function executes a sequence of I2C operations.  The
operations to be performed are specified by the contents of inBuf
which contains the concatenated command codes and associated data.

.br

.br

.EX
handle: >=0, as returned by a call to \fBi2cOpen\fP
.br
 inBuf: pointer to the concatenated I2C commands, see below
.br
 inLen: size of command buffer
.br
outBuf: pointer to buffer to hold returned data
.br
outLen: size of output buffer
.br

.EE

.br

.br
Returns >= 0 if OK (the number of bytes read), otherwise
PI_BAD_HANDLE, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN.
PI_BAD_I2C_WLEN, or PI_BAD_I2C_SEG.

.br

.br
The following command codes are supported:

.br

.br
Name      Cmd & Data   Meaning
.br
End       0            No more commands
.br
Escape    1            Next P is two bytes
.br
On        2            Switch combined flag on
.br
Off       3            Switch combined flag off
.br
Address   4 P          Set I2C address to P
.br
Flags     5 lsb msb    Set I2C flags to lsb + (msb << 8)
.br
Read      6 P          Read P bytes of data
.br
Write     7 P ...      Write P bytes of data
.br

.br

.br
The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).

.br

.br
The address defaults to that associated with the handle.
The flags default to 0.  The address and flags maintain their
previous value until updated.

.br

.br
The returned I2C data is stored in consecutive locations of outBuf.

.br

.br
\fBExample\fP
.br

.EX
Set address 0x53, write 0x32, read 6 bytes
.br
Set address 0x1E, write 0x03, read 6 bytes
.br
Set address 0x68, write 0x1B, read 8 bytes
.br
End
.br

.br
0x04 0x53   0x07 0x01 0x32   0x06 0x06
.br
0x04 0x1E   0x07 0x01 0x03   0x06 0x06
.br
0x04 0x68   0x07 0x01 0x1B   0x06 0x08
.br
0x00
.br

.EE

.IP "\fBint bbI2COpen(unsigned SDA, unsigned SCL, unsigned baud)\fP"
.IP "" 4
This function selects a pair of GPIO for bit banging I2C at a
specified baud rate.

.br

.br
Bit banging I2C allows for certain operations which are not possible
with the standard I2C driver.

.br

.br
o baud rates as low as 50
.br
o repeated starts
.br
o clock stretching
.br
o I2C on any pair of spare GPIO

.br

.br

.EX
 SDA: 0-31
.br
 SCL: 0-31
.br
baud: 50-500000
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_I2C_BAUD, or
PI_GPIO_IN_USE.

.br

.br
NOTE:

.br

.br
The GPIO used for SDA and SCL must have pull-ups to 3V3 connected.  As
a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.

.IP "\fBint bbI2CClose(unsigned SDA)\fP"
.IP "" 4
This function stops bit banging I2C on a pair of GPIO previously
opened with \fBbbI2COpen\fP.

.br

.br

.EX
SDA: 0-31, the SDA GPIO used in a prior call to \fBbbI2COpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_I2C_GPIO.

.IP "\fBint bbI2CZip(unsigned SDA, char *inBuf, unsigned inLen, char *outBuf, unsigned outLen)\fP"
.IP "" 4
This function executes a sequence of bit banged I2C operations.  The
operations to be performed are specified by the contents of inBuf
which contains the concatenated command codes and associated data.

.br

.br

.EX
   SDA: 0-31 (as used in a prior call to \fBbbI2COpen\fP)
.br
 inBuf: pointer to the concatenated I2C commands, see below
.br
 inLen: size of command buffer
.br
outBuf: pointer to buffer to hold returned data
.br
outLen: size of output buffer
.br

.EE

.br

.br
Returns >= 0 if OK (the number of bytes read), otherwise
PI_BAD_USER_GPIO, PI_NOT_I2C_GPIO, PI_BAD_POINTER,
PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN, PI_BAD_I2C_WLEN,
PI_I2C_READ_FAILED, or PI_I2C_WRITE_FAILED.

.br

.br
The following command codes are supported:

.br

.br
Name      Cmd & Data     Meaning
.br
End       0              No more commands
.br
Escape    1              Next P is two bytes
.br
Start     2              Start condition
.br
Stop      3              Stop condition
.br
Address   4 P            Set I2C address to P
.br
Flags     5 lsb msb      Set I2C flags to lsb + (msb << 8)
.br
Read      6 P            Read P bytes of data
.br
Write     7 P ...        Write P bytes of data
.br

.br

.br
The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).

.br

.br
The address and flags default to 0.  The address and flags maintain
their previous value until updated.

.br

.br
No flags are currently defined.

.br

.br
The returned I2C data is stored in consecutive locations of outBuf.

.br

.br
\fBExample\fP
.br

.EX
Set address 0x53
.br
start, write 0x32, (re)start, read 6 bytes, stop
.br
Set address 0x1E
.br
start, write 0x03, (re)start, read 6 bytes, stop
.br
Set address 0x68
.br
start, write 0x1B, (re)start, read 8 bytes, stop
.br
End
.br

.br
0x04 0x53
.br
0x02 0x07 0x01 0x32   0x02 0x06 0x06 0x03
.br

.br
0x04 0x1E
.br
0x02 0x07 0x01 0x03   0x02 0x06 0x06 0x03
.br

.br
0x04 0x68
.br
0x02 0x07 0x01 0x1B   0x02 0x06 0x08 0x03
.br

.br
0x00
.br

.EE

.IP "\fBint bscXfer(bsc_xfer_t *bsc_xfer)\fP"
.IP "" 4
This function provides a low-level interface to the
SPI/I2C Slave peripheral.  This peripheral allows the
Pi to act as a slave device on an I2C or SPI bus.

.br

.br
I can't get SPI to work properly.  I tried with a
control word of 0x303 and swapped MISO and MOSI.

.br

.br
The function sets the BSC mode, writes any data in
the transmit buffer to the BSC transmit FIFO, and
copies any data in the BSC receive FIFO to the
receive buffer.

.br

.br

.EX
bsc_xfer:= a structure defining the transfer
.br

.br
typedef struct
.br
{
.br
   uint32_t control;          // Write
.br
   int rxCnt;                 // Read only
.br
   char rxBuf[BSC_FIFO_SIZE]; // Read only
.br
   int txCnt;                 // Write
.br
   char txBuf[BSC_FIFO_SIZE]; // Write
.br
} bsc_xfer_t;
.br

.EE

.br

.br
To start a transfer set control (see below) and copy the bytes to
be sent (if any) to txBuf and set the byte count in txCnt.

.br

.br
Upon return rxCnt will be set to the number of received bytes placed
in rxBuf.

.br

.br
Note that the control word sets the BSC mode.  The BSC will stay in
that mode until a different control word is sent.

.br

.br
The BSC peripheral uses GPIO 18 (SDA) and 19 (SCL) in I2C mode
and GPIO 18 (MOSI), 19 (SCLK), 20 (MISO), and 21 (CE) in SPI mode.  You
need to swap MISO/MOSI between master and slave.

.br

.br
When a zero control word is received GPIO 18-21 will be reset
to INPUT mode.

.br

.br
The returned function value is the status of the transfer (see below).

.br

.br
If there was an error the status will be less than zero
(and will contain the error code).

.br

.br
The most significant word of the returned status contains the number
of bytes actually copied from txBuf to the BSC transmit FIFO (may be
less than requested if the FIFO already contained untransmitted data).

.br

.br
control consists of the following bits.

.br

.br

.EX
22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 a  a  a  a  a  a  a  -  - IT HC TF IR RE TE BK EC ES PL PH I2 SP EN
.br

.EE

.br

.br
Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document for full
details.

.br

.br
aaaaaaa   defines the I2C slave address (only relevant in I2C mode)
.br
IT        invert transmit status flags
.br
HC        enable host control
.br
TF        enable test FIFO
.br
IR        invert receive status flags
.br
RE        enable receive
.br
TE        enable transmit
.br
BK        abort operation and clear FIFOs
.br
EC        send control register as first I2C byte
.br
ES        send status register as first I2C byte
.br
PL        set SPI polarity high
.br
PH        set SPI phase high
.br
I2        enable I2C mode
.br
SP        enable SPI mode
.br
EN        enable BSC peripheral
.br

.br

.br
The returned status has the following format

.br

.br

.EX
20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 S  S  S  S  S  R  R  R  R  R  T  T  T  T  T RB TE RF TF RE TB
.br

.EE

.br

.br
Bits 0-15 are copied unchanged from the BSC FR register.  See
pages 165-166 of the Broadcom peripherals document for full
details.

.br

.br
SSSSS   number of bytes successfully copied to transmit FIFO
.br
RRRRR   number of bytes in receieve FIFO
.br
TTTTT   number of bytes in transmit FIFO
.br
RB      receive busy
.br
TE      transmit FIFO empty
.br
RF      receive FIFO full
.br
TF      transmit FIFO full
.br
RE      receive FIFO empty
.br
TB      transmit busy
.br

.br

.br
The following example shows how to configure the BSC peripheral as
an I2C slave with address 0x13 and send four bytes.

.br

.br
\fBExample\fP
.br

.EX
bsc_xfer_t xfer;
.br

.br
xfer.control = (0x13<<16) | 0x305;
.br

.br
memcpy(xfer.txBuf, "ABCD", 4);
.br
xfer.txCnt = 4;
.br

.br
status = bscXfer(&xfer);
.br

.br
if (status >= 0)
.br
{
.br
   // process transfer
.br
}
.br

.EE

.IP "\fBint bbSPIOpen(unsigned CS, unsigned MISO, unsigned MOSI, unsigned SCLK, unsigned baud, unsigned spiFlags)\fP"
.IP "" 4
This function selects a set of GPIO for bit banging SPI with
a specified baud rate and mode.

.br

.br

.EX
      CS: 0-31
.br
    MISO: 0-31
.br
    MOSI: 0-31
.br
    SCLK: 0-31
.br
    baud: 50-250000
.br
spiFlags: see below
.br

.EE

.br

.br
spiFlags consists of the least significant 22 bits.

.br

.br

.EX
21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 0  0  0  0  0  0  R  T  0  0  0  0  0  0  0  0  0  0  0  p  m  m
.br

.EE

.br

.br
mm defines the SPI mode, defaults to 0

.br

.br

.EX
Mode CPOL CPHA
.br
 0    0    0
.br
 1    0    1
.br
 2    1    0
.br
 3    1    1
.br

.EE

.br

.br
p is 0 if CS is active low (default) and 1 for active high.

.br

.br
T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.

.br

.br
R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.

.br

.br
The other bits in flags should be set to zero.

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_SPI_BAUD, or
PI_GPIO_IN_USE.

.br

.br
If more than one device is connected to the SPI bus (defined by
SCLK, MOSI, and MISO) each must have its own CS.

.br

.br
\fBExample\fP
.br

.EX
bbSPIOpen(10, MISO, MOSI, SCLK, 10000, 0); // device 1
.br
bbSPIOpen(11, MISO, MOSI, SCLK, 20000, 3); // device 2
.br

.EE

.IP "\fBint bbSPIClose(unsigned CS)\fP"
.IP "" 4
This function stops bit banging SPI on a set of GPIO
opened with \fBbbSPIOpen\fP.

.br

.br

.EX
CS: 0-31, the CS GPIO used in a prior call to \fBbbSPIOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SPI_GPIO.

.IP "\fBint bbSPIXfer(unsigned CS, char *inBuf, char *outBuf, unsigned count)\fP"
.IP "" 4
This function executes a bit banged SPI transfer.

.br

.br

.EX
    CS: 0-31 (as used in a prior call to \fBbbSPIOpen\fP)
.br
 inBuf: pointer to buffer to hold data to be sent
.br
outBuf: pointer to buffer to hold returned data
.br
 count: size of data transfer
.br

.EE

.br

.br
Returns >= 0 if OK (the number of bytes read), otherwise
PI_BAD_USER_GPIO, PI_NOT_SPI_GPIO or PI_BAD_POINTER.

.br

.br
\fBExample\fP
.br

.EX
// gcc -Wall -pthread -o bbSPIx_test bbSPIx_test.c -lpigpio
.br
// sudo ./bbSPIx_test
.br

.br

.br
#include <stdio.h>
.br

.br
#include "pigpio.h"
.br

.br
#define CE0 5
.br
#define CE1 6
.br
#define MISO 13
.br
#define MOSI 19
.br
#define SCLK 12
.br

.br
int main(int argc, char *argv[])
.br
{
.br
   int i, count, set_val, read_val;
.br
   unsigned char inBuf[3];
.br
   char cmd1[] = {0, 0};
.br
   char cmd2[] = {12, 0};
.br
   char cmd3[] = {1, 128, 0};
.br

.br
   if (gpioInitialise() < 0)
.br
   {
.br
      fprintf(stderr, "pigpio initialisation failed.\n");
.br
      return 1;
.br
   }
.br

.br
   bbSPIOpen(CE0, MISO, MOSI, SCLK, 10000, 0); // MCP4251 DAC
.br
   bbSPIOpen(CE1, MISO, MOSI, SCLK, 20000, 3); // MCP3008 ADC
.br

.br
   for (i=0; i<256; i++)
.br
   {
.br
      cmd1[1] = i;
.br

.br
      count = bbSPIXfer(CE0, cmd1, (char *)inBuf, 2); // > DAC
.br

.br
      if (count == 2)
.br
      {
.br
         count = bbSPIXfer(CE0, cmd2, (char *)inBuf, 2); // < DAC
.br

.br
         if (count == 2)
.br
         {
.br
            set_val = inBuf[1];
.br

.br
            count = bbSPIXfer(CE1, cmd3, (char *)inBuf, 3); // < ADC
.br

.br
            if (count == 3)
.br
            {
.br
               read_val = ((inBuf[1]&3)<<8) | inBuf[2];
.br
               printf("%d %d\n", set_val, read_val);
.br
            }
.br
         }
.br
      }
.br
   }
.br

.br
   bbSPIClose(CE0);
.br
   bbSPIClose(CE1);
.br

.br
   gpioTerminate();
.br

.br
   return 0;
.br
}
.br

.EE

.IP "\fBint spiOpen(unsigned spiChan, unsigned baud, unsigned spiFlags)\fP"
.IP "" 4
This function returns a handle for the SPI device on the channel.
Data will be transferred at baud bits per second.  The flags may
be used to modify the default behaviour of 4-wire operation, mode 0,
active low chip select.

.br

.br
The Pi has two SPI peripherals: main and auxiliary.

.br

.br
The main SPI has two chip selects (channels), the auxiliary has
three.

.br

.br
The auxiliary SPI is available on all models but the A and B.

.br

.br
The GPIO used are given in the following table.

.br

.br
           MISO   MOSI   SCLK   CE0   CE1   CE2
.br
Main SPI      9     10     11     8     7     -
.br
Aux SPI      19     20     21    18    17    16
.br

.br

.br

.EX
 spiChan: 0-1 (0-2 for the auxiliary SPI)
.br
    baud: 32K-125M (values above 30M are unlikely to work)
.br
spiFlags: see below
.br

.EE

.br

.br
Returns a handle (>=0) if OK, otherwise PI_BAD_SPI_CHANNEL,
PI_BAD_SPI_SPEED, PI_BAD_FLAGS, PI_NO_AUX_SPI, or PI_SPI_OPEN_FAILED.

.br

.br
spiFlags consists of the least significant 22 bits.

.br

.br

.EX
21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m  m
.br

.EE

.br

.br
mm defines the SPI mode.

.br

.br
Warning: modes 1 and 3 do not appear to work on the auxiliary SPI.

.br

.br

.EX
Mode POL PHA
.br
 0    0   0
.br
 1    0   1
.br
 2    1   0
.br
 3    1   1
.br

.EE

.br

.br
px is 0 if CEx is active low (default) and 1 for active high.

.br

.br
ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.

.br

.br
A is 0 for the main SPI, 1 for the auxiliary SPI.

.br

.br
W is 0 if the device is not 3-wire, 1 if the device is 3-wire.  Main
SPI only.

.br

.br
nnnn defines the number of bytes (0-15) to write before switching
the MOSI line to MISO to read data.  This field is ignored
if W is not set.  Main SPI only.

.br

.br
T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.  Auxiliary SPI
only.

.br

.br
R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.  Auxiliary SPI
only.

.br

.br
bbbbbb defines the word size in bits (0-32).  The default (0)
sets 8 bits per word.  Auxiliary SPI only.

.br

.br
The \fBspiRead\fP, \fBspiWrite\fP, and \fBspiXfer\fP functions
transfer data packed into 1, 2, or 4 bytes according to
the word size in bits.

.br

.br
For bits 1-8 there will be one byte per word.
.br
For bits 9-16 there will be two bytes per word.
.br
For bits 17-32 there will be four bytes per word.

.br

.br
Multi-byte transfers are made in least significant byte first order.

.br

.br
E.g. to transfer 32 11-bit words buf should contain 64 bytes
and count should be 64.

.br

.br
E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed
by 0x1A.

.br

.br
The other bits in flags should be set to zero.

.IP "\fBint spiClose(unsigned handle)\fP"
.IP "" 4
This functions closes the SPI device identified by the handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBspiOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.IP "\fBint spiRead(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This function reads count bytes of data from the SPI
device associated with the handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBspiOpen\fP
.br
   buf: an array to receive the read data bytes
.br
 count: the number of bytes to read
.br

.EE

.br

.br
Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.

.IP "\fBint spiWrite(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This function writes count bytes of data from buf to the SPI
device associated with the handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBspiOpen\fP
.br
   buf: the data bytes to write
.br
 count: the number of bytes to write
.br

.EE

.br

.br
Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.

.IP "\fBint spiXfer(unsigned handle, char *txBuf, char *rxBuf, unsigned count)\fP"
.IP "" 4
This function transfers count bytes of data from txBuf to the SPI
device associated with the handle.  Simultaneously count bytes of
data are read from the device and placed in rxBuf.

.br

.br

.EX
handle: >=0, as returned by a call to \fBspiOpen\fP
.br
 txBuf: the data bytes to write
.br
 rxBuf: the received data bytes
.br
 count: the number of bytes to transfer
.br

.EE

.br

.br
Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.

.IP "\fBint serOpen(char *sertty, unsigned baud, unsigned serFlags)\fP"
.IP "" 4
This function opens a serial device at a specified baud rate
and with specified flags.  The device name must start with
/dev/tty or /dev/serial.

.br

.br

.EX
  sertty: the serial device to open
.br
    baud: the baud rate in bits per second, see below
.br
serFlags: 0
.br

.EE

.br

.br
Returns a handle (>=0) if OK, otherwise PI_NO_HANDLE, or
PI_SER_OPEN_FAILED.

.br

.br
The baud rate must be one of 50, 75, 110, 134, 150,
200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200,
38400, 57600, 115200, or 230400.

.br

.br
No flags are currently defined.  This parameter should be set to zero.

.IP "\fBint serClose(unsigned handle)\fP"
.IP "" 4
This function closes the serial device associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBserOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.IP "\fBint serWriteByte(unsigned handle, unsigned bVal)\fP"
.IP "" 4
This function writes bVal to the serial port associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBserOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_SER_WRITE_FAILED.

.IP "\fBint serReadByte(unsigned handle)\fP"
.IP "" 4
This function reads a byte from the serial port associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBserOpen\fP
.br

.EE

.br

.br
Returns the read byte (>=0) if OK, otherwise PI_BAD_HANDLE,
PI_SER_READ_NO_DATA, or PI_SER_READ_FAILED.

.br

.br
If no data is ready PI_SER_READ_NO_DATA is returned.

.IP "\fBint serWrite(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This function writes count bytes from buf to the the serial port
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBserOpen\fP
.br
   buf: the array of bytes to write
.br
 count: the number of bytes to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_SER_WRITE_FAILED.

.IP "\fBint serRead(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This function reads up count bytes from the the serial port
associated with handle and writes them to buf.

.br

.br

.EX
handle: >=0, as returned by a call to \fBserOpen\fP
.br
   buf: an array to receive the read data
.br
 count: the maximum number of bytes to read
.br

.EE

.br

.br
Returns the number of bytes read (>0=) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_SER_READ_NO_DATA.

.br

.br
If no data is ready zero is returned.

.IP "\fBint serDataAvailable(unsigned handle)\fP"
.IP "" 4
This function returns the number of bytes available
to be read from the device associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBserOpen\fP
.br

.EE

.br

.br
Returns the number of bytes of data available (>=0) if OK,
otherwise PI_BAD_HANDLE.

.IP "\fBint gpioTrigger(unsigned user_gpio, unsigned pulseLen, unsigned level)\fP"
.IP "" 4
This function sends a trigger pulse to a GPIO.  The GPIO is set to
level for pulseLen microseconds and then reset to not level.

.br

.br

.EX
user_gpio: 0-31
.br
 pulseLen: 1-100
.br
    level: 0,1
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_LEVEL,
or PI_BAD_PULSELEN.

.IP "\fBint gpioSetWatchdog(unsigned user_gpio, unsigned timeout)\fP"
.IP "" 4
Sets a watchdog for a GPIO.

.br

.br

.EX
user_gpio: 0-31
.br
  timeout: 0-60000
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_WDOG_TIMEOUT.

.br

.br
The watchdog is nominally in milliseconds.

.br

.br
One watchdog may be registered per GPIO.

.br

.br
The watchdog may be cancelled by setting timeout to 0.

.br

.br
Until cancelled a timeout will be reported every timeout milliseconds
after the last GPIO activity.

.br

.br
In particular:

.br

.br
1) any registered alert function for the GPIO will be called with
   the level set to PI_TIMEOUT.

.br

.br
2) any notification for the GPIO will have a report written to the
   fifo with the flags set to indicate a watchdog timeout.

.br

.br
\fBExample\fP
.br

.EX
void aFunction(int gpio, int level, uint32_t tick)
.br
{
.br
   printf("GPIO %d became %d at %d", gpio, level, tick);
.br
}
.br

.br
// call aFunction whenever GPIO 4 changes state
.br
gpioSetAlertFunc(4, aFunction);
.br

.br
//  or approximately every 5 millis
.br
gpioSetWatchdog(4, 5);
.br

.EE

.IP "\fBint gpioNoiseFilter(unsigned user_gpio, unsigned steady, unsigned active)\fP"
.IP "" 4
Sets a noise filter on a GPIO.

.br

.br
Level changes on the GPIO are ignored until a level which has
been stable for \fBsteady\fP microseconds is detected.  Level changes
on the GPIO are then reported for \fBactive\fP microseconds after
which the process repeats.

.br

.br

.EX
user_gpio: 0-31
.br
   steady: 0-300000
.br
   active: 0-1000000
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.

.br

.br
This filter affects the GPIO samples returned to callbacks set up
with \fBgpioSetAlertFunc\fP, \fBgpioSetAlertFuncEx\fP, \fBgpioSetGetSamplesFunc\fP,
and \fBgpioSetGetSamplesFuncEx\fP.

.br

.br
It does not affect interrupts set up with \fBgpioSetISRFunc\fP,
\fBgpioSetISRFuncEx\fP, or levels read by \fBgpioRead\fP,
\fBgpioRead_Bits_0_31\fP, or \fBgpioRead_Bits_32_53\fP.

.br

.br
Level changes before and after the active period may
be reported.  Your software must be designed to cope with
such reports.

.IP "\fBint gpioGlitchFilter(unsigned user_gpio, unsigned steady)\fP"
.IP "" 4
Sets a glitch filter on a GPIO.

.br

.br
Level changes on the GPIO are not reported unless the level
has been stable for at least \fBsteady\fP microseconds.  The
level is then reported.  Level changes of less than \fBsteady\fP
microseconds are ignored.

.br

.br

.EX
user_gpio: 0-31
.br
   steady: 0-300000
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.

.br

.br
This filter affects the GPIO samples returned to callbacks set up
with \fBgpioSetAlertFunc\fP, \fBgpioSetAlertFuncEx\fP, \fBgpioSetGetSamplesFunc\fP,
and \fBgpioSetGetSamplesFuncEx\fP.

.br

.br
It does not affect interrupts set up with \fBgpioSetISRFunc\fP,
\fBgpioSetISRFuncEx\fP, or levels read by \fBgpioRead\fP,
\fBgpioRead_Bits_0_31\fP, or \fBgpioRead_Bits_32_53\fP.

.br

.br
Each (stable) edge will be timestamped \fBsteady\fP microseconds
after it was first detected.

.IP "\fBint gpioSetGetSamplesFunc(gpioGetSamplesFunc_t f, uint32_t bits)\fP"
.IP "" 4
Registers a function to be called (a callback) every millisecond
with the latest GPIO samples.

.br

.br

.EX
   f: the function to call
.br
bits: the GPIO of interest
.br

.EE

.br

.br
Returns 0 if OK.

.br

.br
The function is passed a pointer to the samples (an array of
\fBgpioSample_t\fP),  and the number of samples.

.br

.br
Only one function can be registered.

.br

.br
The callback may be cancelled by passing NULL as the function.

.br

.br
The samples returned will be the union of bits, plus any active alerts,
plus any active notifications.

.br

.br
e.g.  if there are alerts for GPIO 7, 8, and 9, notifications for GPIO
8, 10, 23, 24, and bits is (1<<23)|(1<<17) then samples for GPIO
7, 8, 9, 10, 17, 23, and 24 will be reported.

.IP "\fBint gpioSetGetSamplesFuncEx(gpioGetSamplesFuncEx_t f, uint32_t bits, void *userdata)\fP"
.IP "" 4
Registers a function to be called (a callback) every millisecond
with the latest GPIO samples.

.br

.br

.EX
       f: the function to call
.br
    bits: the GPIO of interest
.br
userdata: a pointer to arbitrary user data
.br

.EE

.br

.br
Returns 0 if OK.

.br

.br
The function is passed a pointer to the samples (an array of
\fBgpioSample_t\fP), the number of samples, and the userdata pointer.

.br

.br
Only one of \fBgpioGetSamplesFunc\fP or \fBgpioGetSamplesFuncEx\fP can be
registered.

.br

.br
See \fBgpioSetGetSamplesFunc\fP for further details.

.IP "\fBint gpioSetTimerFunc(unsigned timer, unsigned millis, gpioTimerFunc_t f)\fP"
.IP "" 4
Registers a function to be called (a callback) every millis milliseconds.

.br

.br

.EX
 timer: 0-9
.br
millis: 10-60000
.br
     f: the function to call
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_TIMER, PI_BAD_MS, or PI_TIMER_FAILED.

.br

.br
10 timers are supported numbered 0 to 9.

.br

.br
One function may be registered per timer.

.br

.br
The timer may be cancelled by passing NULL as the function.

.br

.br
\fBExample\fP
.br

.EX
void bFunction(void)
.br
{
.br
   printf("two seconds have elapsed");
.br
}
.br

.br
// call bFunction every 2000 milliseconds
.br
gpioSetTimerFunc(0, 2000, bFunction);
.br

.EE

.IP "\fBint gpioSetTimerFuncEx(unsigned timer, unsigned millis, gpioTimerFuncEx_t f, void *userdata)\fP"
.IP "" 4
Registers a function to be called (a callback) every millis milliseconds.

.br

.br

.EX
   timer: 0-9.
.br
  millis: 10-60000
.br
       f: the function to call
.br
userdata: a pointer to arbitrary user data
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_TIMER, PI_BAD_MS, or PI_TIMER_FAILED.

.br

.br
The function is passed the userdata pointer.

.br

.br
Only one of \fBgpioSetTimerFunc\fP or \fBgpioSetTimerFuncEx\fP can be
registered per timer.

.br

.br
See \fBgpioSetTimerFunc\fP for further details.

.IP "\fBpthread_t *gpioStartThread(gpioThreadFunc_t f, void *userdata)\fP"
.IP "" 4
Starts a new thread of execution with f as the main routine.

.br

.br

.EX
       f: the main function for the new thread
.br
userdata: a pointer to arbitrary user data
.br

.EE

.br

.br
Returns a pointer to pthread_t if OK, otherwise NULL.

.br

.br
The function is passed the single argument arg.

.br

.br
The thread can be cancelled by passing the pointer to pthread_t to
\fBgpioStopThread\fP.

.br

.br
\fBExample\fP
.br

.EX
#include <stdio.h>
.br
#include <pigpio.h>
.br

.br
void *myfunc(void *arg)
.br
{
.br
   while (1)
.br
   {
.br
      printf("%s", arg);
.br
      sleep(1);
.br
   }
.br
}
.br

.br
int main(int argc, char *argv[])
.br
{
.br
   pthread_t *p1, *p2, *p3;
.br

.br
   if (gpioInitialise() < 0) return 1;
.br

.br
   p1 = gpioStartThread(myfunc, "thread 1"); sleep(3);
.br

.br
   p2 = gpioStartThread(myfunc, "thread 2"); sleep(3);
.br

.br
   p3 = gpioStartThread(myfunc, "thread 3"); sleep(3);
.br

.br
   gpioStopThread(p3); sleep(3);
.br

.br
   gpioStopThread(p2); sleep(3);
.br

.br
   gpioStopThread(p1); sleep(3);
.br

.br
   gpioTerminate();
.br
}
.br

.EE

.IP "\fBvoid gpioStopThread(pthread_t *pth)\fP"
.IP "" 4
Cancels the thread pointed at by pth.

.br

.br

.EX
pth: a thread pointer returned by \fBgpioStartThread\fP
.br

.EE

.br

.br
No value is returned.

.br

.br
The thread to be stopped should have been started with \fBgpioStartThread\fP.

.IP "\fBint gpioStoreScript(char *script)\fP"
.IP "" 4
This function stores a null terminated script for later execution.

.br

.br
See \fBhttp://abyz.me.uk/rpi/pigpio/pigs.html#Scripts\fP for details.

.br

.br

.EX
script: the text of the script
.br

.EE

.br

.br
The function returns a script id if the script is valid,
otherwise PI_BAD_SCRIPT.

.IP "\fBint gpioRunScript(unsigned script_id, unsigned numPar, uint32_t *param)\fP"
.IP "" 4
This function runs a stored script.

.br

.br

.EX
script_id: >=0, as returned by \fBgpioStoreScript\fP
.br
   numPar: 0-10, the number of parameters
.br
    param: an array of parameters
.br

.EE

.br

.br
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.

.br

.br
param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.

.IP "\fBint gpioRunScript(unsigned script_id, unsigned numPar, uint32_t *param)\fP"
.IP "" 4
This function runs a stored script.

.br

.br

.EX
script_id: >=0, as returned by \fBgpioStoreScript\fP
.br
   numPar: 0-10, the number of parameters
.br
    param: an array of parameters
.br

.EE

.br

.br
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.

.br

.br
param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.

.IP "\fBint gpioUpdateScript(unsigned script_id, unsigned numPar, uint32_t *param)\fP"
.IP "" 4
This function sets the parameters of a script.  The script may or
may not be running.  The first numPar parameters of the script are
overwritten with the new values.

.br

.br

.EX
script_id: >=0, as returned by \fBgpioStoreScript\fP
.br
   numPar: 0-10, the number of parameters
.br
    param: an array of parameters
.br

.EE

.br

.br
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.

.br

.br
param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.

.IP "\fBint gpioScriptStatus(unsigned script_id, uint32_t *param)\fP"
.IP "" 4
This function returns the run status of a stored script as well as
the current values of parameters 0 to 9.

.br

.br

.EX
script_id: >=0, as returned by \fBgpioStoreScript\fP
.br
    param: an array to hold the returned 10 parameters
.br

.EE

.br

.br
The function returns greater than or equal to 0 if OK,
otherwise PI_BAD_SCRIPT_ID.

.br

.br
The run status may be

.br

.br

.EX
PI_SCRIPT_INITING
.br
PI_SCRIPT_HALTED
.br
PI_SCRIPT_RUNNING
.br
PI_SCRIPT_WAITING
.br
PI_SCRIPT_FAILED
.br

.EE

.br

.br
The current value of script parameters 0 to 9 are returned in param.

.IP "\fBint gpioStopScript(unsigned script_id)\fP"
.IP "" 4
This function stops a running script.

.br

.br

.EX
script_id: >=0, as returned by \fBgpioStoreScript\fP
.br

.EE

.br

.br
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.

.IP "\fBint gpioDeleteScript(unsigned script_id)\fP"
.IP "" 4
This function deletes a stored script.

.br

.br

.EX
script_id: >=0, as returned by \fBgpioStoreScript\fP
.br

.EE

.br

.br
The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.

.IP "\fBint gpioSetSignalFunc(unsigned signum, gpioSignalFunc_t f)\fP"
.IP "" 4
Registers a function to be called (a callback) when a signal occurs.

.br

.br

.EX
signum: 0-63
.br
     f: the callback function
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_SIGNUM.

.br

.br
The function is passed the signal number.

.br

.br
One function may be registered per signal.

.br

.br
The callback may be cancelled by passing NULL.

.br

.br
By default all signals are treated as fatal and cause the library
to call gpioTerminate and then exit.

.IP "\fBint gpioSetSignalFuncEx(unsigned signum, gpioSignalFuncEx_t f, void *userdata)\fP"
.IP "" 4
Registers a function to be called (a callback) when a signal occurs.

.br

.br

.EX
  signum: 0-63
.br
       f: the callback function
.br
userdata: a pointer to arbitrary user data
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_SIGNUM.

.br

.br
The function is passed the signal number and the userdata pointer.

.br

.br
Only one of gpioSetSignalFunc or gpioSetSignalFuncEx can be
registered per signal.

.br

.br
See gpioSetSignalFunc for further details.

.IP "\fBuint32_t gpioRead_Bits_0_31(void)\fP"
.IP "" 4
Returns the current level of GPIO 0-31.

.IP "\fBuint32_t gpioRead_Bits_32_53(void)\fP"
.IP "" 4
Returns the current level of GPIO 32-53.

.IP "\fBint gpioWrite_Bits_0_31_Clear(uint32_t bits)\fP"
.IP "" 4
Clears GPIO 0-31 if the corresponding bit in bits is set.

.br

.br

.EX
bits: a bit mask of GPIO to clear
.br

.EE

.br

.br
Returns 0 if OK.

.br

.br
\fBExample\fP
.br

.EX
// To clear (set to 0) GPIO 4, 7, and 15
.br
gpioWrite_Bits_0_31_Clear( (1<<4) | (1<<7) | (1<<15) );
.br

.EE

.IP "\fBint gpioWrite_Bits_32_53_Clear(uint32_t bits)\fP"
.IP "" 4
Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.

.br

.br

.EX
bits: a bit mask of GPIO to clear
.br

.EE

.br

.br
Returns 0 if OK.

.IP "\fBint gpioWrite_Bits_0_31_Set(uint32_t bits)\fP"
.IP "" 4
Sets GPIO 0-31 if the corresponding bit in bits is set.

.br

.br

.EX
bits: a bit mask of GPIO to set
.br

.EE

.br

.br
Returns 0 if OK.

.IP "\fBint gpioWrite_Bits_32_53_Set(uint32_t bits)\fP"
.IP "" 4
Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.

.br

.br

.EX
bits: a bit mask of GPIO to set
.br

.EE

.br

.br
Returns 0 if OK.

.br

.br
\fBExample\fP
.br

.EX
// To set (set to 1) GPIO 32, 40, and 53
.br
gpioWrite_Bits_32_53_Set((1<<(32-32)) | (1<<(40-32)) | (1<<(53-32)));
.br

.EE

.IP "\fBint gpioHardwareClock(unsigned gpio, unsigned clkfreq)\fP"
.IP "" 4
Starts a hardware clock on a GPIO at the specified frequency.
Frequencies above 30MHz are unlikely to work.

.br

.br

.EX
   gpio: see description
.br
clkfreq: 0 (off) or 4689-250000000 (250M)
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_NOT_HCLK_GPIO,
PI_BAD_HCLK_FREQ,or PI_BAD_HCLK_PASS.

.br

.br
The same clock is available on multiple GPIO.  The latest
frequency setting will be used by all GPIO which share a clock.

.br

.br
The GPIO must be one of the following.

.br

.br

.EX
4   clock 0  All models
.br
5   clock 1  All models but A and B (reserved for system use)
.br
6   clock 2  All models but A and B
.br
20  clock 0  All models but A and B
.br
21  clock 1  All models but A and Rev.2 B (reserved for system use)
.br

.br
32  clock 0  Compute module only
.br
34  clock 0  Compute module only
.br
42  clock 1  Compute module only (reserved for system use)
.br
43  clock 2  Compute module only
.br
44  clock 1  Compute module only (reserved for system use)
.br

.EE

.br

.br
Access to clock 1 is protected by a password as its use will likely
crash the Pi.  The password is given by or'ing 0x5A000000 with the
GPIO number.

.IP "\fBint gpioHardwarePWM(unsigned gpio, unsigned PWMfreq, unsigned PWMduty)\fP"
.IP "" 4
Starts hardware PWM on a GPIO at the specified frequency and dutycycle.
Frequencies above 30MHz are unlikely to work.

.br

.br
NOTE: Any waveform started by \fBgpioWaveTxSend\fP, or
\fBgpioWaveChain\fP will be cancelled.

.br

.br
This function is only valid if the pigpio main clock is PCM.  The
main clock defaults to PCM but may be overridden by a call to
\fBgpioCfgClock\fP.

.br

.br

.EX
   gpio: see description
.br
PWMfreq: 0 (off) or 1-125000000 (125M)
.br
PWMduty: 0 (off) to 1000000 (1M)(fully on)
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_GPIO, PI_NOT_HPWM_GPIO,
PI_BAD_HPWM_DUTY, PI_BAD_HPWM_FREQ, or PI_HPWM_ILLEGAL.

.br

.br
The same PWM channel is available on multiple GPIO.  The latest
frequency and dutycycle setting will be used by all GPIO which
share a PWM channel.

.br

.br
The GPIO must be one of the following.

.br

.br

.EX
12  PWM channel 0  All models but A and B
.br
13  PWM channel 1  All models but A and B
.br
18  PWM channel 0  All models
.br
19  PWM channel 1  All models but A and B
.br

.br
40  PWM channel 0  Compute module only
.br
41  PWM channel 1  Compute module only
.br
45  PWM channel 1  Compute module only
.br
52  PWM channel 0  Compute module only
.br
53  PWM channel 1  Compute module only
.br

.EE

.br

.br
The actual number of steps beween off and fully on is the
integral part of 250 million divided by PWMfreq.

.br

.br
The actual frequency set is 250 million / steps.

.br

.br
There will only be a million steps for a PWMfreq of 250.
Lower frequencies will have more steps and higher
frequencies will have fewer steps.  PWMduty is
automatically scaled to take this into account.

.IP "\fBint gpioTime(unsigned timetype, int *seconds, int *micros)\fP"
.IP "" 4
Updates the seconds and micros variables with the current time.

.br

.br

.EX
timetype: 0 (relative), 1 (absolute)
.br
 seconds: a pointer to an int to hold seconds
.br
  micros: a pointer to an int to hold microseconds
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_TIMETYPE.

.br

.br
If timetype is PI_TIME_ABSOLUTE updates seconds and micros with the
number of seconds and microseconds since the epoch (1st January 1970).

.br

.br
If timetype is PI_TIME_RELATIVE updates seconds and micros with the
number of seconds and microseconds since the library was initialised.

.br

.br
\fBExample\fP
.br

.EX
int secs, mics;
.br

.br
// print the number of seconds since the library was started
.br
gpioTime(PI_TIME_RELATIVE, &secs, &mics);
.br
printf("library started %d.%03d seconds ago", secs, mics/1000);
.br

.EE

.IP "\fBint gpioSleep(unsigned timetype, int seconds, int micros)\fP"
.IP "" 4
Sleeps for the number of seconds and microseconds specified by seconds
and micros.

.br

.br

.EX
timetype: 0 (relative), 1 (absolute)
.br
 seconds: seconds to sleep
.br
  micros: microseconds to sleep
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_TIMETYPE, PI_BAD_SECONDS,
or PI_BAD_MICROS.

.br

.br
If timetype is PI_TIME_ABSOLUTE the sleep ends when the number of seconds
and microseconds since the epoch (1st January 1970) has elapsed.  System
clock changes are taken into account.

.br

.br
If timetype is PI_TIME_RELATIVE the sleep is for the specified number
of seconds and microseconds.  System clock changes do not effect the
sleep length.

.br

.br
For short delays (say, 50 microseonds or less) use \fBgpioDelay\fP.

.br

.br
\fBExample\fP
.br

.EX
gpioSleep(PI_TIME_RELATIVE, 2, 500000); // sleep for 2.5 seconds
.br

.br
gpioSleep(PI_TIME_RELATIVE, 0, 100000); // sleep for 0.1 seconds
.br

.br
gpioSleep(PI_TIME_RELATIVE, 60, 0);     // sleep for one minute
.br

.EE

.IP "\fBuint32_t gpioDelay(uint32_t micros)\fP"
.IP "" 4
Delays for at least the number of microseconds specified by micros.

.br

.br

.EX
micros: the number of microseconds to sleep
.br

.EE

.br

.br
Returns the actual length of the delay in microseconds.

.br

.br
Delays of 100 microseconds or less use busy waits.

.IP "\fBuint32_t gpioTick(void)\fP"
.IP "" 4
Returns the current system tick.

.br

.br
Tick is the number of microseconds since system boot.

.br

.br
As tick is an unsigned 32 bit quantity it wraps around after
2^32 microseconds, which is approximately 1 hour 12 minutes.

.br

.br
You don't need to worry about the wrap around as long as you
take a tick (uint32_t) from another tick, i.e. the following
code will always provide the correct difference.

.br

.br
\fBExample\fP
.br

.EX
uint32_t startTick, endTick;
.br
int diffTick;
.br

.br
startTick = gpioTick();
.br

.br
// do some processing
.br

.br
endTick = gpioTick();
.br

.br
diffTick = endTick - startTick;
.br

.br
printf("some processing took %d microseconds", diffTick);
.br

.EE

.IP "\fBunsigned gpioHardwareRevision(void)\fP"
.IP "" 4
Returns the hardware revision.

.br

.br
If the hardware revision can not be found or is not a valid hexadecimal
number the function returns 0.

.br

.br
The hardware revision is the last few characters on the Revision line of
/proc/cpuinfo.

.br

.br
The revision number can be used to determine the assignment of GPIO
to pins (see \fBgpio\fP).

.br

.br
There are at least three types of board.

.br

.br
Type 1 boards have hardware revision numbers of 2 and 3.

.br

.br
Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.

.br

.br
Type 3 boards have hardware revision numbers of 16 or greater.

.br

.br
for "Revision       : 0002" the function returns 2.
.br
for "Revision       : 000f" the function returns 15.
.br
for "Revision       : 000g" the function returns 0.

.IP "\fBunsigned gpioVersion(void)\fP"
.IP "" 4
Returns the pigpio version.

.IP "\fBint gpioGetPad(unsigned pad)\fP"
.IP "" 4
This function returns the pad drive strength in mA.

.br

.br

.EX
pad: 0-2, the pad to get
.br

.EE

.br

.br
Returns the pad drive strength if OK, otherwise PI_BAD_PAD.

.br

.br
Pad   GPIO
.br
0     0-27
.br
1     28-45
.br
2     46-53
.br

.br

.br
\fBExample\fP
.br

.EX
strength = gpioGetPad(1); // get pad 1 strength
.br

.EE

.IP "\fBint gpioSetPad(unsigned pad, unsigned padStrength)\fP"
.IP "" 4
This function sets the pad drive strength in mA.

.br

.br

.EX
        pad: 0-2, the pad to set
.br
padStrength: 1-16 mA
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_PAD, or PI_BAD_STRENGTH.

.br

.br
Pad   GPIO
.br
0     0-27
.br
1     28-45
.br
2     46-53
.br

.br

.br
\fBExample\fP
.br

.EX
gpioSetPad(0, 16); // set pad 0 strength to 16 mA
.br

.EE

.IP "\fBint eventMonitor(unsigned handle, uint32_t bits)\fP"
.IP "" 4
This function selects the events to be reported on a previously
opened handle.

.br

.br

.EX
handle: >=0, as returned by \fBgpioNotifyOpen\fP
.br
  bits: a bit mask indicating the events of interest
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.br

.br
A report is sent each time an event is triggered providing the
corresponding bit in bits is set.

.br

.br
See \fBgpioNotifyBegin\fP for the notification format.

.br

.br
\fBExample\fP
.br

.EX
// Start reporting events 3, 6, and 7.
.br

.br
//  bit      76543210
.br
// (0xC8 = 0b11001000)
.br

.br
eventMonitor(h, 0xC8);
.br

.EE

.br

.br

.IP "\fBint eventSetFunc(unsigned event, eventFunc_t f)\fP"
.IP "" 4
Registers a function to be called (a callback) when the specified
event occurs.

.br

.br

.EX
event: 0-31
.br
    f: the callback function
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_EVENT_ID.

.br

.br
One function may be registered per event.

.br

.br
The function is passed the event, and the tick.

.br

.br
The callback may be cancelled by passing NULL as the function.

.IP "\fBint eventSetFuncEx(unsigned event, eventFuncEx_t f, void *userdata)\fP"
.IP "" 4
Registers a function to be called (a callback) when the specified
event occurs.

.br

.br

.EX
   event: 0-31
.br
       f: the callback function
.br
userdata: pointer to arbitrary user data
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_EVENT_ID.

.br

.br
One function may be registered per event.

.br

.br
The function is passed the event, the tick, and the ueserdata pointer.

.br

.br
The callback may be cancelled by passing NULL as the function.

.br

.br
Only one of \fBeventSetFunc\fP or \fBeventSetFuncEx\fP can be
registered per event.

.IP "\fBint eventTrigger(unsigned event)\fP"
.IP "" 4
This function signals the occurrence of an event.

.br

.br

.EX
event: 0-31, the event
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_EVENT_ID.

.br

.br
An event is a signal used to inform one or more consumers
to start an action.  Each consumer which has registered an interest
in the event (e.g. by calling \fBeventSetFunc\fP) will be informed by
a callback.

.br

.br
One event, PI_EVENT_BSC (31) is predefined.  This event is
auto generated on BSC slave activity.

.br

.br
The meaning of other events is arbitrary.

.br

.br
Note that other than its id and its tick there is no data associated
with an event.

.IP "\fBint shell(char *scriptName, char *scriptString)\fP"
.IP "" 4
This function uses the system call to execute a shell script
with the given string as its parameter.

.br

.br

.EX
  scriptName: the name of the script, only alphanumeric characters,
.br
              '-' and '_' are allowed in the name
.br
scriptString: the string to pass to the script
.br

.EE

.br

.br
The exit status of the system call is returned if OK, otherwise
PI_BAD_SHELL_STATUS.

.br

.br
scriptName must exist in /opt/pigpio/cgi and must be executable.

.br

.br
The returned exit status is normally 256 times that set by the
shell script exit function.  If the script can't be found 32512 will
be returned.

.br

.br
The following table gives some example returned statuses.

.br

.br
Script exit status   Returned system call status
.br
1                    256
.br
5                    1280
.br
10                   2560
.br
200                  51200
.br
script not found     32512
.br

.br

.br
\fBExample\fP
.br

.EX
// pass two parameters, hello and world
.br
status = shell("scr1", "hello world");
.br

.br
// pass three parameters, hello, string with spaces, and world
.br
status = shell("scr1", "hello 'string with spaces' world");
.br

.br
// pass one parameter, hello string with spaces world
.br
status = shell("scr1", "\"hello string with spaces world\"");
.br

.EE

.IP "\fBint fileOpen(char *file, unsigned mode)\fP"
.IP "" 4
This function returns a handle to a file opened in a specified mode.

.br

.br

.EX
file: the file to open
.br
mode: the file open mode
.br

.EE

.br

.br
Returns a handle (>=0) if OK, otherwise PI_NO_HANDLE, PI_NO_FILE_ACCESS,
PI_BAD_FILE_MODE, PI_FILE_OPEN_FAILED, or PI_FILE_IS_A_DIR.

.br

.br
File

.br

.br
A file may only be opened if permission is granted by an entry in
/opt/pigpio/access.  This is intended to allow remote access to files
in a more or less controlled manner.

.br

.br
Each entry in /opt/pigpio/access takes the form of a file path
which may contain wildcards followed by a single letter permission.
The permission may be R for read, W for write, U for read/write,
and N for no access.

.br

.br
Where more than one entry matches a file the most specific rule
applies.  If no entry matches a file then access is denied.

.br

.br
Suppose /opt/pigpio/access contains the following entries

.br

.br

.EX
/home/* n
.br
/home/pi/shared/dir_1/* w
.br
/home/pi/shared/dir_2/* r
.br
/home/pi/shared/dir_3/* u
.br
/home/pi/shared/dir_1/file.txt n
.br

.EE

.br

.br
Files may be written in directory dir_1 with the exception
of file.txt.

.br

.br
Files may be read in directory dir_2.

.br

.br
Files may be read and written in directory dir_3.

.br

.br
If a directory allows read, write, or read/write access then files may
be created in that directory.

.br

.br
In an attempt to prevent risky permissions the following paths are
ignored in /opt/pigpio/access.

.br

.br

.EX
a path containing ..
.br
a path containing only wildcards (*?)
.br
a path containing less than two non-wildcard parts
.br

.EE

.br

.br
Mode

.br

.br
The mode may have the following values.

.br

.br
Macro           Value   Meaning
.br
PI_FILE_READ      1     open file for reading
.br
PI_FILE_WRITE     2     open file for writing
.br
PI_FILE_RW        3     open file for reading and writing
.br

.br

.br
The following values may be or'd into the mode.

.br

.br
Macro            Value   Meaning
.br
PI_FILE_APPEND   4       Writes append data to the end of the file
.br
PI_FILE_CREATE   8       The file is created if it doesn't exist
.br
PI_FILE_TRUNC    16      The file is truncated
.br

.br

.br
Newly created files are owned by root with permissions owner read and write.

.br

.br
\fBExample\fP
.br

.EX
#include <stdio.h>
.br
#include <pigpio.h>
.br

.br
int main(int argc, char *argv[])
.br
{
.br
   int handle, c;
.br
   char buf[60000];
.br

.br
   if (gpioInitialise() < 0) return 1;
.br

.br
   // assumes /opt/pigpio/access contains the following line
.br
   // /ram/*.c r
.br

.br
   handle = fileOpen("/ram/pigpio.c", PI_FILE_READ);
.br

.br
   if (handle >= 0)
.br
   {
.br
      while ((c=fileRead(handle, buf, sizeof(buf)-1)))
.br
      {
.br
         buf[c] = 0;
.br
         printf("%s", buf);
.br
      }
.br

.br
      fileClose(handle);
.br
   }
.br

.br
   gpioTerminate();
.br
}
.br

.EE

.IP "\fBint fileClose(unsigned handle)\fP"
.IP "" 4
This function closes the file associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBfileOpen\fP
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE.

.br

.br
\fBExample\fP
.br

.EX
fileClose(h);
.br

.EE

.IP "\fBint fileWrite(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This function writes count bytes from buf to the the file
associated with handle.

.br

.br

.EX
handle: >=0, as returned by a call to \fBfileOpen\fP
.br
   buf: the array of bytes to write
.br
 count: the number of bytes to write
.br

.EE

.br

.br
Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM,
PI_FILE_NOT_WOPEN, or PI_BAD_FILE_WRITE.

.br

.br
\fBExample\fP
.br

.EX
status = fileWrite(h, buf, count);
.br
if (status == 0)
.br
{
.br
   // okay
.br
}
.br
else
.br
{
.br
   // error
.br
}
.br

.EE

.IP "\fBint fileRead(unsigned handle, char *buf, unsigned count)\fP"
.IP "" 4
This function reads up to count bytes from the the file
associated with handle and writes them to buf.

.br

.br

.EX
handle: >=0, as returned by a call to \fBfileOpen\fP
.br
   buf: an array to receive the read data
.br
 count: the maximum number of bytes to read
.br

.EE

.br

.br
Returns the number of bytes read (>=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, PI_FILE_NOT_ROPEN, or PI_BAD_FILE_WRITE.

.br

.br
\fBExample\fP
.br

.EX
if (fileRead(h, buf, sizeof(buf)) > 0)
.br
{
.br
   // process read data
.br
}
.br

.EE

.IP "\fBint fileSeek(unsigned handle, int32_t seekOffset, int seekFrom)\fP"
.IP "" 4
This function seeks to a position within the file associated
with handle.

.br

.br

.EX
    handle: >=0, as returned by a call to \fBfileOpen\fP
.br
seekOffset: the number of bytes to move.  Positive offsets
.br
            move forward, negative offsets backwards.
.br
  seekFrom: one of PI_FROM_START (0), PI_FROM_CURRENT (1),
.br
            or PI_FROM_END (2)
.br

.EE

.br

.br
Returns the new byte position within the file (>=0) if OK, otherwise PI_BAD_HANDLE, or PI_BAD_FILE_SEEK.

.br

.br
\fBExample\fP
.br

.EX
fileSeek(0, 20, PI_FROM_START); // Seek to start plus 20
.br

.br
size = fileSeek(0, 0, PI_FROM_END); // Seek to end, return size
.br

.br
pos = fileSeek(0, 0, PI_FROM_CURRENT); // Return current position
.br

.EE

.IP "\fBint fileList(char *fpat, char *buf, unsigned count)\fP"
.IP "" 4
This function returns a list of files which match a pattern.  The
pattern may contain wildcards.

.br

.br

.EX
 fpat: file pattern to match
.br
  buf: an array to receive the matching file names
.br
count: the maximum number of bytes to read
.br

.EE

.br

.br
Returns the number of returned bytes if OK, otherwise PI_NO_FILE_ACCESS,
or PI_NO_FILE_MATCH.

.br

.br
The pattern must match an entry in /opt/pigpio/access.  The pattern
may contain wildcards.  See \fBfileOpen\fP.

.br

.br
NOTE

.br

.br
The returned value is not the number of files, it is the number
of bytes in the buffer.  The file names are separated by newline
characters.

.br

.br
\fBExample\fP
.br

.EX
#include <stdio.h>
.br
#include <pigpio.h>
.br

.br
int main(int argc, char *argv[])
.br
{
.br
   int c;
.br
   char buf[1000];
.br

.br
   if (gpioInitialise() < 0) return 1;
.br

.br
   // assumes /opt/pigpio/access contains the following line
.br
   // /ram/*.c r
.br

.br
   c = fileList("/ram/p*.c", buf, sizeof(buf));
.br

.br
   if (c >= 0)
.br
   {
.br
      // terminate string
.br
      buf[c] = 0;
.br
      printf("%s", buf);
.br
   }
.br

.br
   gpioTerminate();
.br
}
.br

.EE

.IP "\fBint gpioCfgBufferSize(unsigned cfgMillis)\fP"
.IP "" 4
Configures pigpio to buffer cfgMillis milliseconds of GPIO samples.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
cfgMillis: 100-10000
.br

.EE

.br

.br
The default setting is 120 milliseconds.

.br

.br
The intention is to allow for bursts of data and protection against
other processes hogging cpu time.

.br

.br
I haven't seen a process locked out for more than 100 milliseconds.

.br

.br
Making the buffer bigger uses a LOT of memory at the more frequent
sampling rates as shown in the following table in MBs.

.br

.br

.EX
                     buffer milliseconds
.br
               120 250 500 1sec 2sec 4sec 8sec
.br

.br
         1      16  31  55  107  ---  ---  ---
.br
         2      10  18  31   55  107  ---  ---
.br
sample   4       8  12  18   31   55  107  ---
.br
 rate    5       8  10  14   24   45   87  ---
.br
 (us)    8       6   8  12   18   31   55  107
.br
        10       6   8  10   14   24   45   87
.br

.EE

.IP "\fBint gpioCfgClock(unsigned cfgMicros, unsigned cfgPeripheral, unsigned cfgSource)\fP"
.IP "" 4
Configures pigpio to use a particular sample rate timed by a specified
peripheral.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
    cfgMicros: 1, 2, 4, 5, 8, 10
.br
cfgPeripheral: 0 (PWM), 1 (PCM)
.br
    cfgSource: deprecated, value is ignored
.br

.EE

.br

.br
The timings are provided by the specified peripheral (PWM or PCM).

.br

.br
The default setting is 5 microseconds using the PCM peripheral.

.br

.br
The approximate CPU percentage used for each sample rate is:

.br

.br

.EX
sample  cpu
.br
 rate    %
.br

.br
  1     25
.br
  2     16
.br
  4     11
.br
  5     10
.br
  8     15
.br
 10     14
.br

.EE

.br

.br
A sample rate of 5 microseconds seeems to be the sweet spot.

.IP "\fBint gpioCfgDMAchannel(unsigned DMAchannel)\fP"
.IP "" 4
Configures pigpio to use the specified DMA channel.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
DMAchannel: 0-14
.br

.EE

.br

.br
The default setting is to use channel 14.

.IP "\fBint gpioCfgDMAchannels(unsigned primaryChannel, unsigned secondaryChannel)\fP"
.IP "" 4
Configures pigpio to use the specified DMA channels.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
  primaryChannel: 0-14
.br
secondaryChannel: 0-14
.br

.EE

.br

.br
The default setting is to use channel 14 for the primary channel and
channel 6 for the secondary channel.

.br

.br
The secondary channel is only used for the transmission of waves.

.br

.br
If possible use one of channels 0 to 6 for the secondary channel
(a full channel).

.br

.br
A full channel only requires one DMA control block regardless of the
length of a pulse delay.  Channels 7 to 14 (lite channels) require
one DMA control block for each 16383 microseconds of delay.  I.e.
a 10 second pulse delay requires one control block on a full channel
and 611 control blocks on a lite channel.

.IP "\fBint gpioCfgPermissions(uint64_t updateMask)\fP"
.IP "" 4
Configures pigpio to restrict GPIO updates via the socket or pipe
interfaces to the GPIO specified by the mask.  Programs directly
calling the pigpio library (i.e. linked with -lpigpio are not
affected).  A GPIO update is a write to a GPIO or a GPIO mode
change or any function which would force such an action.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
updateMask: bit (1<<n) is set for each GPIO n which may be updated
.br

.EE

.br

.br
The default setting depends upon the Pi model. The user GPIO are
added to the mask.

.br

.br
If the board revision is not recognised then GPIO 2-27 are allowed.

.br

.br
Unknown board   PI_DEFAULT_UPDATE_MASK_UNKNOWN   0x0FFFFFFC
.br
.br
Type 1 board    PI_DEFAULT_UPDATE_MASK_B1   0x03E6CF93
.br
.br
Type 2 board    PI_DEFAULT_UPDATE_MASK_A_B2   0xFBC6CF9C
.br
Type 3 board    PI_DEFAULT_UPDATE_MASK_R3   0x0FFFFFFC
.br

.IP "\fBint gpioCfgSocketPort(unsigned port)\fP"
.IP "" 4
Configures pigpio to use the specified socket port.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
port: 1024-32000
.br

.EE

.br

.br
The default setting is to use port 8888.

.IP "\fBint gpioCfgInterfaces(unsigned ifFlags)\fP"
.IP "" 4
Configures pigpio support of the fifo and socket interfaces.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
ifFlags: 0-7
.br

.EE

.br

.br
The default setting (0) is that both interfaces are enabled.

.br

.br
Or in PI_DISABLE_FIFO_IF to disable the pipe interface.

.br

.br
Or in PI_DISABLE_SOCK_IF to disable the socket interface.

.br

.br
Or in PI_LOCALHOST_SOCK_IF to disable remote socket
access (this means that the socket interface is only
usable from the local Pi).

.IP "\fBint gpioCfgMemAlloc(unsigned memAllocMode)\fP"
.IP "" 4
Selects the method of DMA memory allocation.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
memAllocMode: 0-2
.br

.EE

.br

.br
There are two methods of DMA memory allocation.  The original method
uses the /proc/self/pagemap file to allocate bus memory.  The new
method uses the mailbox property interface to allocate bus memory.

.br

.br
Auto will use the mailbox method unless a larger than default buffer
size is requested with \fBgpioCfgBufferSize\fP.

.IP "\fBint gpioCfgNetAddr(int numSockAddr, uint32_t *sockAddr)\fP"
.IP "" 4
Sets the network addresses which are allowed to talk over the
socket interface.

.br

.br
This function is only effective if called before \fBgpioInitialise\fP.

.br

.br

.EX
numSockAddr: 0-256 (0 means all addresses allowed)
.br
   sockAddr: an array of permitted network addresses.
.br

.EE

.IP "\fBint gpioCfgInternals(unsigned cfgWhat, unsigned cfgVal)\fP"
.IP "" 4
Used to tune internal settings.

.br

.br

.EX
cfgWhat: see source code
.br
 cfgVal: see source code
.br

.EE

.IP "\fBuint32_t gpioCfgGetInternals(void)\fP"
.IP "" 4
This function returns the current library internal configuration
settings.

.IP "\fBint gpioCfgSetInternals(uint32_t cfgVal)\fP"
.IP "" 4
This function sets the current library internal configuration
settings.

.br

.br

.EX
cfgVal: see source code
.br

.EE

.IP "\fBint gpioCustom1(unsigned arg1, unsigned arg2, char *argx, unsigned argc)\fP"
.IP "" 4
This function is available for user customisation.

.br

.br
It returns a single integer value.

.br

.br

.EX
arg1: >=0
.br
arg2: >=0
.br
argx: extra (byte) arguments
.br
argc: number of extra arguments
.br

.EE

.br

.br
Returns >= 0 if OK, less than 0 indicates a user defined error.

.IP "\fBint gpioCustom2(unsigned arg1, char *argx, unsigned argc, char *retBuf, unsigned retMax)\fP"
.IP "" 4
This function is available for user customisation.

.br

.br
It differs from gpioCustom1 in that it returns an array of bytes
rather than just an integer.

.br

.br
The returned value is an integer indicating the number of returned bytes.

.EX
  arg1: >=0
.br
  argx: extra (byte) arguments
.br
  argc: number of extra arguments
.br
retBuf: buffer for returned bytes
.br
retMax: maximum number of bytes to return
.br

.EE

.br

.br
Returns >= 0 if OK, less than 0 indicates a user defined error.

.br

.br
The number of returned bytes must be retMax or less.

.IP "\fBint rawWaveAddSPI(rawSPI_t *spi, unsigned offset, unsigned spiSS, char *buf, unsigned spiTxBits, unsigned spiBitFirst, unsigned spiBitLast, unsigned spiBits)\fP"
.IP "" 4
This function adds a waveform representing SPI data to the
existing waveform (if any).

.br

.br

.EX
        spi: a pointer to a spi object
.br
     offset: microseconds from the start of the waveform
.br
      spiSS: the slave select GPIO
.br
        buf: the bits to transmit, most significant bit first
.br
  spiTxBits: the number of bits to write
.br
spiBitFirst: the first bit to read
.br
 spiBitLast: the last bit to read
.br
    spiBits: the number of bits to transfer
.br

.EE

.br

.br
Returns the new total number of pulses in the current waveform if OK,
otherwise PI_BAD_USER_GPIO, PI_BAD_SER_OFFSET, or PI_TOO_MANY_PULSES.

.br

.br
Not intended for general use.

.IP "\fBint rawWaveAddGeneric(unsigned numPulses, rawWave_t *pulses)\fP"
.IP "" 4
This function adds a number of pulses to the current waveform.

.br

.br

.EX
numPulses: the number of pulses
.br
   pulses: the array containing the pulses
.br

.EE

.br

.br
Returns the new total number of pulses in the current waveform if OK,
otherwise PI_TOO_MANY_PULSES.

.br

.br
The advantage of this function over gpioWaveAddGeneric is that it
allows the setting of the flags field.

.br

.br
The pulses are interleaved in time order within the existing waveform
(if any).

.br

.br
Merging allows the waveform to be built in parts, that is the settings
for GPIO#1 can be added, and then GPIO#2 etc.

.br

.br
If the added waveform is intended to start after or within the existing
waveform then the first pulse should consist of a delay.

.br

.br
Not intended for general use.

.IP "\fBunsigned rawWaveCB(void)\fP"
.IP "" 4
Returns the number of the cb being currently output.

.br

.br
Not intended for general use.

.IP "\fBrawCbs_t *rawWaveCBAdr(int cbNum)\fP"
.IP "" 4
Return the (Linux) address of contol block cbNum.

.br

.br

.EX
cbNum: the cb of interest
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBuint32_t rawWaveGetOOL(int pos)\fP"
.IP "" 4
Gets the OOL parameter stored at pos.

.br

.br

.EX
pos: the position of interest.
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBvoid rawWaveSetOOL(int pos, uint32_t lVal)\fP"
.IP "" 4
Sets the OOL parameter stored at pos to value.

.br

.br

.EX
 pos: the position of interest
.br
lVal: the value to write
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBuint32_t rawWaveGetOut(int pos)\fP"
.IP "" 4
Gets the wave output parameter stored at pos.

.br

.br
DEPRECATED: use rawWaveGetOOL instead.

.br

.br

.EX
pos: the position of interest.
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBvoid rawWaveSetOut(int pos, uint32_t lVal)\fP"
.IP "" 4
Sets the wave output parameter stored at pos to value.

.br

.br
DEPRECATED: use rawWaveSetOOL instead.

.br

.br

.EX
 pos: the position of interest
.br
lVal: the value to write
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBuint32_t rawWaveGetIn(int pos)\fP"
.IP "" 4
Gets the wave input value parameter stored at pos.

.br

.br
DEPRECATED: use rawWaveGetOOL instead.

.br

.br

.EX
pos: the position of interest
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBvoid rawWaveSetIn(int pos, uint32_t lVal)\fP"
.IP "" 4
Sets the wave input value stored at pos to value.

.br

.br
DEPRECATED: use rawWaveSetOOL instead.

.br

.br

.EX
 pos: the position of interest
.br
lVal: the value to write
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBrawWaveInfo_t rawWaveInfo(int wave_id)\fP"
.IP "" 4
Gets details about the wave with id wave_id.

.br

.br

.EX
wave_id: the wave of interest
.br

.EE

.br

.br
Not intended for general use.

.IP "\fBint getBitInBytes(int bitPos, char *buf, int numBits)\fP"
.IP "" 4
Returns the value of the bit bitPos bits from the start of buf.  Returns
0 if bitPos is greater than or equal to numBits.

.br

.br

.EX
 bitPos: bit index from the start of buf
.br
    buf: array of bits
.br
numBits: number of valid bits in buf
.br

.EE

.br

.br

.IP "\fBvoid putBitInBytes(int bitPos, char *buf, int bit)\fP"
.IP "" 4
Sets the bit bitPos bits from the start of buf to bit.

.br

.br

.EX
bitPos: bit index from the start of buf
.br
   buf: array of bits
.br
   bit: 0-1, value to set
.br

.EE

.br

.br

.IP "\fBdouble time_time(void)\fP"
.IP "" 4
Return the current time in seconds since the Epoch.

.IP "\fBvoid time_sleep(double seconds)\fP"
.IP "" 4
Delay execution for a given number of seconds

.br

.br

.EX
seconds: the number of seconds to sleep
.br

.EE

.IP "\fBvoid rawDumpWave(void)\fP"
.IP "" 4
Used to print a readable version of the current waveform to stderr.

.br

.br
Not intended for general use.

.IP "\fBvoid rawDumpScript(unsigned script_id)\fP"
.IP "" 4
Used to print a readable version of a script to stderr.

.br

.br

.EX
script_id: >=0, a script_id returned by \fBgpioStoreScript\fP
.br

.EE

.br

.br
Not intended for general use.
.SH PARAMETERS

.br

.br

.IP "\fBactive\fP: 0-1000000" 0

.br

.br
The number of microseconds level changes are reported for once
a noise filter has been triggered (by \fBsteady\fP microseconds of
a stable level).

.br

.br

.IP "\fBarg1\fP" 0

.br

.br
An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.

.br

.br

.IP "\fBarg2\fP" 0

.br

.br
An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.

.br

.br

.IP "\fBargc\fP" 0
The count of bytes passed to a user customised function.

.br

.br

.IP "\fB*argx\fP" 0
A pointer to an array of bytes passed to a user customised function.
Its meaning and content is defined by the customiser.

.br

.br

.IP "\fBbaud\fP" 0
The speed of serial communication (I2C, SPI, serial link, waves) in
bits per second.

.br

.br

.IP "\fBbit\fP" 0
A value of 0 or 1.

.br

.br

.IP "\fBbitPos\fP" 0
A bit position within a byte or word.  The least significant bit is
position 0.

.br

.br

.IP "\fBbits\fP" 0
A value used to select GPIO.  If bit n of bits is set then GPIO n is
selected.

.br

.br
A convenient way to set bit n is to or in (1<<n).

.br

.br
e.g. to select bits 5, 9, 23 you could use (1<<5) | (1<<9) | (1<<23).

.br

.br

.IP "\fB*bsc_xfer\fP" 0
A pointer to a \fBbsc_xfer_t\fP object used to control a BSC transfer.

.br

.br

.IP "\fBbsc_xfer_t\fP" 0

.br

.br

.EX
typedef struct
.br
{
.br
   uint32_t control;          // Write
.br
   int rxCnt;                 // Read only
.br
   char rxBuf[BSC_FIFO_SIZE]; // Read only
.br
   int txCnt;                 // Write
.br
   char txBuf[BSC_FIFO_SIZE]; // Write
.br
} bsc_xfer_t;
.br

.EE

.br

.br

.IP "\fB*buf\fP" 0

.br

.br
A buffer to hold data being sent or being received.

.br

.br

.IP "\fBbufSize\fP" 0

.br

.br
The size in bytes of a buffer.

.br

.br

.IP "\fBbVal\fP: 0-255 (Hex 0x0-0xFF, Octal 0-0377)" 0

.br

.br
An 8-bit byte value.

.br

.br

.IP "\fBcbNum\fP" 0

.br

.br
A number identifying a DMA contol block.

.br

.br

.IP "\fBcfgMicros\fP" 0

.br

.br
The GPIO sample rate in microseconds.  The default is 5us, or 200 thousand
samples per second.

.br

.br

.IP "\fBcfgMillis\fP: 100-10000" 0

.br

.br
The size of the sample buffer in milliseconds.  Generally this should be
left at the default of 120ms.  If you expect intense bursts of signals it
might be necessary to increase the buffer size.

.br

.br

.IP "\fBcfgPeripheral\fP" 0

.br

.br
One of the PWM or PCM peripherals used to pace DMA transfers for timing
purposes.

.br

.br

.IP "\fBcfgSource\fP" 0

.br

.br
Deprecated.

.br

.br

.IP "\fBcfgVal\fP" 0

.br

.br
A number specifying the value of a configuration item.  See \fBcfgWhat\fP.

.br

.br

.IP "\fBcfgWhat\fP" 0

.br

.br
A number specifying a configuration item.

.br

.br
562484977: print enhanced statistics at termination.
.br
984762879: set the initial debug level.

.br

.br

.IP "\fBchar\fP" 0

.br

.br
A single character, an 8 bit quantity able to store 0-255.

.br

.br

.IP "\fBclkfreq\fP: 4689-250M" 0

.br

.br
The hardware clock frequency.

.br

.br

.EX
PI_HW_CLK_MIN_FREQ 4689
.br
PI_HW_CLK_MAX_FREQ 250000000
.br

.EE

.br

.br

.IP "\fBcount\fP" 0
The number of bytes to be transferred in an I2C, SPI, or Serial
command.

.br

.br

.IP "\fBCS\fP" 0
The GPIO used for the slave select signal when bit banging SPI.

.br

.br

.IP "\fBdata_bits\fP: 1-32" 0

.br

.br
The number of data bits to be used when adding serial data to a
waveform.

.br

.br

.EX
PI_MIN_WAVE_DATABITS 1
.br
PI_MAX_WAVE_DATABITS 32
.br

.EE

.br

.br

.IP "\fBDMAchannel\fP: 0-14" 0

.EX
PI_MIN_DMA_CHANNEL 0
.br
PI_MAX_DMA_CHANNEL 14
.br

.EE

.br

.br

.IP "\fBdouble\fP" 0

.br

.br
A floating point number.

.br

.br

.IP "\fBdutycycle\fP: 0-range" 0

.br

.br
A number representing the ratio of on time to off time for PWM.

.br

.br
The number may vary between 0 and range (default 255) where
0 is off and range is fully on.

.br

.br

.IP "\fBedge\fP: 0-2" 0
The type of GPIO edge to generate an interrupt.  See \fBgpioSetISRFunc\fP
and \fBgpioSetISRFuncEx\fP.

.br

.br

.EX
RISING_EDGE 0
.br
FALLING_EDGE 1
.br
EITHER_EDGE 2
.br

.EE

.br

.br

.IP "\fBevent\fP: 0-31" 0
An event is a signal used to inform one or more consumers
to start an action.

.br

.br

.IP "\fBeventFunc_t\fP" 0

.EX
typedef void (*eventFunc_t) (int event, uint32_t tick);
.br

.EE

.br

.br

.IP "\fBeventFuncEx_t\fP" 0

.EX
typedef void (*eventFuncEx_t)
.br
   (int event, uint32_t tick, void *userdata);
.br

.EE

.br

.br

.IP "\fBf\fP" 0

.br

.br
A function.

.br

.br

.IP "\fB*file\fP" 0
A full file path.  To be accessible the path must match an entry in
/opt/pigpio/access.

.br

.br

.IP "\fB*fpat\fP" 0
A file path which may contain wildcards.  To be accessible the path
must match an entry in /opt/pigpio/access.

.br

.br

.IP "\fBfrequency\fP: >=0" 0

.br

.br
The number of times a GPIO is swiched on and off per second.  This
can be set per GPIO and may be as little as 5Hz or as much as
40KHz.  The GPIO will be on for a proportion of the time as defined
by its dutycycle.

.br

.br

.IP "\fBgpio\fP" 0

.br

.br
A Broadcom numbered GPIO, in the range 0-53.

.br

.br
There  are 54 General Purpose Input Outputs (GPIO) named GPIO0 through
GPIO53.

.br

.br
They are split into two  banks.   Bank  1  consists  of  GPIO0  through
GPIO31.  Bank 2 consists of GPIO32 through GPIO53.

.br

.br
All the GPIO which are safe for the user to read and write are in
bank 1.  Not all GPIO in bank 1 are safe though.  Type 1 boards
have 17  safe GPIO.  Type 2 boards have 21.  Type 3 boards have 26.

.br

.br
See \fBgpioHardwareRevision\fP.

.br

.br
The user GPIO are marked with an X in the following table.

.br

.br

.EX
          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
.br
Type 1    X  X  -  -  X  -  -  X  X  X  X  X  -  -  X  X
.br
Type 2    -  -  X  X  X  -  -  X  X  X  X  X  -  -  X  X
.br
Type 3          X  X  X  X  X  X  X  X  X  X  X  X  X  X
.br

.br
         16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
.br
Type 1    -  X  X  -  -  X  X  X  X  X  -  -  -  -  -  -
.br
Type 2    -  X  X  -  -  -  X  X  X  X  -  X  X  X  X  X
.br
Type 3    X  X  X  X  X  X  X  X  X  X  X  X  -  -  -  -
.br

.EE

.br

.br

.IP "\fBgpioAlertFunc_t\fP" 0

.EX
typedef void (*gpioAlertFunc_t) (int gpio, int level, uint32_t tick);
.br

.EE

.br

.br

.IP "\fBgpioAlertFuncEx_t\fP" 0

.EX
typedef void (*eventFuncEx_t)
.br
   (int event, int level, uint32_t tick, void *userdata);
.br

.EE

.br

.br

.IP "\fBgpioCfg*\fP" 0

.br

.br
These functions are only effective if called before \fBgpioInitialise\fP.

.br

.br
\fBgpioCfgBufferSize\fP
.br
\fBgpioCfgClock\fP
.br
\fBgpioCfgDMAchannel\fP
.br
\fBgpioCfgDMAchannels\fP
.br
\fBgpioCfgPermissions\fP
.br
\fBgpioCfgInterfaces\fP
.br
\fBgpioCfgSocketPort\fP
.br
\fBgpioCfgMemAlloc\fP

.br

.br

.IP "\fBgpioGetSamplesFunc_t\fP" 0

.EX
typedef void (*gpioGetSamplesFunc_t)
.br
   (const gpioSample_t *samples, int numSamples);
.br

.EE

.br

.br

.IP "\fBgpioGetSamplesFuncEx_t\fP" 0

.EX
typedef void (*gpioGetSamplesFuncEx_t)
.br
   (const gpioSample_t *samples, int numSamples, void *userdata);
.br

.EE

.br

.br

.IP "\fBgpioISRFunc_t\fP" 0

.EX
typedef void (*gpioISRFunc_t)
.br
   (int gpio, int level, uint32_t tick);
.br

.EE

.br

.br

.IP "\fBgpioISRFuncEx_t\fP" 0

.EX
typedef void (*gpioISRFuncEx_t)
.br
   (int gpio, int level, uint32_t tick, void *userdata);
.br

.EE

.br

.br

.IP "\fBgpioPulse_t\fP" 0

.EX
typedef struct
.br
{
.br
   uint32_t gpioOn;
.br
   uint32_t gpioOff;
.br
   uint32_t usDelay;
.br
} gpioPulse_t;
.br

.EE

.br

.br

.IP "\fBgpioSample_t\fP" 0

.EX
typedef struct
.br
{
.br
   uint32_t tick;
.br
   uint32_t level;
.br
} gpioSample_t;
.br

.EE

.br

.br

.IP "\fBgpioSignalFunc_t\fP" 0

.EX
typedef void (*gpioSignalFunc_t) (int signum);
.br

.EE

.br

.br

.IP "\fBgpioSignalFuncEx_t\fP" 0

.EX
typedef void (*gpioSignalFuncEx_t) (int signum, void *userdata);
.br

.EE

.br

.br

.IP "\fBgpioThreadFunc_t\fP" 0

.EX
typedef void *(gpioThreadFunc_t) (void *);
.br

.EE

.br

.br

.IP "\fBgpioTimerFunc_t\fP" 0

.EX
typedef void (*gpioTimerFunc_t) (void);
.br

.EE

.br

.br

.IP "\fBgpioTimerFuncEx_t\fP" 0

.EX
typedef void (*gpioTimerFuncEx_t) (void *userdata);
.br

.EE

.br

.br

.IP "\fBgpioWaveAdd*\fP" 0

.br

.br
One of

.br

.br
\fBgpioWaveAddNew\fP
.br
\fBgpioWaveAddGeneric\fP
.br
\fBgpioWaveAddSerial\fP

.br

.br

.IP "\fBhandle\fP: >=0" 0

.br

.br
A number referencing an object opened by one of

.br

.br
\fBfileOpen\fP
.br
\fBgpioNotifyOpen\fP
.br
\fBi2cOpen\fP
.br
\fBserOpen\fP
.br
\fBspiOpen\fP

.br

.br

.IP "\fBi2cAddr\fP: 0-0x7F" 0
The address of a device on the I2C bus.

.br

.br

.IP "\fBi2cBus\fP: >=0" 0

.br

.br
An I2C bus number.

.br

.br

.IP "\fBi2cFlags\fP: 0" 0

.br

.br
Flags which modify an I2C open command.  None are currently defined.

.br

.br

.IP "\fBi2cReg\fP: 0-255" 0

.br

.br
A register of an I2C device.

.br

.br

.IP "\fBifFlags\fP: 0-3" 0

.EX
PI_DISABLE_FIFO_IF 1
.br
PI_DISABLE_SOCK_IF 2
.br

.EE

.br

.br

.IP "\fB*inBuf\fP" 0
A buffer used to pass data to a function.

.br

.br

.IP "\fBinLen\fP" 0
The number of bytes of data in a buffer.

.br

.br

.IP "\fBint\fP" 0
A whole number, negative or positive.

.br

.br

.IP "\fBint32_t\fP" 0
A 32-bit signed value.

.br

.br

.IP "\fBinvert\fP" 0
A flag used to set normal or inverted bit bang serial data level logic.

.br

.br

.IP "\fBlevel\fP" 0
The level of a GPIO.  Low or High.

.br

.br

.EX
PI_OFF 0
.br
PI_ON 1
.br

.br
PI_CLEAR 0
.br
PI_SET 1
.br

.br
PI_LOW 0
.br
PI_HIGH 1
.br

.EE

.br

.br
There is one exception.  If a watchdog expires on a GPIO the level will be
reported as PI_TIMEOUT.  See \fBgpioSetWatchdog\fP.

.br

.br

.EX
PI_TIMEOUT 2
.br

.EE

.br

.br

.br

.br

.IP "\fBlVal\fP: 0-4294967295 (Hex 0x0-0xFFFFFFFF, Octal 0-37777777777)" 0

.br

.br
A 32-bit word value.

.br

.br

.IP "\fBmemAllocMode\fP: 0-2" 0

.br

.br
The DMA memory allocation mode.

.br

.br

.EX
PI_MEM_ALLOC_AUTO    0
.br
PI_MEM_ALLOC_PAGEMAP 1
.br
PI_MEM_ALLOC_MAILBOX 2
.br

.EE

.br

.br

.IP "\fB*micros\fP" 0

.br

.br
A value representing microseconds.

.br

.br

.IP "\fBmicros\fP" 0

.br

.br
A value representing microseconds.

.br

.br

.IP "\fBmillis\fP" 0

.br

.br
A value representing milliseconds.

.br

.br

.IP "\fBMISO\fP" 0
The GPIO used for the MISO signal when bit banging SPI.

.br

.br

.IP "\fBmode\fP" 0

.br

.br
1. The operational mode of a GPIO, normally INPUT or OUTPUT.

.br

.br

.EX
PI_INPUT 0
.br
PI_OUTPUT 1
.br
PI_ALT0 4
.br
PI_ALT1 5
.br
PI_ALT2 6
.br
PI_ALT3 7
.br
PI_ALT4 3
.br
PI_ALT5 2
.br

.EE

.br

.br
2. A file open mode.

.br

.br

.EX
PI_FILE_READ  1
.br
PI_FILE_WRITE 2
.br
PI_FILE_RW    3
.br

.EE

.br

.br
The following values can be or'd into the mode.

.br

.br

.EX
PI_FILE_APPEND 4
.br
PI_FILE_CREATE 8
.br
PI_FILE_TRUNC  16
.br

.EE

.br

.br

.IP "\fBMOSI\fP" 0
The GPIO used for the MOSI signal when bit banging SPI.

.br

.br

.IP "\fBnumBits\fP" 0

.br

.br
The number of bits stored in a buffer.

.br

.br

.IP "\fBnumBytes\fP" 0
The number of bytes used to store characters in a string.  Depending
on the number of bits per character there may be 1, 2, or 4 bytes
per character.

.br

.br

.IP "\fBnumPar\fP: 0-10" 0
The number of parameters passed to a script.

.br

.br

.IP "\fBnumPulses\fP" 0
The number of pulses to be added to a waveform.

.br

.br

.IP "\fBnumSegs\fP" 0
The number of segments in a combined I2C transaction.

.br

.br

.IP "\fBnumSockAddr\fP" 0
The number of network addresses allowed to use the socket interface.

.br

.br
0 means all addresses allowed.

.br

.br

.IP "\fBoffset\fP" 0
The associated data starts this number of microseconds from the start of
the waveform.

.br

.br

.IP "\fB*outBuf\fP" 0
A buffer used to return data from a function.

.br

.br

.IP "\fBoutLen\fP" 0
The size in bytes of an output buffer.

.br

.br

.IP "\fBpad\fP: 0-2" 0
A set of GPIO which share common drivers.

.br

.br
Pad   GPIO
.br
0     0-27
.br
1     28-45
.br
2     46-53
.br

.br

.br

.IP "\fBpadStrength\fP: 1-16" 0
The mA which may be drawn from each GPIO whilst still guaranteeing the
high and low levels.

.br

.br

.IP "\fB*param\fP" 0
An array of script parameters.

.br

.br

.IP "\fBpi_i2c_msg_t\fP" 0

.EX
typedef struct
.br
{
.br
   uint16_t addr;  // slave address
.br
   uint16_t flags;
.br
   uint16_t len;   // msg length
.br
   uint8_t  *buf;  // pointer to msg data
.br
} pi_i2c_msg_t;
.br

.EE

.br

.br

.IP "\fBport\fP: 1024-32000" 0
The port used to bind to the pigpio socket.  Defaults to 8888.

.br

.br

.IP "\fBpos\fP" 0
The position of an item.

.br

.br

.IP "\fBprimaryChannel\fP: 0-14" 0
The DMA channel used to time the sampling of GPIO and to time servo and
PWM pulses.

.br

.br

.IP "\fB*pth\fP" 0

.br

.br
A thread identifier, returned by \fBgpioStartThread\fP.

.br

.br

.IP "\fBpthread_t\fP" 0

.br

.br
A thread identifier.

.br

.br

.IP "\fBpud\fP: 0-2" 0

.br

.br
The setting of the pull up/down resistor for a GPIO, which may be off,
pull-up, or pull-down.

.br

.br

.EX
PI_PUD_OFF 0
.br
PI_PUD_DOWN 1
.br
PI_PUD_UP 2
.br

.EE

.br

.br

.IP "\fBpulseLen\fP" 0

.br

.br
1-100, the length of a trigger pulse in microseconds.

.br

.br

.IP "\fB*pulses\fP" 0

.br

.br
An array of pulses to be added to a waveform.

.br

.br

.IP "\fBpulsewidth\fP: 0, 500-2500" 0

.EX
PI_SERVO_OFF 0
.br
PI_MIN_SERVO_PULSEWIDTH 500
.br
PI_MAX_SERVO_PULSEWIDTH 2500
.br

.EE

.br

.br

.IP "\fBPWMduty\fP: 0-1000000 (1M)" 0
The hardware PWM dutycycle.

.br

.br

.EX
PI_HW_PWM_RANGE 1000000
.br

.EE

.br

.br

.IP "\fBPWMfreq\fP: 5-250K" 0
The hardware PWM frequency.

.br

.br

.EX
PI_HW_PWM_MIN_FREQ 1
.br
PI_HW_PWM_MAX_FREQ 125000000
.br

.EE

.br

.br

.IP "\fBrange\fP: 25-40000" 0

.EX
PI_MIN_DUTYCYCLE_RANGE 25
.br
PI_MAX_DUTYCYCLE_RANGE 40000
.br

.EE

.br

.br

.IP "\fBrawCbs_t\fP" 0

.EX
typedef struct // linux/arch/arm/mach-bcm2708/include/mach/dma.h
.br
{
.br
   unsigned long info;
.br
   unsigned long src;
.br
   unsigned long dst;
.br
   unsigned long length;
.br
   unsigned long stride;
.br
   unsigned long next;
.br
   unsigned long pad[2];
.br
} rawCbs_t;
.br

.EE

.br

.br

.IP "\fBrawSPI_t\fP" 0

.EX
typedef struct
.br
{
.br
   int clk;     // GPIO for clock
.br
   int mosi;    // GPIO for MOSI
.br
   int miso;    // GPIO for MISO
.br
   int ss_pol;  // slave select off state
.br
   int ss_us;   // delay after slave select
.br
   int clk_pol; // clock off state
.br
   int clk_pha; // clock phase
.br
   int clk_us;  // clock micros
.br
} rawSPI_t;
.br

.EE

.br

.br

.IP "\fBrawWave_t\fP" 0

.EX
typedef struct
.br
{
.br
   uint32_t gpioOn;
.br
   uint32_t gpioOff;
.br
   uint32_t usDelay;
.br
   uint32_t flags;
.br
} rawWave_t;
.br

.EE

.br

.br

.IP "\fBrawWaveInfo_t\fP" 0

.EX
typedef struct
.br
{
.br
   uint16_t botCB;  // first CB used by wave
.br
   uint16_t topCB;  // last CB used by wave
.br
   uint16_t botOOL; // last OOL used by wave
.br
   uint16_t topOOL; // first OOL used by wave
.br
   uint16_t deleted;
.br
   uint16_t numCB;
.br
   uint16_t numBOOL;
.br
   uint16_t numTOOL;
.br
} rawWaveInfo_t;
.br

.EE

.br

.br

.IP "\fB*retBuf\fP" 0

.br

.br
A buffer to hold a number of bytes returned to a used customised function,

.br

.br

.IP "\fBretMax\fP" 0

.br

.br
The maximum number of bytes a user customised function should return.

.br

.br

.IP "\fB*rxBuf\fP" 0

.br

.br
A pointer to a buffer to receive data.

.br

.br

.IP "\fBSCL\fP" 0
The user GPIO to use for the clock when bit banging I2C.

.br

.br

.IP "\fBSCLK\fP" 0
The GPIO used for the SCLK signal when bit banging SPI.

.br

.br

.IP "\fB*script\fP" 0
A pointer to the text of a script.

.br

.br

.IP "\fBscript_id\fP" 0
An id of a stored script as returned by \fBgpioStoreScript\fP.

.br

.br

.IP "\fB*scriptName\fP" 0
The name of a \fBshell\fP script to be executed.  The script must be present in
/opt/pigpio/cgi and must have execute permission.

.br

.br

.IP "\fB*scriptString\fP" 0
The string to be passed to a \fBshell\fP script to be executed.

.br

.br

.IP "\fBSDA\fP" 0
The user GPIO to use for data when bit banging I2C.

.br

.br

.IP "\fBsecondaryChannel\fP: 0-6" 0

.br

.br
The DMA channel used to time output waveforms.

.br

.br

.IP "\fB*seconds\fP" 0

.br

.br
A pointer to a uint32_t to store the second component of
a returned time.

.br

.br

.IP "\fBseconds\fP" 0
The number of seconds.

.br

.br

.IP "\fBseekFrom\fP" 0

.br

.br

.EX
PI_FROM_START   0
.br
PI_FROM_CURRENT 1
.br
PI_FROM_END     2
.br

.EE

.br

.br

.IP "\fBseekOffset\fP" 0
The number of bytes to move forward (positive) or backwards (negative)
from the seek position (start, current, or end of file).

.br

.br

.IP "\fB*segs\fP" 0
An array of segments which make up a combined I2C transaction.

.br

.br

.IP "\fBserFlags\fP" 0
Flags which modify a serial open command.  None are currently defined.

.br

.br

.IP "\fB*sertty\fP" 0
The name of a serial tty device, e.g. /dev/ttyAMA0, /dev/ttyUSB0, /dev/tty1.

.br

.br

.IP "\fBsetting\fP" 0
A value used to set a flag, 0 for false, non-zero for true.

.br

.br

.IP "\fBsignum\fP: 0-63" 0

.EX
PI_MIN_SIGNUM 0
.br
PI_MAX_SIGNUM 63
.br

.EE

.br

.br

.IP "\fBsize_t\fP" 0

.br

.br
A standard type used to indicate the size of an object in bytes.

.br

.br

.IP "\fB*sockAddr\fP" 0
An array of network addresses allowed to use the socket interface encoded
as 32 bit numbers.

.br

.br
E.g. address 192.168.1.66 would be encoded as 0x4201a8c0.

.br

.br

.IP "\fB*spi\fP" 0
A pointer to a \fBrawSPI_t\fP structure.

.br

.br

.IP "\fBspiBitFirst\fP" 0
GPIO reads are made from spiBitFirst to spiBitLast.

.br

.br

.IP "\fBspiBitLast\fP" 0

.br

.br
GPIO reads are made from spiBitFirst to spiBitLast.

.br

.br

.IP "\fBspiBits\fP" 0
The number of bits to transfer in a raw SPI transaction.

.br

.br

.IP "\fBspiChan\fP" 0
A SPI channel, 0-2.

.br

.br

.IP "\fBspiFlags\fP" 0
See \fBspiOpen\fP and \fBbbSPIOpen\fP.

.br

.br

.IP "\fBspiSS\fP" 0
The SPI slave select GPIO in a raw SPI transaction.

.br

.br

.IP "\fBspiTxBits\fP" 0
The number of bits to transfer dring a raw SPI transaction

.br

.br

.IP "\fBsteady\fP: 0-300000" 0

.br

.br
The number of microseconds level changes must be stable for
before reporting the level changed (\fBgpioGlitchFilter\fP) or triggering
the active part of a noise filter (\fBgpioNoiseFilter\fP).

.br

.br

.IP "\fBstop_bits\fP: 2-8" 0
The number of (half) stop bits to be used when adding serial data
to a waveform.

.br

.br

.EX
PI_MIN_WAVE_HALFSTOPBITS 2
.br
PI_MAX_WAVE_HALFSTOPBITS 8
.br

.EE

.br

.br

.IP "\fB*str\fP" 0
An array of characters.

.br

.br

.IP "\fBtimeout\fP" 0
A GPIO level change timeout in milliseconds.

.br

.br
\fBgpioSetWatchdog\fP

.EX
PI_MIN_WDOG_TIMEOUT 0
.br
PI_MAX_WDOG_TIMEOUT 60000
.br

.EE

.br

.br
\fBgpioSetISRFunc\fP and \fBgpioSetISRFuncEx\fP

.EX
<=0 cancel timeout
.br
>0 timeout after specified milliseconds
.br

.EE

.br

.br

.IP "\fBtimer\fP" 0

.EX
PI_MIN_TIMER 0
.br
PI_MAX_TIMER 9
.br

.EE

.br

.br

.IP "\fBtimetype\fP" 0

.EX
PI_TIME_RELATIVE 0
.br
PI_TIME_ABSOLUTE 1
.br

.EE

.br

.br

.IP "\fB*txBuf\fP" 0

.br

.br
An array of bytes to transmit.

.br

.br

.IP "\fBuint32_t\fP: 0-0-4,294,967,295 (Hex 0x0-0xFFFFFFFF)" 0

.br

.br
A 32-bit unsigned value.

.br

.br

.IP "\fBuint64_t\fP: 0-(2^64)-1" 0

.br

.br
A 64-bit unsigned value.

.br

.br

.IP "\fBunsigned\fP" 0

.br

.br
A whole number >= 0.

.br

.br

.IP "\fBupdateMask\fP" 0

.br

.br
A 64 bit mask indicating which GPIO may be written to by the user.

.br

.br
If GPIO#n may be written then bit (1<<n) is set.

.br

.br

.IP "\fBuser_gpio\fP" 0

.br

.br
0-31, a Broadcom numbered GPIO.

.br

.br
See \fBgpio\fP.

.br

.br

.IP "\fB*userdata\fP" 0
A pointer to arbitrary user data.  This may be used to identify the instance.

.br

.br
You must ensure that the pointer is in scope at the time it is processed.  If
it is a pointer to a global this is automatic.  Do not pass the address of a
local variable.  If you want to pass a transient object then use the
following technique.

.br

.br
In the calling function:

.br

.br

.EX
user_type *userdata;
.br
.br
.br
user_type my_userdata;
.br

.br
userdata = malloc(sizeof(user_type));
.br
.br
.br
*userdata = my_userdata;
.br

.EE

.br

.br
In the receiving function:

.br

.br

.EX
user_type my_userdata = *(user_type*)userdata;
.br

.br
free(userdata);
.br

.EE

.br

.br

.IP "\fBvoid\fP" 0

.br

.br
Denoting no parameter is required

.br

.br

.IP "\fBwave_id\fP" 0

.br

.br
A number identifying a waveform created by \fBgpioWaveCreate\fP.

.br

.br

.IP "\fBwave_mode\fP" 0

.br

.br
The mode determines if the waveform is sent once or cycles
repeatedly.  The SYNC variants wait for the current waveform
to reach the end of a cycle or finish before starting the new
waveform.

.br

.br

.EX
PI_WAVE_MODE_ONE_SHOT      0
.br
PI_WAVE_MODE_REPEAT        1
.br
PI_WAVE_MODE_ONE_SHOT_SYNC 2
.br
PI_WAVE_MODE_REPEAT_SYNC   3
.br

.EE

.br

.br

.IP "\fBwVal\fP: 0-65535 (Hex 0x0-0xFFFF, Octal 0-0177777)" 0

.br

.br
A 16-bit word value.

.br

.br
.SH Socket Command Codes

.EX

.br
#define PI_CMD_MODES  0
.br
#define PI_CMD_MODEG  1
.br
#define PI_CMD_PUD    2
.br
#define PI_CMD_READ   3
.br
#define PI_CMD_WRITE  4
.br
#define PI_CMD_PWM    5
.br
#define PI_CMD_PRS    6
.br
#define PI_CMD_PFS    7
.br
#define PI_CMD_SERVO  8
.br
#define PI_CMD_WDOG   9
.br
#define PI_CMD_BR1   10
.br
#define PI_CMD_BR2   11
.br
#define PI_CMD_BC1   12
.br
#define PI_CMD_BC2   13
.br
#define PI_CMD_BS1   14
.br
#define PI_CMD_BS2   15
.br
#define PI_CMD_TICK  16
.br
#define PI_CMD_HWVER 17
.br
#define PI_CMD_NO    18
.br
#define PI_CMD_NB    19
.br
#define PI_CMD_NP    20
.br
#define PI_CMD_NC    21
.br
#define PI_CMD_PRG   22
.br
#define PI_CMD_PFG   23
.br
#define PI_CMD_PRRG  24
.br
#define PI_CMD_HELP  25
.br
#define PI_CMD_PIGPV 26
.br
#define PI_CMD_WVCLR 27
.br
#define PI_CMD_WVAG  28
.br
#define PI_CMD_WVAS  29
.br
#define PI_CMD_WVGO  30
.br
#define PI_CMD_WVGOR 31
.br
#define PI_CMD_WVBSY 32
.br
#define PI_CMD_WVHLT 33
.br
#define PI_CMD_WVSM  34
.br
#define PI_CMD_WVSP  35
.br
#define PI_CMD_WVSC  36
.br
#define PI_CMD_TRIG  37
.br
#define PI_CMD_PROC  38
.br
#define PI_CMD_PROCD 39
.br
#define PI_CMD_PROCR 40
.br
#define PI_CMD_PROCS 41
.br
#define PI_CMD_SLRO  42
.br
#define PI_CMD_SLR   43
.br
#define PI_CMD_SLRC  44
.br
#define PI_CMD_PROCP 45
.br
#define PI_CMD_MICS  46
.br
#define PI_CMD_MILS  47
.br
#define PI_CMD_PARSE 48
.br
#define PI_CMD_WVCRE 49
.br
#define PI_CMD_WVDEL 50
.br
#define PI_CMD_WVTX  51
.br
#define PI_CMD_WVTXR 52
.br
#define PI_CMD_WVNEW 53
.br

.br
#define PI_CMD_I2CO  54
.br
#define PI_CMD_I2CC  55
.br
#define PI_CMD_I2CRD 56
.br
#define PI_CMD_I2CWD 57
.br
#define PI_CMD_I2CWQ 58
.br
#define PI_CMD_I2CRS 59
.br
#define PI_CMD_I2CWS 60
.br
#define PI_CMD_I2CRB 61
.br
#define PI_CMD_I2CWB 62
.br
#define PI_CMD_I2CRW 63
.br
#define PI_CMD_I2CWW 64
.br
#define PI_CMD_I2CRK 65
.br
#define PI_CMD_I2CWK 66
.br
#define PI_CMD_I2CRI 67
.br
#define PI_CMD_I2CWI 68
.br
#define PI_CMD_I2CPC 69
.br
#define PI_CMD_I2CPK 70
.br

.br
#define PI_CMD_SPIO  71
.br
#define PI_CMD_SPIC  72
.br
#define PI_CMD_SPIR  73
.br
#define PI_CMD_SPIW  74
.br
#define PI_CMD_SPIX  75
.br

.br
#define PI_CMD_SERO  76
.br
#define PI_CMD_SERC  77
.br
#define PI_CMD_SERRB 78
.br
#define PI_CMD_SERWB 79
.br
#define PI_CMD_SERR  80
.br
#define PI_CMD_SERW  81
.br
#define PI_CMD_SERDA 82
.br

.br
#define PI_CMD_GDC   83
.br
#define PI_CMD_GPW   84
.br

.br
#define PI_CMD_HC    85
.br
#define PI_CMD_HP    86
.br

.br
#define PI_CMD_CF1   87
.br
#define PI_CMD_CF2   88
.br

.br
#define PI_CMD_BI2CC 89
.br
#define PI_CMD_BI2CO 90
.br
#define PI_CMD_BI2CZ 91
.br

.br
#define PI_CMD_I2CZ  92
.br

.br
#define PI_CMD_WVCHA 93
.br

.br
#define PI_CMD_SLRI  94
.br

.br
#define PI_CMD_CGI   95
.br
#define PI_CMD_CSI   96
.br

.br
#define PI_CMD_FG    97
.br
#define PI_CMD_FN    98
.br

.br
#define PI_CMD_NOIB  99
.br

.br
#define PI_CMD_WVTXM 100
.br
#define PI_CMD_WVTAT 101
.br

.br
#define PI_CMD_PADS  102
.br
#define PI_CMD_PADG  103
.br

.br
#define PI_CMD_FO    104
.br
#define PI_CMD_FC    105
.br
#define PI_CMD_FR    106
.br
#define PI_CMD_FW    107
.br
#define PI_CMD_FS    108
.br
#define PI_CMD_FL    109
.br

.br
#define PI_CMD_SHELL 110
.br

.br
#define PI_CMD_BSPIC 111
.br
#define PI_CMD_BSPIO 112
.br
#define PI_CMD_BSPIX 113
.br

.br
#define PI_CMD_BSCX  114
.br

.br
#define PI_CMD_EVM   115
.br
#define PI_CMD_EVT   116
.br

.br
#define PI_CMD_PROCU 117
.br

.br

.EE
.SH Error Codes

.EX

.br
#define PI_INIT_FAILED       -1 // gpioInitialise failed
.br
#define PI_BAD_USER_GPIO     -2 // GPIO not 0-31
.br
#define PI_BAD_GPIO          -3 // GPIO not 0-53
.br
#define PI_BAD_MODE          -4 // mode not 0-7
.br
#define PI_BAD_LEVEL         -5 // level not 0-1
.br
#define PI_BAD_PUD           -6 // pud not 0-2
.br
#define PI_BAD_PULSEWIDTH    -7 // pulsewidth not 0 or 500-2500
.br
#define PI_BAD_DUTYCYCLE     -8 // dutycycle outside set range
.br
#define PI_BAD_TIMER         -9 // timer not 0-9
.br
#define PI_BAD_MS           -10 // ms not 10-60000
.br
#define PI_BAD_TIMETYPE     -11 // timetype not 0-1
.br
#define PI_BAD_SECONDS      -12 // seconds < 0
.br
#define PI_BAD_MICROS       -13 // micros not 0-999999
.br
#define PI_TIMER_FAILED     -14 // gpioSetTimerFunc failed
.br
#define PI_BAD_WDOG_TIMEOUT -15 // timeout not 0-60000
.br
#define PI_NO_ALERT_FUNC    -16 // DEPRECATED
.br
#define PI_BAD_CLK_PERIPH   -17 // clock peripheral not 0-1
.br
#define PI_BAD_CLK_SOURCE   -18 // DEPRECATED
.br
#define PI_BAD_CLK_MICROS   -19 // clock micros not 1, 2, 4, 5, 8, or 10
.br
#define PI_BAD_BUF_MILLIS   -20 // buf millis not 100-10000
.br
#define PI_BAD_DUTYRANGE    -21 // dutycycle range not 25-40000
.br
#define PI_BAD_DUTY_RANGE   -21 // DEPRECATED (use PI_BAD_DUTYRANGE)
.br
#define PI_BAD_SIGNUM       -22 // signum not 0-63
.br
#define PI_BAD_PATHNAME     -23 // can't open pathname
.br
#define PI_NO_HANDLE        -24 // no handle available
.br
#define PI_BAD_HANDLE       -25 // unknown handle
.br
#define PI_BAD_IF_FLAGS     -26 // ifFlags > 4
.br
#define PI_BAD_CHANNEL      -27 // DMA channel not 0-14
.br
#define PI_BAD_PRIM_CHANNEL -27 // DMA primary channel not 0-14
.br
#define PI_BAD_SOCKET_PORT  -28 // socket port not 1024-32000
.br
#define PI_BAD_FIFO_COMMAND -29 // unrecognized fifo command
.br
#define PI_BAD_SECO_CHANNEL -30 // DMA secondary channel not 0-6
.br
#define PI_NOT_INITIALISED  -31 // function called before gpioInitialise
.br
#define PI_INITIALISED      -32 // function called after gpioInitialise
.br
#define PI_BAD_WAVE_MODE    -33 // waveform mode not 0-3
.br
#define PI_BAD_CFG_INTERNAL -34 // bad parameter in gpioCfgInternals call
.br
#define PI_BAD_WAVE_BAUD    -35 // baud rate not 50-250K(RX)/50-1M(TX)
.br
#define PI_TOO_MANY_PULSES  -36 // waveform has too many pulses
.br
#define PI_TOO_MANY_CHARS   -37 // waveform has too many chars
.br
#define PI_NOT_SERIAL_GPIO  -38 // no bit bang serial read on GPIO
.br
#define PI_BAD_SERIAL_STRUC -39 // bad (null) serial structure parameter
.br
#define PI_BAD_SERIAL_BUF   -40 // bad (null) serial buf parameter
.br
#define PI_NOT_PERMITTED    -41 // GPIO operation not permitted
.br
#define PI_SOME_PERMITTED   -42 // one or more GPIO not permitted
.br
#define PI_BAD_WVSC_COMMND  -43 // bad WVSC subcommand
.br
#define PI_BAD_WVSM_COMMND  -44 // bad WVSM subcommand
.br
#define PI_BAD_WVSP_COMMND  -45 // bad WVSP subcommand
.br
#define PI_BAD_PULSELEN     -46 // trigger pulse length not 1-100
.br
#define PI_BAD_SCRIPT       -47 // invalid script
.br
#define PI_BAD_SCRIPT_ID    -48 // unknown script id
.br
#define PI_BAD_SER_OFFSET   -49 // add serial data offset > 30 minutes
.br
#define PI_GPIO_IN_USE      -50 // GPIO already in use
.br
#define PI_BAD_SERIAL_COUNT -51 // must read at least a byte at a time
.br
#define PI_BAD_PARAM_NUM    -52 // script parameter id not 0-9
.br
#define PI_DUP_TAG          -53 // script has duplicate tag
.br
#define PI_TOO_MANY_TAGS    -54 // script has too many tags
.br
#define PI_BAD_SCRIPT_CMD   -55 // illegal script command
.br
#define PI_BAD_VAR_NUM      -56 // script variable id not 0-149
.br
#define PI_NO_SCRIPT_ROOM   -57 // no more room for scripts
.br
#define PI_NO_MEMORY        -58 // can't allocate temporary memory
.br
#define PI_SOCK_READ_FAILED -59 // socket read failed
.br
#define PI_SOCK_WRIT_FAILED -60 // socket write failed
.br
#define PI_TOO_MANY_PARAM   -61 // too many script parameters (> 10)
.br
#define PI_NOT_HALTED       -62 // DEPRECATED
.br
#define PI_SCRIPT_NOT_READY -62 // script initialising
.br
#define PI_BAD_TAG          -63 // script has unresolved tag
.br
#define PI_BAD_MICS_DELAY   -64 // bad MICS delay (too large)
.br
#define PI_BAD_MILS_DELAY   -65 // bad MILS delay (too large)
.br
#define PI_BAD_WAVE_ID      -66 // non existent wave id
.br
#define PI_TOO_MANY_CBS     -67 // No more CBs for waveform
.br
#define PI_TOO_MANY_OOL     -68 // No more OOL for waveform
.br
#define PI_EMPTY_WAVEFORM   -69 // attempt to create an empty waveform
.br
#define PI_NO_WAVEFORM_ID   -70 // no more waveforms
.br
#define PI_I2C_OPEN_FAILED  -71 // can't open I2C device
.br
#define PI_SER_OPEN_FAILED  -72 // can't open serial device
.br
#define PI_SPI_OPEN_FAILED  -73 // can't open SPI device
.br
#define PI_BAD_I2C_BUS      -74 // bad I2C bus
.br
#define PI_BAD_I2C_ADDR     -75 // bad I2C address
.br
#define PI_BAD_SPI_CHANNEL  -76 // bad SPI channel
.br
#define PI_BAD_FLAGS        -77 // bad i2c/spi/ser open flags
.br
#define PI_BAD_SPI_SPEED    -78 // bad SPI speed
.br
#define PI_BAD_SER_DEVICE   -79 // bad serial device name
.br
#define PI_BAD_SER_SPEED    -80 // bad serial baud rate
.br
#define PI_BAD_PARAM        -81 // bad i2c/spi/ser parameter
.br
#define PI_I2C_WRITE_FAILED -82 // i2c write failed
.br
#define PI_I2C_READ_FAILED  -83 // i2c read failed
.br
#define PI_BAD_SPI_COUNT    -84 // bad SPI count
.br
#define PI_SER_WRITE_FAILED -85 // ser write failed
.br
#define PI_SER_READ_FAILED  -86 // ser read failed
.br
#define PI_SER_READ_NO_DATA -87 // ser read no data available
.br
#define PI_UNKNOWN_COMMAND  -88 // unknown command
.br
#define PI_SPI_XFER_FAILED  -89 // spi xfer/read/write failed
.br
#define PI_BAD_POINTER      -90 // bad (NULL) pointer
.br
#define PI_NO_AUX_SPI       -91 // no auxiliary SPI on Pi A or B
.br
#define PI_NOT_PWM_GPIO     -92 // GPIO is not in use for PWM
.br
#define PI_NOT_SERVO_GPIO   -93 // GPIO is not in use for servo pulses
.br
#define PI_NOT_HCLK_GPIO    -94 // GPIO has no hardware clock
.br
#define PI_NOT_HPWM_GPIO    -95 // GPIO has no hardware PWM
.br
#define PI_BAD_HPWM_FREQ    -96 // hardware PWM frequency not 1-125M
.br
#define PI_BAD_HPWM_DUTY    -97 // hardware PWM dutycycle not 0-1M
.br
#define PI_BAD_HCLK_FREQ    -98 // hardware clock frequency not 4689-250M
.br
#define PI_BAD_HCLK_PASS    -99 // need password to use hardware clock 1
.br
#define PI_HPWM_ILLEGAL    -100 // illegal, PWM in use for main clock
.br
#define PI_BAD_DATABITS    -101 // serial data bits not 1-32
.br
#define PI_BAD_STOPBITS    -102 // serial (half) stop bits not 2-8
.br
#define PI_MSG_TOOBIG      -103 // socket/pipe message too big
.br
#define PI_BAD_MALLOC_MODE -104 // bad memory allocation mode
.br
#define PI_TOO_MANY_SEGS   -105 // too many I2C transaction segments
.br
#define PI_BAD_I2C_SEG     -106 // an I2C transaction segment failed
.br
#define PI_BAD_SMBUS_CMD   -107 // SMBus command not supported by driver
.br
#define PI_NOT_I2C_GPIO    -108 // no bit bang I2C in progress on GPIO
.br
#define PI_BAD_I2C_WLEN    -109 // bad I2C write length
.br
#define PI_BAD_I2C_RLEN    -110 // bad I2C read length
.br
#define PI_BAD_I2C_CMD     -111 // bad I2C command
.br
#define PI_BAD_I2C_BAUD    -112 // bad I2C baud rate, not 50-500k
.br
#define PI_CHAIN_LOOP_CNT  -113 // bad chain loop count
.br
#define PI_BAD_CHAIN_LOOP  -114 // empty chain loop
.br
#define PI_CHAIN_COUNTER   -115 // too many chain counters
.br
#define PI_BAD_CHAIN_CMD   -116 // bad chain command
.br
#define PI_BAD_CHAIN_DELAY -117 // bad chain delay micros
.br
#define PI_CHAIN_NESTING   -118 // chain counters nested too deeply
.br
#define PI_CHAIN_TOO_BIG   -119 // chain is too long
.br
#define PI_DEPRECATED      -120 // deprecated function removed
.br
#define PI_BAD_SER_INVERT  -121 // bit bang serial invert not 0 or 1
.br
#define PI_BAD_EDGE        -122 // bad ISR edge value, not 0-2
.br
#define PI_BAD_ISR_INIT    -123 // bad ISR initialisation
.br
#define PI_BAD_FOREVER     -124 // loop forever must be last command
.br
#define PI_BAD_FILTER      -125 // bad filter parameter
.br
#define PI_BAD_PAD         -126 // bad pad number
.br
#define PI_BAD_STRENGTH    -127 // bad pad drive strength
.br
#define PI_FIL_OPEN_FAILED -128 // file open failed
.br
#define PI_BAD_FILE_MODE   -129 // bad file mode
.br
#define PI_BAD_FILE_FLAG   -130 // bad file flag
.br
#define PI_BAD_FILE_READ   -131 // bad file read
.br
#define PI_BAD_FILE_WRITE  -132 // bad file write
.br
#define PI_FILE_NOT_ROPEN  -133 // file not open for read
.br
#define PI_FILE_NOT_WOPEN  -134 // file not open for write
.br
#define PI_BAD_FILE_SEEK   -135 // bad file seek
.br
#define PI_NO_FILE_MATCH   -136 // no files match pattern
.br
#define PI_NO_FILE_ACCESS  -137 // no permission to access file
.br
#define PI_FILE_IS_A_DIR   -138 // file is a directory
.br
#define PI_BAD_SHELL_STATUS -139 // bad shell return status
.br
#define PI_BAD_SCRIPT_NAME -140 // bad script name
.br
#define PI_BAD_SPI_BAUD    -141 // bad SPI baud rate, not 50-500k
.br
#define PI_NOT_SPI_GPIO    -142 // no bit bang SPI in progress on GPIO
.br
#define PI_BAD_EVENT_ID    -143 // bad event id
.br
#define PI_CMD_INTERRUPTED -144 // Used by Python
.br

.br
#define PI_PIGIF_ERR_0    -2000
.br
#define PI_PIGIF_ERR_99   -2099
.br

.br
#define PI_CUSTOM_ERR_0   -3000
.br
#define PI_CUSTOM_ERR_999 -3999
.br

.br

.EE
.SH Defaults

.EX

.br
#define PI_DEFAULT_BUFFER_MILLIS           120
.br
#define PI_DEFAULT_CLK_MICROS              5
.br
#define PI_DEFAULT_CLK_PERIPHERAL          PI_CLOCK_PCM
.br
#define PI_DEFAULT_IF_FLAGS                0
.br
#define PI_DEFAULT_FOREGROUND              0
.br
#define PI_DEFAULT_DMA_CHANNEL             14
.br
#define PI_DEFAULT_DMA_PRIMARY_CHANNEL     14
.br
#define PI_DEFAULT_DMA_SECONDARY_CHANNEL   6
.br
#define PI_DEFAULT_SOCKET_PORT             8888
.br
#define PI_DEFAULT_SOCKET_PORT_STR         "8888"
.br
#define PI_DEFAULT_SOCKET_ADDR_STR         "127.0.0.1"
.br
#define PI_DEFAULT_UPDATE_MASK_UNKNOWN     0x0000000FFFFFFCLL
.br
#define PI_DEFAULT_UPDATE_MASK_B1          0x03E7CF93
.br
#define PI_DEFAULT_UPDATE_MASK_A_B2        0xFBC7CF9C
.br
#define PI_DEFAULT_UPDATE_MASK_APLUS_BPLUS 0x0080480FFFFFFCLL
.br
#define PI_DEFAULT_UPDATE_MASK_ZERO        0x0080000FFFFFFCLL
.br
#define PI_DEFAULT_UPDATE_MASK_PI2B        0x0080480FFFFFFCLL
.br
#define PI_DEFAULT_UPDATE_MASK_PI3B        0x0000000FFFFFFCLL
.br
#define PI_DEFAULT_UPDATE_MASK_COMPUTE     0x00FFFFFFFFFFFFLL
.br
#define PI_DEFAULT_MEM_ALLOC_MODE          PI_MEM_ALLOC_AUTO
.br

.br
#define PI_DEFAULT_CFG_INTERNALS           0
.br

.br

.EE

.SH SEE ALSO

pigpiod(1), pig2vcd(1), pigs(1), pigpiod_if(3), pigpiod_if2(3)
.SH AUTHOR

joan@abyz.me.uk
