<br><br>pigpio is a C library for the Raspberry which allows control of the GPIO.
<h3>Features</h3>o hardware timed PWM on any of GPIO 0-31
<br><br>o hardware timed servo pulses on any of GPIO 0-31
<br><br>o callbacks when any of GPIO 0-31 change state
<br><br>o callbacks at timed intervals
<br><br>o reading/writing all of the GPIO in a bank as one operation
<br><br>o individually setting GPIO modes, reading and writing
<br><br>o notifications when any of GPIO 0-31 change state
<br><br>o the construction of output waveforms with microsecond timing
<br><br>o rudimentary permission control over GPIO
<br><br>o a simple interface to start and stop new threads
<br><br>o I2C, SPI, and serial link wrappers
<br><br>o creating and running scripts
<h3>GPIO</h3>ALL GPIO are identified by their Broadcom number.
<h3>Credits</h3>The PWM and servo pulses are timed using the DMA and PWM peripherals.
<br><br>This use was inspired by Richard Hirst's servoblaster kernel module.
<h3>Usage</h3>Include &lt;pigpio.h&gt; in your source files.
<br><br>Assuming your source is in prog.c use the following command to build and
run the executable.
<br><br><code>gcc&nbsp;-Wall&nbsp;-pthread&nbsp;-o&nbsp;prog&nbsp;prog.c&nbsp;-lpigpio&nbsp;-lrt<br>sudo&nbsp;./prog<br></code><br><br>For examples of usage see the C programs within the pigpio archive file.
<h3>Notes</h3>All the functions which return an int return &lt; 0 on error.
<br><br><a href="#gpioInitialise">gpioInitialise</a> must be called before all other library functions
with the following exceptions:
<br><br><code><a href="#gpioCfg*">gpioCfg*</a><br><a href="#gpioVersion">gpioVersion</a><br><a href="#gpioHardwareRevision">gpioHardwareRevision</a><br></code><br><br>If the library is not initialised all but the <a href="#gpioCfg*">gpioCfg*</a>,
<a href="#gpioVersion">gpioVersion</a>, and <a href="#gpioHardwareRevision">gpioHardwareRevision</a> functions will
return error PI_NOT_INITIALISED.
<br><br>If the library is initialised the <a href="#gpioCfg*">gpioCfg*</a> functions will return
error PI_INITIALISED.
<h2>OVERVIEW</h2><table border="0" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td></td></tr><tr><td><b>ESSENTIAL
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioInitialise">gpioInitialise</a></td><td>            Initialise library
</td></tr><tr><td><a href="#gpioTerminate">gpioTerminate</a></td><td>             Stop library
</td></tr><tr><td></td><td></td></tr><tr><td><b>BASIC
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetMode">gpioSetMode</a></td><td>               Set a GPIO mode
</td></tr><tr><td><a href="#gpioGetMode">gpioGetMode</a></td><td>               Get a GPIO mode
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetPullUpDown">gpioSetPullUpDown</a></td><td>         Set/clear GPIO pull up/down resistor
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioRead">gpioRead</a></td><td>                  Read a GPIO
</td></tr><tr><td><a href="#gpioWrite">gpioWrite</a></td><td>                 Write a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>PWM (overrides servo commands on same GPIO)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioPWM">gpioPWM</a></td><td>                   Start/stop PWM pulses on a GPIO
</td></tr><tr><td><a href="#gpioSetPWMfrequency">gpioSetPWMfrequency</a></td><td>       Configure PWM frequency for a GPIO
</td></tr><tr><td><a href="#gpioSetPWMrange">gpioSetPWMrange</a></td><td>           Configure PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioGetPWMdutycycle">gpioGetPWMdutycycle</a></td><td>       Get dutycycle setting on a GPIO
</td></tr><tr><td><a href="#gpioGetPWMfrequency">gpioGetPWMfrequency</a></td><td>       Get configured PWM frequency for a GPIO
</td></tr><tr><td><a href="#gpioGetPWMrange">gpioGetPWMrange</a></td><td>           Get configured PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioGetPWMrealRange">gpioGetPWMrealRange</a></td><td>       Get underlying PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>Servo (overrides PWM commands on same GPIO)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioServo">gpioServo</a></td><td>                 Start/stop servo pulses on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioGetServoPulsewidth">gpioGetServoPulsewidth</a></td><td>    Get pulsewidth setting on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>INTERMEDIATE
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioTrigger">gpioTrigger</a></td><td>               Send a trigger pulse to a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetWatchdog">gpioSetWatchdog</a></td><td>           Set a watchdog on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioRead_Bits_0_31">gpioRead_Bits_0_31</a></td><td>        Read all GPIO in bank 1
</td></tr><tr><td><a href="#gpioRead_Bits_32_53">gpioRead_Bits_32_53</a></td><td>       Read all GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWrite_Bits_0_31_Clear">gpioWrite_Bits_0_31_Clear</a></td><td> Clear selected GPIO in bank 1
</td></tr><tr><td><a href="#gpioWrite_Bits_32_53_Clear">gpioWrite_Bits_32_53_Clear</a></td><td>Clear selected GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWrite_Bits_0_31_Set">gpioWrite_Bits_0_31_Set</a></td><td>   Set selected GPIO in bank 1
</td></tr><tr><td><a href="#gpioWrite_Bits_32_53_Set">gpioWrite_Bits_32_53_Set</a></td><td>  Set selected GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetAlertFunc">gpioSetAlertFunc</a></td><td>          Request a GPIO level change callback
</td></tr><tr><td><a href="#gpioSetAlertFuncEx">gpioSetAlertFuncEx</a></td><td>        Request a GPIO change callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetTimerFunc">gpioSetTimerFunc</a></td><td>          Request a regular timed callback
</td></tr><tr><td><a href="#gpioSetTimerFuncEx">gpioSetTimerFuncEx</a></td><td>        Request a regular timed callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioStartThread">gpioStartThread</a></td><td>           Start a new thread
</td></tr><tr><td><a href="#gpioStopThread">gpioStopThread</a></td><td>            Stop a previously started thread
</td></tr><tr><td></td><td></td></tr><tr><td><b>ADVANCED
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioNotifyOpen">gpioNotifyOpen</a></td><td>            Request a notification handle
</td></tr><tr><td><a href="#gpioNotifyClose">gpioNotifyClose</a></td><td>           Close a notification
</td></tr><tr><td><a href="#gpioNotifyOpenWithSize">gpioNotifyOpenWithSize</a></td><td>    Request a notification with sized pipe
</td></tr><tr><td><a href="#gpioNotifyBegin">gpioNotifyBegin</a></td><td>           Start notifications for selected GPIO
</td></tr><tr><td><a href="#gpioNotifyPause">gpioNotifyPause</a></td><td>           Pause notifications
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioHardwareClock">gpioHardwareClock</a></td><td>         Start hardware clock on supported GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioHardwarePWM">gpioHardwarePWM</a></td><td>           Start hardware PWM on supported GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioGlitchFilter">gpioGlitchFilter</a></td><td>          Set a glitch filter on a GPIO
</td></tr><tr><td><a href="#gpioNoiseFilter">gpioNoiseFilter</a></td><td>           Set a noise filter on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetPad">gpioSetPad</a></td><td>                Sets a pads drive strength
</td></tr><tr><td><a href="#gpioGetPad">gpioGetPad</a></td><td>                Gets a pads drive strength
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#shell">shell</a></td><td>                     Executes a shell command
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetISRFunc">gpioSetISRFunc</a></td><td>            Request a GPIO interrupt callback
</td></tr><tr><td><a href="#gpioSetISRFuncEx">gpioSetISRFuncEx</a></td><td>          Request a GPIO interrupt callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetSignalFunc">gpioSetSignalFunc</a></td><td>         Request a signal callback
</td></tr><tr><td><a href="#gpioSetSignalFuncEx">gpioSetSignalFuncEx</a></td><td>       Request a signal callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSetGetSamplesFunc">gpioSetGetSamplesFunc</a></td><td>     Requests a GPIO samples callback
</td></tr><tr><td><a href="#gpioSetGetSamplesFuncEx">gpioSetGetSamplesFuncEx</a></td><td>   Requests a GPIO samples callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><b>Custom
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioCustom1">gpioCustom1</a></td><td>               User custom function 1
</td></tr><tr><td><a href="#gpioCustom2">gpioCustom2</a></td><td>               User custom function 2
</td></tr><tr><td></td><td></td></tr><tr><td><b>Events
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#eventMonitor">eventMonitor</a></td><td>              Sets the events to monitor
</td></tr><tr><td><a href="#eventSetFunc">eventSetFunc</a></td><td>              Request an event callback
</td></tr><tr><td><a href="#eventSetFuncEx">eventSetFuncEx</a></td><td>            Request an event callback, extended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#eventTrigger">eventTrigger</a></td><td>              Trigger an event
</td></tr><tr><td></td><td></td></tr><tr><td><b>Scripts
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioStoreScript">gpioStoreScript</a></td><td>           Store a script
</td></tr><tr><td><a href="#gpioRunScript">gpioRunScript</a></td><td>             Run a stored script
</td></tr><tr><td><a href="#gpioUpdateScript">gpioUpdateScript</a></td><td>          Set a scripts parameters
</td></tr><tr><td><a href="#gpioScriptStatus">gpioScriptStatus</a></td><td>          Get script status and parameters
</td></tr><tr><td><a href="#gpioStopScript">gpioStopScript</a></td><td>            Stop a running script
</td></tr><tr><td><a href="#gpioDeleteScript">gpioDeleteScript</a></td><td>          Delete a stored script
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cOpen">i2cOpen</a></td><td>                   Opens an I2C device
</td></tr><tr><td><a href="#i2cClose">i2cClose</a></td><td>                  Closes an I2C device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cWriteQuick">i2cWriteQuick</a></td><td>             SMBus write quick
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cReadByte">i2cReadByte</a></td><td>               SMBus read byte
</td></tr><tr><td><a href="#i2cWriteByte">i2cWriteByte</a></td><td>              SMBus write byte
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cReadByteData">i2cReadByteData</a></td><td>           SMBus read byte data
</td></tr><tr><td><a href="#i2cWriteByteData">i2cWriteByteData</a></td><td>          SMBus write byte data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cReadWordData">i2cReadWordData</a></td><td>           SMBus read word data
</td></tr><tr><td><a href="#i2cWriteWordData">i2cWriteWordData</a></td><td>          SMBus write word data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cReadBlockData">i2cReadBlockData</a></td><td>          SMBus read block data
</td></tr><tr><td><a href="#i2cWriteBlockData">i2cWriteBlockData</a></td><td>         SMBus write block data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cReadI2CBlockData">i2cReadI2CBlockData</a></td><td>       SMBus read I2C block data
</td></tr><tr><td><a href="#i2cWriteI2CBlockData">i2cWriteI2CBlockData</a></td><td>      SMBus write I2C block data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cReadDevice">i2cReadDevice</a></td><td>             Reads the raw I2C device
</td></tr><tr><td><a href="#i2cWriteDevice">i2cWriteDevice</a></td><td>            Writes the raw I2C device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cProcessCall">i2cProcessCall</a></td><td>            SMBus process call
</td></tr><tr><td><a href="#i2cBlockProcessCall">i2cBlockProcessCall</a></td><td>       SMBus block process call
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cSwitchCombined">i2cSwitchCombined</a></td><td>         Sets or clears the combined flag
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cSegments">i2cSegments</a></td><td>               Performs multiple I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2cZip">i2cZip</a></td><td>                    Performs multiple I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C BIT BANG
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bbI2COpen">bbI2COpen</a></td><td>                 Opens GPIO for bit banging I2C
</td></tr><tr><td><a href="#bbI2CClose">bbI2CClose</a></td><td>                Closes GPIO for bit banging I2C
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bbI2CZip">bbI2CZip</a></td><td>                  Performs bit banged I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C/SPI SLAVE
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bscXfer">bscXfer</a></td><td>                   I2C/SPI as slave transfer
</td></tr><tr><td></td><td></td></tr><tr><td><b>SERIAL
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#serOpen">serOpen</a></td><td>                   Opens a serial device
</td></tr><tr><td><a href="#serClose">serClose</a></td><td>                  Closes a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serReadByte">serReadByte</a></td><td>               Reads a byte from a serial device
</td></tr><tr><td><a href="#serWriteByte">serWriteByte</a></td><td>              Writes a byte to a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serRead">serRead</a></td><td>                   Reads bytes from a serial device
</td></tr><tr><td><a href="#serWrite">serWrite</a></td><td>                  Writes bytes to a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serDataAvailable">serDataAvailable</a></td><td>          Returns number of bytes ready to be read
</td></tr><tr><td></td><td></td></tr><tr><td><b>SERIAL BIT BANG (read only)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSerialReadOpen">gpioSerialReadOpen</a></td><td>        Opens a GPIO for bit bang serial reads
</td></tr><tr><td><a href="#gpioSerialReadClose">gpioSerialReadClose</a></td><td>       Closes a GPIO for bit bang serial reads
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSerialReadInvert">gpioSerialReadInvert</a></td><td>      Configures normal/inverted for serial reads
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioSerialRead">gpioSerialRead</a></td><td>            Reads bit bang serial data from a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>SPI
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#spiOpen">spiOpen</a></td><td>                   Opens a SPI device
</td></tr><tr><td><a href="#spiClose">spiClose</a></td><td>                  Closes a SPI device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#spiRead">spiRead</a></td><td>                   Reads bytes from a SPI device
</td></tr><tr><td><a href="#spiWrite">spiWrite</a></td><td>                  Writes bytes to a SPI device
</td></tr><tr><td><a href="#spiXfer">spiXfer</a></td><td>                   Transfers bytes with a SPI device
</td></tr><tr><td></td><td></td></tr><tr><td><b>SPI BIT BANG
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bbSPIOpen">bbSPIOpen</a></td><td>                 Opens GPIO for bit banging SPI
</td></tr><tr><td><a href="#bbSPIClose">bbSPIClose</a></td><td>                Closes GPIO for bit banging SPI
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bbSPIXfer">bbSPIXfer</a></td><td>                 Performs bit banged SPI transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>FILES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#fileOpen">fileOpen</a></td><td>                  Opens a file
</td></tr><tr><td><a href="#fileClose">fileClose</a></td><td>                 Closes a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#fileRead">fileRead</a></td><td>                  Reads bytes from a file
</td></tr><tr><td><a href="#fileWrite">fileWrite</a></td><td>                 Writes bytes to a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#fileSeek">fileSeek</a></td><td>                  Seeks to a position within a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#fileList">fileList</a></td><td>                  List files which match a pattern
</td></tr><tr><td></td><td></td></tr><tr><td><b>WAVES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveClear">gpioWaveClear</a></td><td>             Deletes all waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveAddNew">gpioWaveAddNew</a></td><td>            Starts a new waveform
</td></tr><tr><td><a href="#gpioWaveAddGeneric">gpioWaveAddGeneric</a></td><td>        Adds a series of pulses to the waveform
</td></tr><tr><td><a href="#gpioWaveAddSerial">gpioWaveAddSerial</a></td><td>         Adds serial data to the waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveCreate">gpioWaveCreate</a></td><td>            Creates a waveform from added data
</td></tr><tr><td><a href="#gpioWaveCreatePad">gpioWaveCreatePad</a></td><td>         Creates a waveform of fixed size from added data
</td></tr><tr><td><a href="#gpioWaveDelete">gpioWaveDelete</a></td><td>            Deletes a waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveTxSend">gpioWaveTxSend</a></td><td>            Transmits a waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveChain">gpioWaveChain</a></td><td>             Transmits a chain of waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveTxAt">gpioWaveTxAt</a></td><td>              Returns the current transmitting waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveTxBusy">gpioWaveTxBusy</a></td><td>            Checks to see if the waveform has ended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveTxStop">gpioWaveTxStop</a></td><td>            Aborts the current waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveGetCbs">gpioWaveGetCbs</a></td><td>            Length in CBs of the current waveform
</td></tr><tr><td><a href="#gpioWaveGetHighCbs">gpioWaveGetHighCbs</a></td><td>        Length of longest waveform so far
</td></tr><tr><td><a href="#gpioWaveGetMaxCbs">gpioWaveGetMaxCbs</a></td><td>         Absolute maximum allowed CBs
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveGetMicros">gpioWaveGetMicros</a></td><td>         Length in micros of the current waveform
</td></tr><tr><td><a href="#gpioWaveGetHighMicros">gpioWaveGetHighMicros</a></td><td>     Length of longest waveform so far
</td></tr><tr><td><a href="#gpioWaveGetMaxMicros">gpioWaveGetMaxMicros</a></td><td>      Absolute maximum allowed micros
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioWaveGetPulses">gpioWaveGetPulses</a></td><td>         Length in pulses of the current waveform
</td></tr><tr><td><a href="#gpioWaveGetHighPulses">gpioWaveGetHighPulses</a></td><td>     Length of longest waveform so far
</td></tr><tr><td><a href="#gpioWaveGetMaxPulses">gpioWaveGetMaxPulses</a></td><td>      Absolute maximum allowed pulses
</td></tr><tr><td></td><td></td></tr><tr><td><b>UTILITIES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioDelay">gpioDelay</a></td><td>                 Delay for a number of microseconds
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioTick">gpioTick</a></td><td>                  Get current tick (microseconds)
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioHardwareRevision">gpioHardwareRevision</a></td><td>      Get hardware revision
</td></tr><tr><td><a href="#gpioVersion">gpioVersion</a></td><td>               Get the pigpio version
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#getBitInBytes">getBitInBytes</a></td><td>             Get the value of a bit
</td></tr><tr><td><a href="#putBitInBytes">putBitInBytes</a></td><td>             Set the value of a bit
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioTime">gpioTime</a></td><td>                  Get current time
</td></tr><tr><td><a href="#gpioSleep">gpioSleep</a></td><td>                 Sleep for specified time
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#time_sleep">time_sleep</a></td><td>                Sleeps for a float number of seconds
</td></tr><tr><td><a href="#time_time">time_time</a></td><td>                 Float number of seconds since the epoch
</td></tr><tr><td></td><td></td></tr><tr><td><b>CONFIGURATION
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioCfgBufferSize">gpioCfgBufferSize</a></td><td>         Configure the GPIO sample buffer size
</td></tr><tr><td><a href="#gpioCfgClock">gpioCfgClock</a></td><td>              Configure the GPIO sample rate
</td></tr><tr><td><a href="#gpioCfgDMAchannel">gpioCfgDMAchannel</a></td><td>         Configure the DMA channel (DEPRECATED)
</td></tr><tr><td><a href="#gpioCfgDMAchannels">gpioCfgDMAchannels</a></td><td>        Configure the DMA channels
</td></tr><tr><td><a href="#gpioCfgPermissions">gpioCfgPermissions</a></td><td>        Configure the GPIO access permissions
</td></tr><tr><td><a href="#gpioCfgInterfaces">gpioCfgInterfaces</a></td><td>         Configure user interfaces
</td></tr><tr><td><a href="#gpioCfgSocketPort">gpioCfgSocketPort</a></td><td>         Configure socket port
</td></tr><tr><td><a href="#gpioCfgMemAlloc">gpioCfgMemAlloc</a></td><td>           Configure DMA memory allocation mode
</td></tr><tr><td><a href="#gpioCfgNetAddr">gpioCfgNetAddr</a></td><td>            Configure allowed network addresses
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpioCfgInternals">gpioCfgInternals</a></td><td>          Configure misc. internals (DEPRECATED)
</td></tr><tr><td><a href="#gpioCfgGetInternals">gpioCfgGetInternals</a></td><td>       Get internal configuration settings
</td></tr><tr><td><a href="#gpioCfgSetInternals">gpioCfgSetInternals</a></td><td>       Set internal configuration settings
</td></tr><tr><td></td><td></td></tr><tr><td><b>EXPERT
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#rawWaveAddSPI">rawWaveAddSPI</a></td><td>             Not intended for general use
</td></tr><tr><td><a href="#rawWaveAddGeneric">rawWaveAddGeneric</a></td><td>         Not intended for general use
</td></tr><tr><td><a href="#rawWaveCB">rawWaveCB</a></td><td>                 Not intended for general use
</td></tr><tr><td><a href="#rawWaveCBAdr">rawWaveCBAdr</a></td><td>              Not intended for general use
</td></tr><tr><td><a href="#rawWaveGetOOL">rawWaveGetOOL</a></td><td>             Not intended for general use
</td></tr><tr><td><a href="#rawWaveSetOOL">rawWaveSetOOL</a></td><td>             Not intended for general use
</td></tr><tr><td><a href="#rawWaveGetOut">rawWaveGetOut</a></td><td>             Not intended for general use
</td></tr><tr><td><a href="#rawWaveSetOut">rawWaveSetOut</a></td><td>             Not intended for general use
</td></tr><tr><td><a href="#rawWaveGetIn">rawWaveGetIn</a></td><td>              Not intended for general use
</td></tr><tr><td><a href="#rawWaveSetIn">rawWaveSetIn</a></td><td>              Not intended for general use
</td></tr><tr><td><a href="#rawWaveInfo">rawWaveInfo</a></td><td>               Not intended for general use
</td></tr><tr><td><a href="#rawDumpWave">rawDumpWave</a></td><td>               Not intended for general use
</td></tr><tr><td><a href="#rawDumpScript">rawDumpScript</a></td><td>             Not intended for general use
</td></tr><tr><td></td><td></td></tr></tbody></table><h2>FUNCTIONS</h2><h3><a name="gpioInitialise"></a><a href="#int"><small>int</small></a> gpioInitialise<small>(void)</small></h3>
Initialises the library.
<br><br>Returns the pigpio version number if OK, otherwise PI_INIT_FAILED.
<br><br>gpioInitialise must be called before using the other library functions
with the following exceptions:
<br><br><code><a href="#gpioCfg*">gpioCfg*</a><br><a href="#gpioVersion">gpioVersion</a><br><a href="#gpioHardwareRevision">gpioHardwareRevision</a><br></code><br><br><b><small>Example</small></b><br><br><code>if&nbsp;(gpioInitialise()&nbsp;&lt;&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;pigpio&nbsp;initialisation&nbsp;failed.<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;pigpio&nbsp;initialised&nbsp;okay.<br>}<br></code><h3><a name="gpioTerminate"></a><a href="#void"><small>void</small></a> gpioTerminate<small>(void)</small></h3>
Terminates the library.
<br><br>Returns nothing.
<br><br>Call before program exit.
<br><br>This function resets the used DMA channels, releases memory, and
terminates any running threads.
<br><br><b><small>Example</small></b><br><br><code>gpioTerminate();<br></code><h3><a name="gpioSetMode"></a><a href="#int"><small>int</small></a> gpioSetMode<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#mode">mode</a>)</small></h3>
Sets the GPIO mode, typically input or output.
<br><br><code>gpio:&nbsp;0-53<br>mode:&nbsp;0-7<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_MODE.
<br><br>Arduino style: pinMode.
<br><br><b><small>Example</small></b><br><br><code>gpioSetMode(17,&nbsp;PI_INPUT);&nbsp;&nbsp;//&nbsp;Set&nbsp;GPIO17&nbsp;as&nbsp;input.<br><br>gpioSetMode(18,&nbsp;PI_OUTPUT);&nbsp;//&nbsp;Set&nbsp;GPIO18&nbsp;as&nbsp;output.<br><br>gpioSetMode(22,PI_ALT0);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Set&nbsp;GPIO22&nbsp;to&nbsp;alternative&nbsp;mode&nbsp;0.<br></code><br><br>See <a href="http://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf">http://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf</a> page 102 for an overview of the modes.
<h3><a name="gpioGetMode"></a><a href="#int"><small>int</small></a> gpioGetMode<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>)</small></h3>
Gets the GPIO mode.
<br><br><code>gpio:&nbsp;0-53<br></code><br><br>Returns the GPIO mode if OK, otherwise PI_BAD_GPIO.
<br><br><b><small>Example</small></b><br><br><code>if&nbsp;(gpioGetMode(17)&nbsp;!=&nbsp;PI_ALT0)<br>{<br>&nbsp;&nbsp;&nbsp;gpioSetMode(17,&nbsp;PI_ALT0);&nbsp;&nbsp;//&nbsp;set&nbsp;GPIO17&nbsp;to&nbsp;ALT0<br>}<br></code><h3><a name="gpioSetPullUpDown"></a><a href="#int"><small>int</small></a> gpioSetPullUpDown<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#pud">pud</a>)</small></h3>
Sets or clears resistor pull ups or downs on the GPIO.
<br><br><code>gpio:&nbsp;0-53<br>&nbsp;pud:&nbsp;0-2<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_PUD.
<br><br><b><small>Example</small></b><br><br><code>gpioSetPullUpDown(17,&nbsp;PI_PUD_UP);&nbsp;&nbsp;&nbsp;//&nbsp;Sets&nbsp;a&nbsp;pull-up.<br><br>gpioSetPullUpDown(18,&nbsp;PI_PUD_DOWN);&nbsp;//&nbsp;Sets&nbsp;a&nbsp;pull-down.<br><br>gpioSetPullUpDown(23,&nbsp;PI_PUD_OFF);&nbsp;&nbsp;//&nbsp;Clear&nbsp;any&nbsp;pull-ups/downs.<br></code><h3><a name="gpioRead"></a><a href="#int"><small>int</small></a> gpioRead<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>)</small></h3>
Reads the GPIO level, on or off.
<br><br><code>gpio:&nbsp;0-53<br></code><br><br>Returns the GPIO level if OK, otherwise PI_BAD_GPIO.
<br><br>Arduino style: digitalRead.
<br><br><b><small>Example</small></b><br><br><code>printf("GPIO24&nbsp;is&nbsp;level&nbsp;%d",&nbsp;gpioRead(24));<br></code><h3><a name="gpioWrite"></a><a href="#int"><small>int</small></a> gpioWrite<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#level">level</a>)</small></h3>
Sets the GPIO level, on or off.
<br><br><code>&nbsp;gpio:&nbsp;0-53<br>level:&nbsp;0-1<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO or PI_BAD_LEVEL.
<br><br>If PWM or servo pulses are active on the GPIO they are switched off.
<br><br>Arduino style: digitalWrite
<br><br><b><small>Example</small></b><br><br><code>gpioWrite(24,&nbsp;1);&nbsp;//&nbsp;Set&nbsp;GPIO24&nbsp;high.<br></code><h3><a name="gpioPWM"></a><a href="#int"><small>int</small></a> gpioPWM<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#dutycycle">dutycycle</a>)</small></h3>
Starts PWM on the GPIO, dutycycle between 0 (off) and range (fully on).
Range defaults to 255.
<br><br><code>user_gpio:&nbsp;0-31<br>dutycycle:&nbsp;0-range<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_DUTYCYCLE.
<br><br>Arduino style: analogWrite
<br><br>This and the servo functionality use the DMA and PWM or PCM peripherals
to control and schedule the pulse lengths and dutycycles.
<br><br>The <a href="#gpioSetPWMrange">gpioSetPWMrange</a> function may be used to change the default
range of 255.
<br><br><b><small>Example</small></b><br><br><code>gpioPWM(17,&nbsp;255);&nbsp;//&nbsp;Sets&nbsp;GPIO17&nbsp;full&nbsp;on.<br><br>gpioPWM(18,&nbsp;128);&nbsp;//&nbsp;Sets&nbsp;GPIO18&nbsp;half&nbsp;on.<br><br>gpioPWM(23,&nbsp;0);&nbsp;&nbsp;&nbsp;//&nbsp;Sets&nbsp;GPIO23&nbsp;full&nbsp;off.<br></code><h3><a name="gpioGetPWMdutycycle"></a><a href="#int"><small>int</small></a> gpioGetPWMdutycycle<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the PWM dutycycle setting for the GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br></code><br><br>Returns between 0 (off) and range (fully on) if OK, otherwise
PI_BAD_USER_GPIO or PI_NOT_PWM_GPIO.
<br><br>For normal PWM the dutycycle will be out of the defined range
for the GPIO (see <a href="#gpioGetPWMrange">gpioGetPWMrange</a>).
<br><br>If a hardware clock is active on the GPIO the reported dutycycle
will be 500000 (500k) out of 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported dutycycle
will be out of a 1000000 (1M).
<br><br>Normal PWM range defaults to 255.
<h3><a name="gpioSetPWMrange"></a><a href="#int"><small>int</small></a> gpioSetPWMrange<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#range">range</a>)</small></h3>
Selects the dutycycle range to be used for the GPIO.  Subsequent calls
to gpioPWM will use a dutycycle between 0 (off) and range (fully on).
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;range:&nbsp;25-40000<br></code><br><br>Returns the real range for the given GPIO's frequency if OK,
otherwise PI_BAD_USER_GPIO or PI_BAD_DUTYRANGE.
<br><br>If PWM is currently active on the GPIO its dutycycle will be scaled
to reflect the new range.
<br><br>The real range, the number of steps between fully off and fully
on for each frequency, is given in the following table.
<br><br><code>&nbsp;&nbsp;25,&nbsp;&nbsp;&nbsp;50,&nbsp;&nbsp;100,&nbsp;&nbsp;125,&nbsp;&nbsp;200,&nbsp;&nbsp;250,&nbsp;&nbsp;400,&nbsp;&nbsp;&nbsp;500,&nbsp;&nbsp;&nbsp;625,<br>&nbsp;800,&nbsp;1000,&nbsp;1250,&nbsp;2000,&nbsp;2500,&nbsp;4000,&nbsp;5000,&nbsp;10000,&nbsp;20000<br></code><br><br>The real value set by <a href="#gpioPWM">gpioPWM</a> is (dutycycle * real range) / range.
<br><br><b><small>Example</small></b><br><br><code>gpioSetPWMrange(24,&nbsp;2000);&nbsp;//&nbsp;Now&nbsp;2000&nbsp;is&nbsp;fully&nbsp;on<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000&nbsp;is&nbsp;half&nbsp;on<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500&nbsp;is&nbsp;quarter&nbsp;on,&nbsp;etc.<br></code><h3><a name="gpioGetPWMrange"></a><a href="#int"><small>int</small></a> gpioGetPWMrange<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the dutycycle range used for the GPIO if OK, otherwise
PI_BAD_USER_GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br></code><br><br>If a hardware clock or hardware PWM is active on the GPIO
the reported range will be 1000000 (1M).
<br><br><b><small>Example</small></b><br><br><code>r&nbsp;=&nbsp;gpioGetPWMrange(23);<br></code><h3><a name="gpioGetPWMrealRange"></a><a href="#int"><small>int</small></a> gpioGetPWMrealRange<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the real range used for the GPIO if OK, otherwise
PI_BAD_USER_GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br></code><br><br>If a hardware clock is active on the GPIO the reported real
range will be 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported real range
will be approximately 250M divided by the set PWM frequency.
<br><br><b><small>Example</small></b><br><br><code>rr&nbsp;=&nbsp;gpioGetPWMrealRange(17);<br></code><h3><a name="gpioSetPWMfrequency"></a><a href="#int"><small>int</small></a> gpioSetPWMfrequency<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#frequency">frequency</a>)</small></h3>
Sets the frequency in hertz to be used for the GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br>frequency:&nbsp;&gt;=0<br></code><br><br>Returns the numerically closest frequency if OK, otherwise
PI_BAD_USER_GPIO.
<br><br>If PWM is currently active on the GPIO it will be
switched off and then back on at the new frequency.
<br><br>Each GPIO can be independently set to one of 18 different PWM
frequencies.
<br><br>The selectable frequencies depend upon the sample rate which
may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).
<br><br>The frequencies for each sample rate are:
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hertz<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;40000&nbsp;20000&nbsp;10000&nbsp;8000&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1600<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1250&nbsp;&nbsp;1000&nbsp;&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;20000&nbsp;10000&nbsp;&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;800<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;625&nbsp;&nbsp;&nbsp;500&nbsp;&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;10000&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;400<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;313&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13<br>sample<br>&nbsp;rate<br>&nbsp;(us)&nbsp;&nbsp;5:&nbsp;&nbsp;8000&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;1600&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;320<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;&nbsp;160&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;313&nbsp;&nbsp;250&nbsp;&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;156&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;6<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;160<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;5<br></code><br><br><b><small>Example</small></b><br><br><code>gpioSetPWMfrequency(23,&nbsp;0);&nbsp;//&nbsp;Set&nbsp;GPIO23&nbsp;to&nbsp;lowest&nbsp;frequency.<br><br>gpioSetPWMfrequency(24,&nbsp;500);&nbsp;//&nbsp;Set&nbsp;GPIO24&nbsp;to&nbsp;500Hz.<br><br>gpioSetPWMfrequency(25,&nbsp;100000);&nbsp;//&nbsp;Set&nbsp;GPIO25&nbsp;to&nbsp;highest&nbsp;frequency.<br></code><h3><a name="gpioGetPWMfrequency"></a><a href="#int"><small>int</small></a> gpioGetPWMfrequency<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the frequency (in hertz) used for the GPIO if OK, otherwise
PI_BAD_USER_GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br></code><br><br>For normal PWM the frequency will be that defined for the GPIO by
<a href="#gpioSetPWMfrequency">gpioSetPWMfrequency</a>.
<br><br>If a hardware clock is active on the GPIO the reported frequency
will be that set by <a href="#gpioHardwareClock">gpioHardwareClock</a>.
<br><br>If hardware PWM is active on the GPIO the reported frequency
will be that set by <a href="#gpioHardwarePWM">gpioHardwarePWM</a>.
<br><br><b><small>Example</small></b><br><br><code>f&nbsp;=&nbsp;gpioGetPWMfrequency(23);&nbsp;//&nbsp;Get&nbsp;frequency&nbsp;used&nbsp;for&nbsp;GPIO23.<br></code><h3><a name="gpioServo"></a><a href="#int"><small>int</small></a> gpioServo<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#pulsewidth">pulsewidth</a>)</small></h3>
Starts servo pulses on the GPIO, 0 (off), 500 (most anti-clockwise) to
2500 (most clockwise).
<br><br><code>&nbsp;user_gpio:&nbsp;0-31<br>pulsewidth:&nbsp;0,&nbsp;500-2500<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_PULSEWIDTH.
<br><br>The range supported by servos varies and should probably be determined
by experiment.  A value of 1500 should always be safe and represents
the mid-point of rotation.  You can DAMAGE a servo if you command it
to move beyond its limits.
<br><br>The following causes an on pulse of 1500 microseconds duration to be
transmitted on GPIO 17 at a rate of 50 times per second. This will
command a servo connected to GPIO 17 to rotate to its mid-point.
<br><br><b><small>Example</small></b><br><br><code>gpioServo(17,&nbsp;1000);&nbsp;//&nbsp;Move&nbsp;servo&nbsp;to&nbsp;safe&nbsp;position&nbsp;anti-clockwise.<br><br>gpioServo(23,&nbsp;1500);&nbsp;//&nbsp;Move&nbsp;servo&nbsp;to&nbsp;centre&nbsp;position.<br><br>gpioServo(25,&nbsp;2000);&nbsp;//&nbsp;Move&nbsp;servo&nbsp;to&nbsp;safe&nbsp;position&nbsp;clockwise.<br></code><br><br>OTHER UPDATE RATES:
<br><br>This function updates servos at 50Hz.  If you wish to use a different
update frequency you will have to use the PWM functions.
<br><br><code>PWM&nbsp;Hz&nbsp;&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;200&nbsp;&nbsp;400&nbsp;&nbsp;500<br>1E6/Hz&nbsp;20000&nbsp;10000&nbsp;5000&nbsp;2500&nbsp;2000<br></code><br><br>Firstly set the desired PWM frequency using <a href="#gpioSetPWMfrequency">gpioSetPWMfrequency</a>.
<br><br>Then set the PWM range using <a href="#gpioSetPWMrange">gpioSetPWMrange</a> to 1E6/frequency.
Doing this allows you to use units of microseconds when setting
the servo pulsewidth.
<br><br>E.g. If you want to update a servo connected to GPIO25 at 400Hz
<br><br><code>gpioSetPWMfrequency(25,&nbsp;400);<br><br>gpioSetPWMrange(25,&nbsp;2500);<br></code><br><br>Thereafter use the PWM command to move the servo,
e.g. gpioPWM(25, 1500) will set a 1500 us pulse.
<h3><a name="gpioGetServoPulsewidth"></a><a href="#int"><small>int</small></a> gpioGetServoPulsewidth<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the servo pulsewidth setting for the GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br></code><br><br>Returns 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise)
if OK, otherwise PI_BAD_USER_GPIO or PI_NOT_SERVO_GPIO.
<h3><a name="gpioSetAlertFunc"></a><a href="#int"><small>int</small></a> gpioSetAlertFunc<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#gpioAlertFunc_t">gpioAlertFunc_t</a> <a href="#f">f</a>)</small></h3>
Registers a function to be called (a callback) when the specified
GPIO changes state.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO.
<br><br>One callback may be registered per GPIO.
<br><br>The callback is passed the GPIO, the new level, and the tick.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(a&nbsp;watchdog&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br></code><br><br>The alert may be cancelled by passing NULL as the function.
<br><br>The GPIO are sampled at a rate set when the library is started.
<br><br>If a value isn't specifically set the default of 5 us is used.
<br><br>The number of samples per second is given in the following table.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;samples<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;per&nbsp;sec<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1,000,000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;500,000<br>sample&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;250,000<br>rate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;200,000<br>(us)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;125,000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;100,000<br></code><br><br>Level changes shorter than the sample rate may be missed.
<br><br>The thread which calls the alert functions is triggered nominally
1000 times per second.  The active alert functions will be called
once per level change since the last time the thread was activated.
i.e. The active alert functions will get all level changes but there
will be a latency.
<br><br>If you want to track the level of more than one GPIO do so by
maintaining the state in the callback.  Do not use <a href="#gpioRead">gpioRead</a>.
Remember the event that triggered the callback may have
happened several milliseconds before and the GPIO may have
changed level many times since then.
<br><br>The tick value is the time stamp of the sample in microseconds, see
<a href="#gpioTick">gpioTick</a> for more details.
<br><br><b><small>Example</small></b><br><br><code>void&nbsp;aFunction(int&nbsp;gpio,&nbsp;int&nbsp;level,&nbsp;uint32_t&nbsp;tick)<br>{<br>&nbsp;&nbsp;&nbsp;printf("GPIO&nbsp;%d&nbsp;became&nbsp;%d&nbsp;at&nbsp;%d",&nbsp;gpio,&nbsp;level,&nbsp;tick);<br>}<br><br>//&nbsp;call&nbsp;aFunction&nbsp;whenever&nbsp;GPIO&nbsp;4&nbsp;changes&nbsp;state<br><br>gpioSetAlertFunc(4,&nbsp;aFunction);<br></code><h3><a name="gpioSetAlertFuncEx"></a><a href="#int"><small>int</small></a> gpioSetAlertFuncEx<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#gpioAlertFuncEx_t">gpioAlertFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Registers a function to be called (a callback) when the specified
GPIO changes state.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br>&nbsp;userdata:&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO.
<br><br>One callback may be registered per GPIO.
<br><br>The callback is passed the GPIO, the new level, the tick, and
the userdata pointer.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(a&nbsp;watchdog&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br><br>userdata&nbsp;&nbsp;&nbsp;&nbsp;pointer&nbsp;&nbsp;Pointer&nbsp;to&nbsp;an&nbsp;arbitrary&nbsp;object<br></code><br><br>See <a href="#gpioSetAlertFunc">gpioSetAlertFunc</a> for further details.
<br><br>Only one of <a href="#gpioSetAlertFunc">gpioSetAlertFunc</a> or <a href="#gpioSetAlertFuncEx">gpioSetAlertFuncEx</a> can be
registered per GPIO.
<h3><a name="gpioSetISRFunc"></a><a href="#int"><small>int</small></a> gpioSetISRFunc<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#edge">edge</a>, <a href="#int">int</a> <a href="#timeout">timeout</a>, <a href="#gpioISRFunc_t">gpioISRFunc_t</a> <a href="#f">f</a>)</small></h3>
Registers a function to be called (a callback) whenever the specified
GPIO interrupt occurs.
<br><br><code>&nbsp;&nbsp;&nbsp;gpio:&nbsp;0-53<br>&nbsp;&nbsp;&nbsp;edge:&nbsp;RISING_EDGE,&nbsp;FALLING_EDGE,&nbsp;or&nbsp;EITHER_EDGE<br>timeout:&nbsp;interrupt&nbsp;timeout&nbsp;in&nbsp;milliseconds&nbsp;(&lt;=0&nbsp;to&nbsp;cancel)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_EDGE,
or PI_BAD_ISR_INIT.
<br><br>One function may be registered per GPIO.
<br><br>The function is passed the GPIO, the current level, and the
current tick.  The level will be PI_TIMEOUT if the optional
interrupt timeout expires.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(interrupt&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br></code><br><br>The underlying Linux sysfs GPIO interface is used to provide
the interrupt services.
<br><br>The first time the function is called, with a non-NULL f, the
GPIO is exported, set to be an input, and set to interrupt
on the given edge and timeout.
<br><br>Subsequent calls, with a non-NULL f, can vary one or more of the
edge, timeout, or function.
<br><br>The ISR may be cancelled by passing a NULL f, in which case the
GPIO is unexported.
<br><br>The tick is that read at the time the process was informed of
the interrupt.  This will be a variable number of microseconds
after the interrupt occurred.  Typically the latency will be of
the order of 50 microseconds.  The latency is not guaranteed
and will vary with system load.
<br><br>The level is that read at the time the process was informed of
the interrupt, or PI_TIMEOUT if the optional interrupt timeout
expired.  It may not be the same as the expected edge as
interrupts happening in rapid succession may be missed by the
kernel (i.e. this mechanism can not be used to capture several
interrupts only a few microseconds apart).
<h3><a name="gpioSetISRFuncEx"></a><a href="#int"><small>int</small></a> gpioSetISRFuncEx<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#edge">edge</a>, <a href="#int">int</a> <a href="#timeout">timeout</a>, <a href="#gpioISRFuncEx_t">gpioISRFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Registers a function to be called (a callback) whenever the specified
GPIO interrupt occurs.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;gpio:&nbsp;0-53<br>&nbsp;&nbsp;&nbsp;&nbsp;edge:&nbsp;RISING_EDGE,&nbsp;FALLING_EDGE,&nbsp;or&nbsp;EITHER_EDGE<br>&nbsp;timeout:&nbsp;interrupt&nbsp;timeout&nbsp;in&nbsp;milliseconds&nbsp;(&lt;=0&nbsp;to&nbsp;cancel)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br>userdata:&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_BAD_EDGE,
or PI_BAD_ISR_INIT.
<br><br>The function is passed the GPIO, the current level, the
current tick, and the userdata pointer.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(interrupt&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br><br>userdata&nbsp;&nbsp;&nbsp;&nbsp;pointer&nbsp;&nbsp;Pointer&nbsp;to&nbsp;an&nbsp;arbitrary&nbsp;object<br></code><br><br>Only one of <a href="#gpioSetISRFunc">gpioSetISRFunc</a> or <a href="#gpioSetISRFuncEx">gpioSetISRFuncEx</a> can be
registered per GPIO.
<br><br>See <a href="#gpioSetISRFunc">gpioSetISRFunc</a> for further details.
<h3><a name="gpioNotifyOpen"></a><a href="#int"><small>int</small></a> gpioNotifyOpen<small>(void)</small></h3>
This function requests a free notification handle.
<br><br>Returns a handle greater than or equal to zero if OK,
otherwise PI_NO_HANDLE.
<br><br>A notification is a method for being notified of GPIO state changes
via a pipe or socket.
<br><br>Pipe notifications for handle x will be available at the pipe
named /dev/pigpiox (where x is the handle number).  E.g. if the
function returns 15 then the notifications must be read
from /dev/pigpio15.
<br><br>Socket notifications are returned to the socket which requested the
handle.
<br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;gpioNotifyOpen();<br><br>if&nbsp;(h&nbsp;&gt;=&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;sprintf(str,&nbsp;"/dev/pigpio%d",&nbsp;h);<br><br>&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;open(str,&nbsp;O_RDONLY);<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(fd&nbsp;&gt;=&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Okay.<br>&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Error.<br>&nbsp;&nbsp;&nbsp;}<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;Error.<br>}<br></code><h3><a name="gpioNotifyOpenWithSize"></a><a href="#int"><small>int</small></a> gpioNotifyOpenWithSize<small>(<a href="#int">int</a> <a href="#bufSize">bufSize</a>)</small></h3>
This function requests a free notification handle.
<br><br>It differs from <a href="#gpioNotifyOpen">gpioNotifyOpen</a> in that the pipe size may be
specified, whereas <a href="#gpioNotifyOpen">gpioNotifyOpen</a> uses the default pipe size.
<br><br>See <a href="#gpioNotifyOpen">gpioNotifyOpen</a> for further details.
<h3><a name="gpioNotifyBegin"></a><a href="#int"><small>int</small></a> gpioNotifyBegin<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
This function starts notifications on a previously opened handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioNotifyOpen">gpioNotifyOpen</a><br>&nbsp;&nbsp;bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;indicating&nbsp;the&nbsp;GPIO&nbsp;of&nbsp;interest<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br>The notification sends state changes for each GPIO whose corresponding
bit in bits is set.
<br><br>Each notification occupies 12 bytes in the fifo and has the
following structure.
<br><br><code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;seqno;<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;flags;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;tick;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;level;<br>}&nbsp;gpioReport_t;<br></code><br><br>seqno: starts at 0 each time the handle is opened and then increments
by one for each report.
<br><br>flags: three flags are defined, PI_NTFY_FLAGS_WDOG,
PI_NTFY_FLAGS_ALIVE, and PI_NTFY_FLAGS_EVENT.
<br><br>If bit 5 is set (PI_NTFY_FLAGS_WDOG) then bits 0-4 of the flags
indicate a GPIO which has had a watchdog timeout.
<br><br>If bit 6 is set (PI_NTFY_FLAGS_ALIVE) this indicates a keep alive
signal on the pipe/socket and is sent once a minute in the absence
of other notification activity.
<br><br>If bit 7 is set (PI_NTFY_FLAGS_EVENT) then bits 0-4 of the flags
indicate an event which has been triggered.
<br><br>tick: the number of microseconds since system boot.  It wraps around
after 1h12m.
<br><br>level: indicates the level of each GPIO.  If bit 1&lt;&lt;x is set then
GPIO x is high.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;Start&nbsp;notifications&nbsp;for&nbsp;GPIO&nbsp;1,&nbsp;4,&nbsp;6,&nbsp;7,&nbsp;10.<br><br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;76&nbsp;4&nbsp;&nbsp;1<br>//&nbsp;(1234&nbsp;=&nbsp;0x04D2&nbsp;=&nbsp;0b0000010011010010)<br><br>gpioNotifyBegin(h,&nbsp;1234);<br></code><h3><a name="gpioNotifyPause"></a><a href="#int"><small>int</small></a> gpioNotifyPause<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function pauses notifications on a previously opened handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioNotifyOpen">gpioNotifyOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br>Notifications for the handle are suspended until <a href="#gpioNotifyBegin">gpioNotifyBegin</a>
is called again.
<br><br><b><small>Example</small></b><br><br><code>gpioNotifyPause(h);<br></code><h3><a name="gpioNotifyClose"></a><a href="#int"><small>int</small></a> gpioNotifyClose<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function stops notifications on a previously opened handle
and releases the handle for reuse.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioNotifyOpen">gpioNotifyOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br><b><small>Example</small></b><br><br><code>gpioNotifyClose(h);<br></code><h3><a name="gpioWaveClear"></a><a href="#int"><small>int</small></a> gpioWaveClear<small>(void)</small></h3>
This function clears all waveforms and any data added by calls to the
<a href="#gpioWaveAdd*">gpioWaveAdd*</a> functions.
<br><br>Returns 0 if OK.
<br><br><b><small>Example</small></b><br><br><code>gpioWaveClear();<br></code><h3><a name="gpioWaveAddNew"></a><a href="#int"><small>int</small></a> gpioWaveAddNew<small>(void)</small></h3>
This function starts a new empty waveform.
<br><br>You wouldn't normally need to call this function as it is automatically
called after a waveform is created with the <a href="#gpioWaveCreate">gpioWaveCreate</a> function.
<br><br>Returns 0 if OK.
<br><br><b><small>Example</small></b><br><br><code>gpioWaveAddNew();<br></code><h3><a name="gpioWaveAddGeneric"></a><a href="#int"><small>int</small></a> gpioWaveAddGeneric<small>(<a href="#unsigned">unsigned</a> <a href="#numPulses">numPulses</a>, <a href="#gpioPulse_t">gpioPulse_t</a> <a href="#*pulses">*pulses</a>)</small></h3>
This function adds a number of pulses to the current waveform.
<br><br><code>numPulses:&nbsp;the&nbsp;number&nbsp;of&nbsp;pulses<br>&nbsp;&nbsp;&nbsp;pulses:&nbsp;an&nbsp;array&nbsp;of&nbsp;pulses<br></code><br><br>Returns the new total number of pulses in the current waveform if OK,
otherwise PI_TOO_MANY_PULSES.
<br><br>The pulses are interleaved in time order within the existing waveform
(if any).
<br><br>Merging allows the waveform to be built in parts, that is the settings
for GPIO#1 can be added, and then GPIO#2 etc.
<br><br>If the added waveform is intended to start after or within the existing
waveform then the first pulse should consist of a delay.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;Construct&nbsp;and&nbsp;send&nbsp;a&nbsp;30&nbsp;microsecond&nbsp;square&nbsp;wave.<br><br>gpioSetMode(gpio,&nbsp;PI_OUTPUT);<br><br>pulse[0].gpioOn&nbsp;=&nbsp;(1&lt;&lt;gpio);<br>pulse[0].gpioOff&nbsp;=&nbsp;0;<br>pulse[0].usDelay&nbsp;=&nbsp;15;<br><br>pulse[1].gpioOn&nbsp;=&nbsp;0;<br>pulse[1].gpioOff&nbsp;=&nbsp;(1&lt;&lt;gpio);<br>pulse[1].usDelay&nbsp;=&nbsp;15;<br><br>gpioWaveAddNew();<br><br>gpioWaveAddGeneric(2,&nbsp;pulse);<br><br>wave_id&nbsp;=&nbsp;gpioWaveCreate();<br><br>if&nbsp;(wave_id&nbsp;&gt;=&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;gpioWaveTxSend(wave_id,&nbsp;PI_WAVE_MODE_REPEAT);<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;Transmit&nbsp;for&nbsp;30&nbsp;seconds.<br><br>&nbsp;&nbsp;&nbsp;sleep(30);<br><br>&nbsp;&nbsp;&nbsp;gpioWaveTxStop();<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;Wave&nbsp;create&nbsp;failed.<br>}<br></code><h3><a name="gpioWaveAddSerial"></a><a href="#int"><small>int</small></a> gpioWaveAddSerial<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#data_bits">data_bits</a>, <a href="#unsigned">unsigned</a> <a href="#stop_bits">stop_bits</a>, <a href="#unsigned">unsigned</a> <a href="#offset">offset</a>, <a href="#unsigned">unsigned</a> <a href="#numBytes">numBytes</a>, <a href="#char">char</a> <a href="#*str">*str</a>)</small></h3>
This function adds a waveform representing serial data to the
existing waveform (if any).  The serial data starts offset
microseconds from the start of the waveform.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;50-1000000<br>data_bits:&nbsp;1-32<br>stop_bits:&nbsp;2-8<br>&nbsp;&nbsp;&nbsp;offset:&nbsp;&gt;=0<br>&nbsp;numBytes:&nbsp;&gt;=1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str:&nbsp;an&nbsp;array&nbsp;of&nbsp;chars&nbsp;(which&nbsp;may&nbsp;contain&nbsp;nulls)<br></code><br><br>Returns the new total number of pulses in the current waveform if OK,
otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD, PI_BAD_DATABITS,
PI_BAD_STOPBITS, PI_TOO_MANY_CHARS, PI_BAD_SER_OFFSET,
or PI_TOO_MANY_PULSES.
<br><br>NOTES:
<br><br>The serial data is formatted as one start bit, data_bits data bits, and
stop_bits/2 stop bits.
<br><br>It is legal to add serial data streams with different baud rates to
the same waveform.
<br><br>numBytes is the number of bytes of data in str.
<br><br>The bytes required for each character depend upon data_bits.
<br><br>For data_bits 1-8 there will be one byte per character.<br>
For data_bits 9-16 there will be two bytes per character.<br>
For data_bits 17-32 there will be four bytes per character.
<br><br><b><small>Example</small></b><br><br><code>#define&nbsp;MSG_LEN&nbsp;8<br><br>int&nbsp;i;<br>char&nbsp;*str;<br>char&nbsp;data[MSG_LEN];<br><br>str&nbsp;=&nbsp;"Hello&nbsp;world!";<br><br>gpioWaveAddSerial(4,&nbsp;9600,&nbsp;8,&nbsp;2,&nbsp;0,&nbsp;strlen(str),&nbsp;str);<br><br>for&nbsp;(i=0;&nbsp;i&lt;MSG_LEN;&nbsp;i++)&nbsp;data[i]&nbsp;=&nbsp;i;<br><br>//&nbsp;Data&nbsp;added&nbsp;is&nbsp;offset&nbsp;1&nbsp;second&nbsp;from&nbsp;the&nbsp;waveform&nbsp;start.<br>gpioWaveAddSerial(4,&nbsp;9600,&nbsp;8,&nbsp;2,&nbsp;1000000,&nbsp;MSG_LEN,&nbsp;data);<br></code><h3><a name="gpioWaveCreate"></a><a href="#int"><small>int</small></a> gpioWaveCreate<small>(void)</small></h3>
This function creates a waveform from the data provided by the prior
calls to the <a href="#gpioWaveAdd*">gpioWaveAdd*</a> functions.  Upon success a wave id
greater than or equal to 0 is returned, otherwise PI_EMPTY_WAVEFORM,
PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.
<br><br>The data provided by the <a href="#gpioWaveAdd*">gpioWaveAdd*</a> functions is consumed by this
function.
<br><br>As many waveforms may be created as there is space available.  The
wave id is passed to <a href="#gpioWaveTxSend">gpioWaveTxSend</a> to specify the waveform to transmit.
<br><br>Normal usage would be
<br><br>Step 1. <a href="#gpioWaveClear">gpioWaveClear</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#gpioWaveAdd*">gpioWaveAdd*</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#gpioWaveCreate">gpioWaveCreate</a> to create the waveform and get a unique id
<br><br>Repeat steps 2 and 3 as needed.
<br><br>Step 4. <a href="#gpioWaveTxSend">gpioWaveTxSend</a> with the id of the waveform to transmit.
<br><br>A waveform comprises one of more pulses.  Each pulse consists of a
<a href="#gpioPulse_t">gpioPulse_t</a> structure.
<br><br><code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOn;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOff;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;usDelay;<br>}&nbsp;gpioPulse_t;<br></code><br><br>The fields specify
<br><br>1) the GPIO to be switched on at the start of the pulse.<br>
2) the GPIO to be switched off at the start of the pulse.<br>
3) the delay in microseconds before the next pulse.
<br><br>Any or all the fields can be zero.  It doesn't make any sense to
set all the fields to zero (the pulse will be ignored).
<br><br>When a waveform is started each pulse is executed in order with the
specified delay between the pulse and the next.
<br><br>Returns the new waveform id if OK, otherwise PI_EMPTY_WAVEFORM,
PI_NO_WAVEFORM_ID, PI_TOO_MANY_CBS, or PI_TOO_MANY_OOL.
<h3><a name="gpioWaveCreatePad"></a><a href="#int"><small>int</small></a> gpioWaveCreatePad<small>(<a href="#int">int</a> <a href="#pctCB">pctCB</a>, <a href="#int">int</a> <a href="#pctBOOL">pctBOOL</a>, <a href="#int">int</a> <a href="#pctTOOL">pctTOOL</a>)</small></h3>
Similar to <a href="#gpioWaveCreate">gpioWaveCreate</a>, this function creates a waveform but pads the consumed
resources. Padded waves of equal dimension can be re-cycled efficiently allowing
newly created waves to re-use the resources of deleted waves of the same dimension.
<br><br><code>pctCB:&nbsp;0-100,&nbsp;the&nbsp;percent&nbsp;of&nbsp;all&nbsp;DMA&nbsp;control&nbsp;blocks&nbsp;to&nbsp;consume.<br>pctBOOL:&nbsp;0-100,&nbsp;percent&nbsp;On-Off-Level&nbsp;(OOL)&nbsp;buffer&nbsp;to&nbsp;consume&nbsp;for&nbsp;wave&nbsp;output.<br>pctTOOL:&nbsp;0-100,&nbsp;the&nbsp;percent&nbsp;of&nbsp;OOL&nbsp;buffer&nbsp;to&nbsp;consume&nbsp;for&nbsp;wave&nbsp;input&nbsp;(flags).<br></code><br><br>Upon success a wave id greater than or equal to 0 is returned, otherwise
PI_EMPTY_WAVEFORM, PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.
<br><br>Waveform data provided by <a href="#gpioWaveAdd*">gpioWaveAdd*</a> and <a href="#rawWaveAdd*">rawWaveAdd*</a> functions are
consumed by this function.
<br><br>A usage would be the creation of two waves where one is filled while the other
is being transmitted. Each wave is assigned 50% of the resources.
This buffer structure allows the transmission of infinite wave sequences.
<br><br><b><small>Example</small></b><br><br><code>&nbsp;&nbsp;//&nbsp;get&nbsp;firstWaveChunk,&nbsp;somehow<br>&nbsp;&nbsp;gpioWaveAddGeneric(firstWaveChunk);<br>&nbsp;&nbsp;wid&nbsp;=&nbsp;gpioWaveCreatePad(50,&nbsp;50,&nbsp;0);<br>&nbsp;&nbsp;gpioWaveTxSend(wid,&nbsp;PI_WAVE_MODE_ONE_SHOT);<br>&nbsp;&nbsp;//&nbsp;get&nbsp;nextWaveChunk<br><br>&nbsp;&nbsp;while&nbsp;(nextWaveChunk)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpioWaveAddGeneric(nextWaveChunk);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextWid&nbsp;=&nbsp;gpioWaveCreatePad(50,&nbsp;50,&nbsp;0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpioWaveTxSend(nextWid,&nbsp;PI_WAVE_MODE_ONE_SHOT_SYNC);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(gpioWaveTxAt()&nbsp;==&nbsp;wid)&nbsp;time_sleep(0.1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpioWaveDelete(wid);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid&nbsp;=&nbsp;nextWid;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;get&nbsp;nextWaveChunk<br>&nbsp;&nbsp;}<br></code><h3><a name="gpioWaveDelete"></a><a href="#int"><small>int</small></a> gpioWaveDelete<small>(<a href="#unsigned">unsigned</a> <a href="#wave_id">wave_id</a>)</small></h3>
This function deletes the waveform with id wave_id.
<br><br>The wave is flagged for deletion.  The resources used by the wave
will only be reused when either of the following apply.
<br><br>- all waves with higher numbered wave ids have been deleted or have
been flagged for deletion.
<br><br>- a new wave is created which uses exactly the same resources as
the current wave (see the C source for gpioWaveCreate for details).
<br><br><code>wave_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioWaveCreate">gpioWaveCreate</a><br></code><br><br>Wave ids are allocated in order, 0, 1, 2, etc.
<br><br>Returns 0 if OK, otherwise PI_BAD_WAVE_ID.
<h3><a name="gpioWaveTxSend"></a><a href="#int"><small>int</small></a> gpioWaveTxSend<small>(<a href="#unsigned">unsigned</a> <a href="#wave_id">wave_id</a>, <a href="#unsigned">unsigned</a> <a href="#wave_mode">wave_mode</a>)</small></h3>
This function transmits the waveform with id wave_id.  The mode
determines whether the waveform is sent once or cycles endlessly.
The SYNC variants wait for the current waveform to reach the
end of a cycle or finish before starting the new waveform.
<br><br>WARNING: bad things may happen if you delete the previous
waveform before it has been synced to the new waveform.
<br><br>NOTE: Any hardware PWM started by <a href="#gpioHardwarePWM">gpioHardwarePWM</a> will be cancelled.
<br><br><code>&nbsp;&nbsp;wave_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioWaveCreate">gpioWaveCreate</a><br>wave_mode:&nbsp;PI_WAVE_MODE_ONE_SHOT,&nbsp;PI_WAVE_MODE_REPEAT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PI_WAVE_MODE_ONE_SHOT_SYNC,&nbsp;PI_WAVE_MODE_REPEAT_SYNC<br></code><br><br>Returns the number of DMA control blocks in the waveform if OK,
otherwise PI_BAD_WAVE_ID, or PI_BAD_WAVE_MODE.
<h3><a name="gpioWaveChain"></a><a href="#int"><small>int</small></a> gpioWaveChain<small>(<a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#bufSize">bufSize</a>)</small></h3>
This function transmits a chain of waveforms.
<br><br>NOTE: Any hardware PWM started by <a href="#gpioHardwarePWM">gpioHardwarePWM</a> will be cancelled.
<br><br>The waves to be transmitted are specified by the contents of buf
which contains an ordered list of <a href="#wave_id">wave_id</a>s and optional command
codes and related data.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;pointer&nbsp;to&nbsp;the&nbsp;wave_ids&nbsp;and&nbsp;optional&nbsp;command&nbsp;codes<br>bufSize:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;in&nbsp;buf<br></code><br><br>Returns 0 if OK, otherwise PI_CHAIN_NESTING, PI_CHAIN_LOOP_CNT, PI_BAD_CHAIN_LOOP, PI_BAD_CHAIN_CMD, PI_CHAIN_COUNTER,
PI_BAD_CHAIN_DELAY, PI_CHAIN_TOO_BIG, or PI_BAD_WAVE_ID.
<br><br>Each wave is transmitted in the order specified.  A wave may
occur multiple times per chain.
<br><br>A blocks of waves may be transmitted multiple times by using
the loop commands. The block is bracketed by loop start and
end commands.  Loops may be nested.
<br><br>Delays between waves may be added with the delay command.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>Loop Start</td><td>255 0</td><td>Identify start of a wave block</td></tr><tr><td>Loop Repeat</td><td>255 1 x y</td><td>loop x + y*256 times</td></tr><tr><td>Delay</td><td>255 2 x y</td><td>delay x + y*256 microseconds</td></tr><tr><td>Loop Forever</td><td>255 3</td><td>loop forever</td></tr></tbody></table><br><br>If present Loop Forever must be the last entry in the chain.
<br><br>The code is currently dimensioned to support a chain with roughly
600 entries and 20 loop counters.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpio.h&gt;<br><br>#define&nbsp;WAVES&nbsp;5<br>#define&nbsp;GPIO&nbsp;4<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;wid[WAVES];<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(gpioInitialise()&lt;0)&nbsp;return&nbsp;-1;<br><br>&nbsp;&nbsp;&nbsp;gpioSetMode(GPIO,&nbsp;PI_OUTPUT);<br><br>&nbsp;&nbsp;&nbsp;printf("start&nbsp;piscope,&nbsp;press&nbsp;return");&nbsp;getchar();<br><br>&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;WAVES;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpioWaveAddGeneric(2,&nbsp;(gpioPulse_t[])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{1&lt;&lt;GPIO,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0,&nbsp;1&lt;&lt;GPIO,&nbsp;(i+1)*200}});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[i]&nbsp;=&nbsp;gpioWaveCreate();<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;gpioWaveChain((char&nbsp;[])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[4],&nbsp;wid[3],&nbsp;wid[2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;4+3+2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[0],&nbsp;wid[0],&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;0+1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;2,&nbsp;0x88,&nbsp;0x13,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;delay&nbsp;5000us<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;30,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;30&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[2],&nbsp;wid[3],&nbsp;wid[0],&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;2+3+0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[3],&nbsp;wid[1],&nbsp;wid[2],&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;3+1+2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;10,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;10&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;5,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;5&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[4],&nbsp;wid[4],&nbsp;wid[4],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;4+4+4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;2,&nbsp;0x20,&nbsp;0x4E,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;delay&nbsp;20000us<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[0],&nbsp;wid[0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;46);<br><br>&nbsp;&nbsp;&nbsp;while&nbsp;(gpioWaveTxBusy())&nbsp;time_sleep(0.1);<br><br>&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;WAVES;&nbsp;i++)&nbsp;gpioWaveDelete(wid[i]);<br><br>&nbsp;&nbsp;&nbsp;printf("stop&nbsp;piscope,&nbsp;press&nbsp;return");&nbsp;getchar();<br><br>&nbsp;&nbsp;&nbsp;gpioTerminate();<br>}<br></code><h3><a name="gpioWaveTxAt"></a><a href="#int"><small>int</small></a> gpioWaveTxAt<small>(void)</small></h3>
This function returns the id of the waveform currently being
transmitted.
<br><br>Returns the waveform id or one of the following special values:
<br><br>PI_WAVE_NOT_FOUND (9998) - transmitted wave not found.<br>
PI_NO_TX_WAVE (9999) - no wave being transmitted.
<h3><a name="gpioWaveTxBusy"></a><a href="#int"><small>int</small></a> gpioWaveTxBusy<small>(void)</small></h3>
This function checks to see if a waveform is currently being
transmitted.
<br><br>Returns 1 if a waveform is currently being transmitted, otherwise 0.
<h3><a name="gpioWaveTxStop"></a><a href="#int"><small>int</small></a> gpioWaveTxStop<small>(void)</small></h3>
This function aborts the transmission of the current waveform.
<br><br>Returns 0 if OK.
<br><br>This function is intended to stop a waveform started in repeat mode.
<h3><a name="gpioWaveGetMicros"></a><a href="#int"><small>int</small></a> gpioWaveGetMicros<small>(void)</small></h3>
This function returns the length in microseconds of the current
waveform.
<h3><a name="gpioWaveGetHighMicros"></a><a href="#int"><small>int</small></a> gpioWaveGetHighMicros<small>(void)</small></h3>
This function returns the length in microseconds of the longest waveform
created since <a href="#gpioInitialise">gpioInitialise</a> was called.
<h3><a name="gpioWaveGetMaxMicros"></a><a href="#int"><small>int</small></a> gpioWaveGetMaxMicros<small>(void)</small></h3>
This function returns the maximum possible size of a waveform in
microseconds.
<h3><a name="gpioWaveGetPulses"></a><a href="#int"><small>int</small></a> gpioWaveGetPulses<small>(void)</small></h3>
This function returns the length in pulses of the current waveform.
<h3><a name="gpioWaveGetHighPulses"></a><a href="#int"><small>int</small></a> gpioWaveGetHighPulses<small>(void)</small></h3>
This function returns the length in pulses of the longest waveform
created since <a href="#gpioInitialise">gpioInitialise</a> was called.
<h3><a name="gpioWaveGetMaxPulses"></a><a href="#int"><small>int</small></a> gpioWaveGetMaxPulses<small>(void)</small></h3>
This function returns the maximum possible size of a waveform in pulses.
<h3><a name="gpioWaveGetCbs"></a><a href="#int"><small>int</small></a> gpioWaveGetCbs<small>(void)</small></h3>
This function returns the length in DMA control blocks of the current
waveform.
<h3><a name="gpioWaveGetHighCbs"></a><a href="#int"><small>int</small></a> gpioWaveGetHighCbs<small>(void)</small></h3>
This function returns the length in DMA control blocks of the longest
waveform created since <a href="#gpioInitialise">gpioInitialise</a> was called.
<h3><a name="gpioWaveGetMaxCbs"></a><a href="#int"><small>int</small></a> gpioWaveGetMaxCbs<small>(void)</small></h3>
This function returns the maximum possible size of a waveform in DMA
control blocks.
<h3><a name="gpioSerialReadOpen"></a><a href="#int"><small>int</small></a> gpioSerialReadOpen<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#data_bits">data_bits</a>)</small></h3>
This function opens a GPIO for bit bang reading of serial data.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;50-250000<br>data_bits:&nbsp;1-32<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_WAVE_BAUD,
PI_BAD_DATABITS, or PI_GPIO_IN_USE.
<br><br>The serial data is returned in a cyclic buffer and is read using
<a href="#gpioSerialRead">gpioSerialRead</a>.
<br><br>It is the caller's responsibility to read data from the cyclic buffer
in a timely fashion.
<h3><a name="gpioSerialReadInvert"></a><a href="#int"><small>int</small></a> gpioSerialReadInvert<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#invert">invert</a>)</small></h3>
This function configures the level logic for bit bang serial reads.
<br><br>Use PI_BB_SER_INVERT to invert the serial logic and PI_BB_SER_NORMAL for
normal logic.  Default is PI_BB_SER_NORMAL.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;invert:&nbsp;0-1<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_GPIO_IN_USE,
PI_NOT_SERIAL_GPIO, or PI_BAD_SER_INVERT.
<br><br>The GPIO must be opened for bit bang reading of serial data using
<a href="#gpioSerialReadOpen">gpioSerialReadOpen</a> prior to calling this function.
<h3><a name="gpioSerialRead"></a><a href="#int"><small>int</small></a> gpioSerialRead<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#void">void</a> <a href="#*buf">*buf</a>, <a href="#size_t">size_t</a> <a href="#bufSize">bufSize</a>)</small></h3>
This function copies up to bufSize bytes of data read from the
bit bang serial cyclic buffer to the buffer starting at buf.
<br><br><code>user_gpio:&nbsp;0-31,&nbsp;previously&nbsp;opened&nbsp;with&nbsp;<a href="#gpioSerialReadOpen">gpioSerialReadOpen</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;bytes<br>&nbsp;&nbsp;bufSize:&nbsp;&gt;=0<br></code><br><br>Returns the number of bytes copied if OK, otherwise PI_BAD_USER_GPIO
or PI_NOT_SERIAL_GPIO.
<br><br>The bytes returned for each character depend upon the number of
data bits <a href="#data_bits">data_bits</a> specified in the <a href="#gpioSerialReadOpen">gpioSerialReadOpen</a> command.
<br><br>For <a href="#data_bits">data_bits</a> 1-8 there will be one byte per character.<br>
For <a href="#data_bits">data_bits</a> 9-16 there will be two bytes per character.<br>
For <a href="#data_bits">data_bits</a> 17-32 there will be four bytes per character.
<h3><a name="gpioSerialReadClose"></a><a href="#int"><small>int</small></a> gpioSerialReadClose<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>)</small></h3>
This function closes a GPIO for bit bang reading of serial data.
<br><br><code>user_gpio:&nbsp;0-31,&nbsp;previously&nbsp;opened&nbsp;with&nbsp;<a href="#gpioSerialReadOpen">gpioSerialReadOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SERIAL_GPIO.
<h3><a name="i2cOpen"></a><a href="#int"><small>int</small></a> i2cOpen<small>(<a href="#unsigned">unsigned</a> <a href="#i2cBus">i2cBus</a>, <a href="#unsigned">unsigned</a> <a href="#i2cAddr">i2cAddr</a>, <a href="#unsigned">unsigned</a> <a href="#i2cFlags">i2cFlags</a>)</small></h3>
This returns a handle for the device at the address on the I2C bus.
<br><br><code>&nbsp;&nbsp;i2cBus:&nbsp;&gt;=0<br>&nbsp;i2cAddr:&nbsp;0-0x7F<br>i2cFlags:&nbsp;0<br></code><br><br>No flags are currently defined.  This parameter should be set to zero.
<br><br>Physically buses 0 and 1 are available on the Pi.  Higher numbered buses
will be available if a kernel supported bus multiplexor is being used.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td></tr><tr><td>I2C 0</td><td>0</td><td>1</td></tr><tr><td>I2C 1</td><td>2</td><td>3</td></tr></tbody></table><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_BAD_I2C_BUS, PI_BAD_I2C_ADDR,
PI_BAD_FLAGS, PI_NO_HANDLE, or PI_I2C_OPEN_FAILED.
<br><br>For the SMBus commands the low level transactions are shown at the end
of the function description.  The following abbreviations are used.
<br><br><code>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Start&nbsp;bit<br>P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Stop&nbsp;bit<br>Rd/Wr&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Read/Write&nbsp;bit.&nbsp;Rd&nbsp;equals&nbsp;1,&nbsp;Wr&nbsp;equals&nbsp;0.<br>A,&nbsp;NA&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Accept&nbsp;and&nbsp;not&nbsp;accept&nbsp;bit.<br><br>Addr&nbsp;&nbsp;&nbsp;(7&nbsp;bits):&nbsp;I2C&nbsp;7&nbsp;bit&nbsp;address.<br>i2cReg&nbsp;(8&nbsp;bits):&nbsp;Command&nbsp;byte,&nbsp;a&nbsp;byte&nbsp;which&nbsp;often&nbsp;selects&nbsp;a&nbsp;register.<br>Data&nbsp;&nbsp;&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;data&nbsp;byte.<br>Count&nbsp;&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;byte&nbsp;defining&nbsp;the&nbsp;length&nbsp;of&nbsp;a&nbsp;block&nbsp;operation.<br><br>[..]:&nbsp;Data&nbsp;sent&nbsp;by&nbsp;the&nbsp;device.<br></code><h3><a name="i2cClose"></a><a href="#int"><small>int</small></a> i2cClose<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This closes the I2C device associated with the handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="i2cWriteQuick"></a><a href="#int"><small>int</small></a> i2cWriteQuick<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#bit">bit</a>)</small></h3>
This sends a single bit (in the Rd/Wr bit) to the device associated
with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;&nbsp;&nbsp;bit:&nbsp;0-1,&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Quick command. SMBus 2.0 5.5.1
<code>S&nbsp;Addr&nbsp;bit&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cWriteByte"></a><a href="#int"><small>int</small></a> i2cWriteByte<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#bVal">bVal</a>)</small></h3>
This sends a single byte to the device associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;&nbsp;bVal:&nbsp;0-0xFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Send byte. SMBus 2.0 5.5.2
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;bVal&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cReadByte"></a><a href="#int"><small>int</small></a> i2cReadByte<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This reads a single byte from the device associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br></code><br><br>Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
or PI_I2C_READ_FAILED.
<br><br>Receive byte. SMBus 2.0 5.5.3
<code>S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cWriteByteData"></a><a href="#int"><small>int</small></a> i2cWriteByteData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#unsigned">unsigned</a> <a href="#bVal">bVal</a>)</small></h3>
This writes a single byte to the specified register of the device
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write<br>&nbsp;&nbsp;bVal:&nbsp;0-0xFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Write byte. SMBus 2.0 5.5.4
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;bVal&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cWriteWordData"></a><a href="#int"><small>int</small></a> i2cWriteWordData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#unsigned">unsigned</a> <a href="#wVal">wVal</a>)</small></h3>
This writes a single 16 bit word to the specified register of the device
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write<br>&nbsp;&nbsp;wVal:&nbsp;0-0xFFFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Write word. SMBus 2.0 5.5.4
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;wValLow&nbsp;[A]&nbsp;wValHigh&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cReadByteData"></a><a href="#int"><small>int</small></a> i2cReadByteData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>)</small></h3>
This reads a single byte from the specified register of the device
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read<br></code><br><br>Returns the byte read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Read byte. SMBus 2.0 5.5.5
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cReadWordData"></a><a href="#int"><small>int</small></a> i2cReadWordData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>)</small></h3>
This reads a single 16 bit word from the specified register of the device
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read<br></code><br><br>Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Read word. SMBus 2.0 5.5.5
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[DataLow]&nbsp;A&nbsp;[DataHigh]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cProcessCall"></a><a href="#int"><small>int</small></a> i2cProcessCall<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#unsigned">unsigned</a> <a href="#wVal">wVal</a>)</small></h3>
This writes 16 bits of data to the specified register of the device
associated with handle and reads 16 bits of data in return.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write/read<br>&nbsp;&nbsp;wVal:&nbsp;0-0xFFFF,&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Returns the word read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Process call. SMBus 2.0 5.5.6
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;wValLow&nbsp;[A]&nbsp;wValHigh&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[DataLow]&nbsp;A&nbsp;[DataHigh]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cWriteBlockData"></a><a href="#int"><small>int</small></a> i2cWriteBlockData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes up to 32 bytes to the specified register of the device
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;with&nbsp;the&nbsp;data&nbsp;to&nbsp;send<br>&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br>Block write. SMBus 2.0 5.5.7
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;count&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;buf0&nbsp;[A]&nbsp;buf1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;bufn&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cReadBlockData"></a><a href="#int"><small>int</small></a> i2cReadBlockData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>)</small></h3>
This reads a block of up to 32 bytes from the specified register of
the device associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data<br></code><br><br>The amount of returned data is set by the device.
<br><br>Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>Block read. SMBus 2.0 5.5.7
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Count]&nbsp;A&nbsp;[buf0]&nbsp;A&nbsp;[buf1]&nbsp;A&nbsp;...&nbsp;A&nbsp;[bufn]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cBlockProcessCall"></a><a href="#int"><small>int</small></a> i2cBlockProcessCall<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes data bytes to the specified register of the device
associated with handle and reads a device specified number
of bytes of data in return.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write/read<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;with&nbsp;the&nbsp;data&nbsp;to&nbsp;send&nbsp;and&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data<br>&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br>The SMBus 2.0 documentation states that a minimum of 1 byte may be
sent and a minimum of 1 byte may be received.  The total number of
bytes sent/received must be 32 or less.
<br><br>Block write-block read. SMBus 2.0 5.5.8
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;count&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;...&nbsp;bufn&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Count]&nbsp;A&nbsp;[buf0]&nbsp;A&nbsp;...&nbsp;[bufn]&nbsp;A&nbsp;P<br></code><h3><a name="i2cReadI2CBlockData"></a><a href="#int"><small>int</small></a> i2cReadI2CBlockData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This reads count bytes from the specified register of the device
associated with handle .  The count may be 1-32.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;read<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data<br>&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read<br></code><br><br>Returns the number of bytes read (&gt;0) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_I2C_READ_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[buf0]&nbsp;A&nbsp;[buf1]&nbsp;A&nbsp;...&nbsp;A&nbsp;[bufn]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cWriteI2CBlockData"></a><a href="#int"><small>int</small></a> i2cWriteI2CBlockData<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#i2cReg">i2cReg</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes 1 to 32 bytes to the specified register of the device
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>i2cReg:&nbsp;0-255,&nbsp;the&nbsp;register&nbsp;to&nbsp;write<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;data&nbsp;to&nbsp;write<br>&nbsp;count:&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;i2cReg&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;buf1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;bufn&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cReadDevice"></a><a href="#int"><small>int</small></a> i2cReadDevice<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This reads count bytes from the raw device into buf.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data&nbsp;bytes<br>&nbsp;count:&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read<br></code><br><br>Returns count (&gt;0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_READ_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[buf0]&nbsp;A&nbsp;[buf1]&nbsp;A&nbsp;...&nbsp;A&nbsp;[bufn]&nbsp;NA&nbsp;P<br></code><h3><a name="i2cWriteDevice"></a><a href="#int"><small>int</small></a> i2cWriteDevice<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This writes count bytes from buf to the raw device.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;containing&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;write<br>&nbsp;count:&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_I2C_WRITE_FAILED.
<br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;buf0&nbsp;[A]&nbsp;buf1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;bufn&nbsp;[A]&nbsp;P<br></code><h3><a name="i2cSwitchCombined"></a><a href="#void"><small>void</small></a> i2cSwitchCombined<small>(<a href="#int">int</a> <a href="#setting">setting</a>)</small></h3>
This sets the I2C (i2c-bcm2708) module "use combined transactions"
parameter on or off.
<br><br><code>setting:&nbsp;0&nbsp;to&nbsp;set&nbsp;the&nbsp;parameter&nbsp;off,&nbsp;non-zero&nbsp;to&nbsp;set&nbsp;it&nbsp;on<br></code><br><br>NOTE: when the flag is on a write followed by a read to the same
slave address will use a repeated start (rather than a stop/start).
<h3><a name="i2cSegments"></a><a href="#int"><small>int</small></a> i2cSegments<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#pi_i2c_msg_t">pi_i2c_msg_t</a> <a href="#*segs">*segs</a>, <a href="#unsigned">unsigned</a> <a href="#numSegs">numSegs</a>)</small></h3>
This function executes multiple I2C segments in one transaction by
calling the I2C_RDWR ioctl.
<br><br><code>&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;&nbsp;&nbsp;segs:&nbsp;an&nbsp;array&nbsp;of&nbsp;I2C&nbsp;segments<br>numSegs:&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;I2C&nbsp;segments<br></code><br><br>Returns the number of segments if OK, otherwise PI_BAD_I2C_SEG.
<h3><a name="i2cZip"></a><a href="#int"><small>int</small></a> i2cZip<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*inBuf">*inBuf</a>, <a href="#unsigned">unsigned</a> <a href="#inLen">inLen</a>, <a href="#char">char</a> <a href="#*outBuf">*outBuf</a>, <a href="#unsigned">unsigned</a> <a href="#outLen">outLen</a>)</small></h3>
This function executes a sequence of I2C operations.  The
operations to be performed are specified by the contents of inBuf
which contains the concatenated command codes and associated data.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#i2cOpen">i2cOpen</a><br>&nbsp;inBuf:&nbsp;pointer&nbsp;to&nbsp;the&nbsp;concatenated&nbsp;I2C&nbsp;commands,&nbsp;see&nbsp;below<br>&nbsp;inLen:&nbsp;size&nbsp;of&nbsp;command&nbsp;buffer<br>outBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;returned&nbsp;data<br>outLen:&nbsp;size&nbsp;of&nbsp;output&nbsp;buffer<br></code><br><br>Returns &gt;= 0 if OK (the number of bytes read), otherwise
PI_BAD_HANDLE, PI_BAD_POINTER, PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN.
PI_BAD_I2C_WLEN, or PI_BAD_I2C_SEG.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>On</td><td>2</td><td>Switch combined flag on</td></tr><tr><td>Off</td><td>3</td><td>Switch combined flag off</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address defaults to that associated with the handle.
The flags default to 0.  The address and flags maintain their
previous value until updated.
<br><br>The returned I2C data is stored in consecutive locations of outBuf.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53,&nbsp;write&nbsp;0x32,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x1E,&nbsp;write&nbsp;0x03,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x68,&nbsp;write&nbsp;0x1B,&nbsp;read&nbsp;8&nbsp;bytes<br>End<br><br>0x04&nbsp;0x53&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x1E&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x68&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x06&nbsp;0x08<br>0x00<br></code><h3><a name="bbI2COpen"></a><a href="#int"><small>int</small></a> bbI2COpen<small>(<a href="#unsigned">unsigned</a> <a href="#SDA">SDA</a>, <a href="#unsigned">unsigned</a> <a href="#SCL">SCL</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>)</small></h3>
This function selects a pair of GPIO for bit banging I2C at a
specified baud rate.
<br><br>Bit banging I2C allows for certain operations which are not possible
with the standard I2C driver.
<br><br>o baud rates as low as 50<br>
o repeated starts<br>
o clock stretching<br>
o I2C on any pair of spare GPIO
<br><br><code>&nbsp;SDA:&nbsp;0-31<br>&nbsp;SCL:&nbsp;0-31<br>baud:&nbsp;50-500000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_I2C_BAUD, or
PI_GPIO_IN_USE.
<br><br>NOTE:
<br><br>The GPIO used for SDA and SCL must have pull-ups to 3V3 connected.  As
a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.
<h3><a name="bbI2CClose"></a><a href="#int"><small>int</small></a> bbI2CClose<small>(<a href="#unsigned">unsigned</a> <a href="#SDA">SDA</a>)</small></h3>
This function stops bit banging I2C on a pair of GPIO previously
opened with <a href="#bbI2COpen">bbI2COpen</a>.
<br><br><code>SDA:&nbsp;0-31,&nbsp;the&nbsp;SDA&nbsp;GPIO&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bbI2COpen">bbI2COpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_I2C_GPIO.
<h3><a name="bbI2CZip"></a><a href="#int"><small>int</small></a> bbI2CZip<small>(<a href="#unsigned">unsigned</a> <a href="#SDA">SDA</a>, <a href="#char">char</a> <a href="#*inBuf">*inBuf</a>, <a href="#unsigned">unsigned</a> <a href="#inLen">inLen</a>, <a href="#char">char</a> <a href="#*outBuf">*outBuf</a>, <a href="#unsigned">unsigned</a> <a href="#outLen">outLen</a>)</small></h3>
This function executes a sequence of bit banged I2C operations.  The
operations to be performed are specified by the contents of inBuf
which contains the concatenated command codes and associated data.
<br><br><code>&nbsp;&nbsp;&nbsp;SDA:&nbsp;0-31&nbsp;(as&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bbI2COpen">bbI2COpen</a>)<br>&nbsp;inBuf:&nbsp;pointer&nbsp;to&nbsp;the&nbsp;concatenated&nbsp;I2C&nbsp;commands,&nbsp;see&nbsp;below<br>&nbsp;inLen:&nbsp;size&nbsp;of&nbsp;command&nbsp;buffer<br>outBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;returned&nbsp;data<br>outLen:&nbsp;size&nbsp;of&nbsp;output&nbsp;buffer<br></code><br><br>Returns &gt;= 0 if OK (the number of bytes read), otherwise
PI_BAD_USER_GPIO, PI_NOT_I2C_GPIO, PI_BAD_POINTER,
PI_BAD_I2C_CMD, PI_BAD_I2C_RLEN, PI_BAD_I2C_WLEN,
PI_I2C_READ_FAILED, or PI_I2C_WRITE_FAILED.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>Start</td><td>2</td><td>Start condition</td></tr><tr><td>Stop</td><td>3</td><td>Stop condition</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address and flags default to 0.  The address and flags maintain
their previous value until updated.
<br><br>No flags are currently defined.
<br><br>The returned I2C data is stored in consecutive locations of outBuf.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53<br>start,&nbsp;write&nbsp;0x32,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x1E<br>start,&nbsp;write&nbsp;0x03,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x68<br>start,&nbsp;write&nbsp;0x1B,&nbsp;(re)start,&nbsp;read&nbsp;8&nbsp;bytes,&nbsp;stop<br>End<br><br>0x04&nbsp;0x53<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x1E<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x68<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x08&nbsp;0x03<br><br>0x00<br></code><h3><a name="bscXfer"></a><a href="#int"><small>int</small></a> bscXfer<small>(<a href="#bsc_xfer_t">bsc_xfer_t</a> <a href="#*bsc_xfer">*bsc_xfer</a>)</small></h3>
This function provides a low-level interface to the SPI/I2C Slave
peripheral on the BCM chip.
<br><br>This peripheral allows the Pi to act as a hardware slave device
on an I2C or SPI bus.
<br><br>This is not a bit bang version and as such is OS timing
independent. The bus timing is handled directly by the chip.
<br><br>The output process is simple. You simply append data to the FIFO
buffer on the chip.  This works like a queue, you add data to the
queue and the master removes it.
<br><br>I can't get SPI to work properly.  I tried with a
control word of 0x303 and swapped MISO and MOSI.
<br><br>The function sets the BSC mode, writes any data in
the transmit buffer to the BSC transmit FIFO, and
copies any data in the BSC receive FIFO to the
receive buffer.
<br><br><code>bsc_xfer:=&nbsp;a&nbsp;structure&nbsp;defining&nbsp;the&nbsp;transfer<br><br>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;control;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;int&nbsp;rxCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;char&nbsp;rxBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;int&nbsp;txCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;char&nbsp;txBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Write<br>}&nbsp;bsc_xfer_t;<br></code><br><br>To start a transfer set control (see below), copy the bytes to
be added to the transmit FIFO (if any) to txBuf and set txCnt to
the number of copied bytes.
<br><br>Upon return rxCnt will be set to the number of received bytes placed
in rxBuf.
<br><br>Note that the control word sets the BSC mode.  The BSC will stay in
that mode until a different control word is sent.
<br><br>GPIO used for models other than those based on the BCM2711.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>18</td><td>19</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>18</td><td>19</td><td>20</td><td>21</td></tr></tbody></table><br><br>GPIO used for models based on the BCM2711 (e.g. the Pi4B).
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>10</td><td>11</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>10</td><td>11</td><td>9</td><td>8</td></tr></tbody></table><br><br>When a zero control word is received the used GPIO will be reset
to INPUT mode.
<br><br>The returned function value is the status of the transfer (see below).
<br><br>If there was an error the status will be less than zero
(and will contain the error code).
<br><br>The most significant word of the returned status contains the number
of bytes actually copied from txBuf to the BSC transmit FIFO (may be
less than requested if the FIFO already contained untransmitted data).
<br><br>control consists of the following bits.
<br><br><code>22&nbsp;21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;IT&nbsp;HC&nbsp;TF&nbsp;IR&nbsp;RE&nbsp;TE&nbsp;BK&nbsp;EC&nbsp;ES&nbsp;PL&nbsp;PH&nbsp;I2&nbsp;SP&nbsp;EN<br></code><br><br>Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>aaaaaaa</td><td>defines the I2C slave address (only relevant in I2C mode)</td></tr><tr><td>IT</td><td>invert transmit status flags</td></tr><tr><td>HC</td><td>enable host control</td></tr><tr><td>TF</td><td>enable test FIFO</td></tr><tr><td>IR</td><td>invert receive status flags</td></tr><tr><td>RE</td><td>enable receive</td></tr><tr><td>TE</td><td>enable transmit</td></tr><tr><td>BK</td><td>abort operation and clear FIFOs</td></tr><tr><td>EC</td><td>send control register as first I2C byte</td></tr><tr><td>ES</td><td>send status register as first I2C byte</td></tr><tr><td>PL</td><td>set SPI polarity high</td></tr><tr><td>PH</td><td>set SPI phase high</td></tr><tr><td>I2</td><td>enable I2C mode</td></tr><tr><td>SP</td><td>enable SPI mode</td></tr><tr><td>EN</td><td>enable BSC peripheral</td></tr></tbody></table><br><br>The returned status has the following format
<br><br><code>20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;RB&nbsp;TE&nbsp;RF&nbsp;TF&nbsp;RE&nbsp;TB<br></code><br><br>Bits 0-15 are copied unchanged from the BSC FR register.  See
pages 165-166 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>SSSSS</td><td>number of bytes successfully copied to transmit FIFO</td></tr><tr><td>RRRRR</td><td>number of bytes in receieve FIFO</td></tr><tr><td>TTTTT</td><td>number of bytes in transmit FIFO</td></tr><tr><td>RB</td><td>receive busy</td></tr><tr><td>TE</td><td>transmit FIFO empty</td></tr><tr><td>RF</td><td>receive FIFO full</td></tr><tr><td>TF</td><td>transmit FIFO full</td></tr><tr><td>RE</td><td>receive FIFO empty</td></tr><tr><td>TB</td><td>transmit busy</td></tr></tbody></table><br><br>The following example shows how to configure the BSC peripheral as
an I2C slave with address 0x13 and send four bytes.
<br><br><b><small>Example</small></b><br><br><code>bsc_xfer_t&nbsp;xfer;<br><br>xfer.control&nbsp;=&nbsp;(0x13&lt;&lt;16)&nbsp;|&nbsp;0x305;<br><br>memcpy(xfer.txBuf,&nbsp;"ABCD",&nbsp;4);<br>xfer.txCnt&nbsp;=&nbsp;4;<br><br>status&nbsp;=&nbsp;bscXfer(&xfer);<br><br>if&nbsp;(status&nbsp;&gt;=&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;process&nbsp;transfer<br>}<br></code><h3><a name="bbSPIOpen"></a><a href="#int"><small>int</small></a> bbSPIOpen<small>(<a href="#unsigned">unsigned</a> <a href="#CS">CS</a>, <a href="#unsigned">unsigned</a> <a href="#MISO">MISO</a>, <a href="#unsigned">unsigned</a> <a href="#MOSI">MOSI</a>, <a href="#unsigned">unsigned</a> <a href="#SCLK">SCLK</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#spiFlags">spiFlags</a>)</small></h3>
This function selects a set of GPIO for bit banging SPI with
a specified baud rate and mode.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CS:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;MISO:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;MOSI:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;SCLK:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;50-250000<br>spiFlags:&nbsp;see&nbsp;below<br></code><br><br>spiFlags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;p&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode, defaults to 0
<br><br><code>Mode&nbsp;CPOL&nbsp;CPHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1<br></code><br><br>p is 0 if CS is active low (default) and 1 for active high.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.
<br><br>R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.
<br><br>The other bits in flags should be set to zero.
<br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_SPI_BAUD, or
PI_GPIO_IN_USE.
<br><br>If more than one device is connected to the SPI bus (defined by
SCLK, MOSI, and MISO) each must have its own CS.
<br><br><b><small>Example</small></b><br><br><code>bbSPIOpen(10,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;10000,&nbsp;0);&nbsp;//&nbsp;device&nbsp;1<br>bbSPIOpen(11,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;20000,&nbsp;3);&nbsp;//&nbsp;device&nbsp;2<br></code><h3><a name="bbSPIClose"></a><a href="#int"><small>int</small></a> bbSPIClose<small>(<a href="#unsigned">unsigned</a> <a href="#CS">CS</a>)</small></h3>
This function stops bit banging SPI on a set of GPIO
opened with <a href="#bbSPIOpen">bbSPIOpen</a>.
<br><br><code>CS:&nbsp;0-31,&nbsp;the&nbsp;CS&nbsp;GPIO&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bbSPIOpen">bbSPIOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SPI_GPIO.
<h3><a name="bbSPIXfer"></a><a href="#int"><small>int</small></a> bbSPIXfer<small>(<a href="#unsigned">unsigned</a> <a href="#CS">CS</a>, <a href="#char">char</a> <a href="#*inBuf">*inBuf</a>, <a href="#char">char</a> <a href="#*outBuf">*outBuf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function executes a bit banged SPI transfer.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;CS:&nbsp;0-31&nbsp;(as&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bbSPIOpen">bbSPIOpen</a>)<br>&nbsp;inBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;data&nbsp;to&nbsp;be&nbsp;sent<br>outBuf:&nbsp;pointer&nbsp;to&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;returned&nbsp;data<br>&nbsp;count:&nbsp;size&nbsp;of&nbsp;data&nbsp;transfer<br></code><br><br>Returns &gt;= 0 if OK (the number of bytes read), otherwise
PI_BAD_USER_GPIO, PI_NOT_SPI_GPIO or PI_BAD_POINTER.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;gcc&nbsp;-Wall&nbsp;-pthread&nbsp;-o&nbsp;bbSPIx_test&nbsp;bbSPIx_test.c&nbsp;-lpigpio<br>//&nbsp;sudo&nbsp;./bbSPIx_test<br><br>#include&nbsp;&lt;stdio.h&gt;<br><br>#include&nbsp;"pigpio.h"<br><br>#define&nbsp;CE0&nbsp;5<br>#define&nbsp;CE1&nbsp;6<br>#define&nbsp;MISO&nbsp;13<br>#define&nbsp;MOSI&nbsp;19<br>#define&nbsp;SCLK&nbsp;12<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;count,&nbsp;set_val,&nbsp;read_val;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;inBuf[3];<br>&nbsp;&nbsp;&nbsp;char&nbsp;cmd1[]&nbsp;=&nbsp;{0,&nbsp;0};<br>&nbsp;&nbsp;&nbsp;char&nbsp;cmd2[]&nbsp;=&nbsp;{12,&nbsp;0};<br>&nbsp;&nbsp;&nbsp;char&nbsp;cmd3[]&nbsp;=&nbsp;{1,&nbsp;128,&nbsp;0};<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(gpioInitialise()&nbsp;&lt;&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;"pigpio&nbsp;initialisation&nbsp;failed.\n");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;bbSPIOpen(CE0,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;10000,&nbsp;0);&nbsp;//&nbsp;MCP4251&nbsp;DAC<br>&nbsp;&nbsp;&nbsp;bbSPIOpen(CE1,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;20000,&nbsp;3);&nbsp;//&nbsp;MCP3008&nbsp;ADC<br><br>&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;256;&nbsp;i++)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd1[1]&nbsp;=&nbsp;i;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;bbSPIXfer(CE0,&nbsp;cmd1,&nbsp;(char&nbsp;*)inBuf,&nbsp;2);&nbsp;//&nbsp;&gt;&nbsp;DAC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;bbSPIXfer(CE0,&nbsp;cmd2,&nbsp;(char&nbsp;*)inBuf,&nbsp;2);&nbsp;//&nbsp;&lt;&nbsp;DAC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_val&nbsp;=&nbsp;inBuf[1];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;bbSPIXfer(CE1,&nbsp;cmd3,&nbsp;(char&nbsp;*)inBuf,&nbsp;3);&nbsp;//&nbsp;&lt;&nbsp;ADC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;3)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_val&nbsp;=&nbsp;((inBuf[1]&3)&lt;&lt;8)&nbsp;|&nbsp;inBuf[2];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;%d\n",&nbsp;set_val,&nbsp;read_val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;bbSPIClose(CE0);<br>&nbsp;&nbsp;&nbsp;bbSPIClose(CE1);<br><br>&nbsp;&nbsp;&nbsp;gpioTerminate();<br><br>&nbsp;&nbsp;&nbsp;return&nbsp;0;<br>}<br></code><h3><a name="spiOpen"></a><a href="#int"><small>int</small></a> spiOpen<small>(<a href="#unsigned">unsigned</a> <a href="#spiChan">spiChan</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#spiFlags">spiFlags</a>)</small></h3>
This function returns a handle for the SPI device on the channel.
Data will be transferred at baud bits per second.  The flags may
be used to modify the default behaviour of 4-wire operation, mode 0,
active low chip select.
<br><br>The Pi has two SPI peripherals: main and auxiliary.
<br><br>The main SPI has two chip selects (channels), the auxiliary has
three.
<br><br>The auxiliary SPI is available on all models but the A and B.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>MISO</td><td>MOSI</td><td>SCLK</td><td>CE0</td><td>CE1</td><td>CE2</td></tr><tr><td>Main SPI</td><td>9</td><td>10</td><td>11</td><td>8</td><td>7</td><td>-</td></tr><tr><td>Aux SPI</td><td>19</td><td>20</td><td>21</td><td>18</td><td>17</td><td>16</td></tr></tbody></table><br><br><code>&nbsp;spiChan:&nbsp;0-1&nbsp;(0-2&nbsp;for&nbsp;the&nbsp;auxiliary&nbsp;SPI)<br>&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;32K-125M&nbsp;(values&nbsp;above&nbsp;30M&nbsp;are&nbsp;unlikely&nbsp;to&nbsp;work)<br>spiFlags:&nbsp;see&nbsp;below<br></code><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_BAD_SPI_CHANNEL,
PI_BAD_SPI_SPEED, PI_BAD_FLAGS, PI_NO_AUX_SPI, or PI_SPI_OPEN_FAILED.
<br><br>spiFlags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;W&nbsp;&nbsp;A&nbsp;u2&nbsp;u1&nbsp;u0&nbsp;p2&nbsp;p1&nbsp;p0&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode.
<br><br>Warning: modes 1 and 3 do not appear to work on the auxiliary SPI.
<br><br><code>Mode&nbsp;POL&nbsp;PHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1<br></code><br><br>px is 0 if CEx is active low (default) and 1 for active high.
<br><br>ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.
<br><br>A is 0 for the main SPI, 1 for the auxiliary SPI.
<br><br>W is 0 if the device is not 3-wire, 1 if the device is 3-wire.  Main
SPI only.
<br><br>nnnn defines the number of bytes (0-15) to write before switching
the MOSI line to MISO to read data.  This field is ignored
if W is not set.  Main SPI only.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.  Auxiliary SPI
only.
<br><br>R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.  Auxiliary SPI
only.
<br><br>bbbbbb defines the word size in bits (0-32).  The default (0)
sets 8 bits per word.  Auxiliary SPI only.
<br><br>The <a href="#spiRead">spiRead</a>, <a href="#spiWrite">spiWrite</a>, and <a href="#spiXfer">spiXfer</a> functions
transfer data packed into 1, 2, or 4 bytes according to
the word size in bits.
<br><br>For bits 1-8 there will be one byte per word.<br>
For bits 9-16 there will be two bytes per word.<br>
For bits 17-32 there will be four bytes per word.
<br><br>Multi-byte transfers are made in least significant byte first order.
<br><br>E.g. to transfer 32 11-bit words buf should contain 64 bytes
and count should be 64.
<br><br>E.g. to transfer the 14 bit value 0x1ABC send the bytes 0xBC followed
by 0x1A.
<br><br>The other bits in flags should be set to zero.
<h3><a name="spiClose"></a><a href="#int"><small>int</small></a> spiClose<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This functions closes the SPI device identified by the handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spiOpen">spiOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="spiRead"></a><a href="#int"><small>int</small></a> spiRead<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function reads count bytes of data from the SPI
device associated with the handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spiOpen">spiOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data&nbsp;bytes<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read<br></code><br><br>Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.
<h3><a name="spiWrite"></a><a href="#int"><small>int</small></a> spiWrite<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function writes count bytes of data from buf to the SPI
device associated with the handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spiOpen">spiOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;write<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.
<h3><a name="spiXfer"></a><a href="#int"><small>int</small></a> spiXfer<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*txBuf">*txBuf</a>, <a href="#char">char</a> <a href="#*rxBuf">*rxBuf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function transfers count bytes of data from txBuf to the SPI
device associated with the handle.  Simultaneously count bytes of
data are read from the device and placed in rxBuf.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#spiOpen">spiOpen</a><br>&nbsp;txBuf:&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;write<br>&nbsp;rxBuf:&nbsp;the&nbsp;received&nbsp;data&nbsp;bytes<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;transfer<br></code><br><br>Returns the number of bytes transferred if OK, otherwise
PI_BAD_HANDLE, PI_BAD_SPI_COUNT, or PI_SPI_XFER_FAILED.
<h3><a name="serOpen"></a><a href="#int"><small>int</small></a> serOpen<small>(<a href="#char">char</a> <a href="#*sertty">*sertty</a>, <a href="#unsigned">unsigned</a> <a href="#baud">baud</a>, <a href="#unsigned">unsigned</a> <a href="#serFlags">serFlags</a>)</small></h3>
This function opens a serial device at a specified baud rate
and with specified flags.  The device name must start with
/dev/tty or /dev/serial.
<br><br><code>&nbsp;&nbsp;sertty:&nbsp;the&nbsp;serial&nbsp;device&nbsp;to&nbsp;open<br>&nbsp;&nbsp;&nbsp;&nbsp;baud:&nbsp;the&nbsp;baud&nbsp;rate&nbsp;in&nbsp;bits&nbsp;per&nbsp;second,&nbsp;see&nbsp;below<br>serFlags:&nbsp;0<br></code><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, or
PI_SER_OPEN_FAILED.
<br><br>The baud rate must be one of 50, 75, 110, 134, 150,
200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200,
38400, 57600, 115200, or 230400.
<br><br>No flags are currently defined.  This parameter should be set to zero.
<h3><a name="serClose"></a><a href="#int"><small>int</small></a> serClose<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function closes the serial device associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serOpen">serOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<h3><a name="serWriteByte"></a><a href="#int"><small>int</small></a> serWriteByte<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#unsigned">unsigned</a> <a href="#bVal">bVal</a>)</small></h3>
This function writes bVal to the serial port associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serOpen">serOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_SER_WRITE_FAILED.
<h3><a name="serReadByte"></a><a href="#int"><small>int</small></a> serReadByte<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function reads a byte from the serial port associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serOpen">serOpen</a><br></code><br><br>Returns the read byte (&gt;=0) if OK, otherwise PI_BAD_HANDLE,
PI_SER_READ_NO_DATA, or PI_SER_READ_FAILED.
<br><br>If no data is ready PI_SER_READ_NO_DATA is returned.
<h3><a name="serWrite"></a><a href="#int"><small>int</small></a> serWrite<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function writes count bytes from buf to the the serial port
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serOpen">serOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;array&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, or
PI_SER_WRITE_FAILED.
<h3><a name="serRead"></a><a href="#int"><small>int</small></a> serRead<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function reads up count bytes from the the serial port
associated with handle and writes them to buf.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serOpen">serOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data<br>&nbsp;count:&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read<br></code><br><br>Returns the number of bytes read (&gt;0=) if OK, otherwise PI_BAD_HANDLE,
PI_BAD_PARAM, or PI_SER_READ_NO_DATA.
<br><br>If no data is ready zero is returned.
<h3><a name="serDataAvailable"></a><a href="#int"><small>int</small></a> serDataAvailable<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function returns the number of bytes available
to be read from the device associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#serOpen">serOpen</a><br></code><br><br>Returns the number of bytes of data available (&gt;=0) if OK,
otherwise PI_BAD_HANDLE.
<h3><a name="gpioTrigger"></a><a href="#int"><small>int</small></a> gpioTrigger<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#pulseLen">pulseLen</a>, <a href="#unsigned">unsigned</a> <a href="#level">level</a>)</small></h3>
This function sends a trigger pulse to a GPIO.  The GPIO is set to
level for pulseLen microseconds and then reset to not level.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;pulseLen:&nbsp;1-100<br>&nbsp;&nbsp;&nbsp;&nbsp;level:&nbsp;0,1<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_LEVEL,
or PI_BAD_PULSELEN.
<h3><a name="gpioSetWatchdog"></a><a href="#int"><small>int</small></a> gpioSetWatchdog<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#timeout">timeout</a>)</small></h3>
Sets a watchdog for a GPIO.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;timeout:&nbsp;0-60000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO or PI_BAD_WDOG_TIMEOUT.
<br><br>The watchdog is nominally in milliseconds.
<br><br>One watchdog may be registered per GPIO.
<br><br>The watchdog may be cancelled by setting timeout to 0.
<br><br>Until cancelled a timeout will be reported every timeout milliseconds
after the last GPIO activity.
<br><br>In particular:
<br><br>1) any registered alert function for the GPIO will be called with
   the level set to PI_TIMEOUT.
<br><br>2) any notification for the GPIO will have a report written to the
   fifo with the flags set to indicate a watchdog timeout.
<br><br><b><small>Example</small></b><br><br><code>void&nbsp;aFunction(int&nbsp;gpio,&nbsp;int&nbsp;level,&nbsp;uint32_t&nbsp;tick)<br>{<br>&nbsp;&nbsp;&nbsp;printf("GPIO&nbsp;%d&nbsp;became&nbsp;%d&nbsp;at&nbsp;%d",&nbsp;gpio,&nbsp;level,&nbsp;tick);<br>}<br><br>//&nbsp;call&nbsp;aFunction&nbsp;whenever&nbsp;GPIO&nbsp;4&nbsp;changes&nbsp;state<br>gpioSetAlertFunc(4,&nbsp;aFunction);<br><br>//&nbsp;&nbsp;or&nbsp;approximately&nbsp;every&nbsp;5&nbsp;millis<br>gpioSetWatchdog(4,&nbsp;5);<br></code><h3><a name="gpioNoiseFilter"></a><a href="#int"><small>int</small></a> gpioNoiseFilter<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#steady">steady</a>, <a href="#unsigned">unsigned</a> <a href="#active">active</a>)</small></h3>
Sets a noise filter on a GPIO.
<br><br>Level changes on the GPIO are ignored until a level which has
been stable for <a href="#steady">steady</a> microseconds is detected.  Level changes
on the GPIO are then reported for <a href="#active">active</a> microseconds after
which the process repeats.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;steady:&nbsp;0-300000<br>&nbsp;&nbsp;&nbsp;active:&nbsp;0-1000000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.
<br><br>This filter affects the GPIO samples returned to callbacks set up
with <a href="#gpioSetAlertFunc">gpioSetAlertFunc</a>, <a href="#gpioSetAlertFuncEx">gpioSetAlertFuncEx</a>, <a href="#gpioSetGetSamplesFunc">gpioSetGetSamplesFunc</a>,
and <a href="#gpioSetGetSamplesFuncEx">gpioSetGetSamplesFuncEx</a>.
<br><br>It does not affect interrupts set up with <a href="#gpioSetISRFunc">gpioSetISRFunc</a>,
<a href="#gpioSetISRFuncEx">gpioSetISRFuncEx</a>, or levels read by <a href="#gpioRead">gpioRead</a>,
<a href="#gpioRead_Bits_0_31">gpioRead_Bits_0_31</a>, or <a href="#gpioRead_Bits_32_53">gpioRead_Bits_32_53</a>.
<br><br>Level changes before and after the active period may
be reported.  Your software must be designed to cope with
such reports.
<h3><a name="gpioGlitchFilter"></a><a href="#int"><small>int</small></a> gpioGlitchFilter<small>(<a href="#unsigned">unsigned</a> <a href="#user_gpio">user_gpio</a>, <a href="#unsigned">unsigned</a> <a href="#steady">steady</a>)</small></h3>
Sets a glitch filter on a GPIO.
<br><br>Level changes on the GPIO are not reported unless the level
has been stable for at least <a href="#steady">steady</a> microseconds.  The
level is then reported.  Level changes of less than <a href="#steady">steady</a>
microseconds are ignored.
<br><br><code>user_gpio:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;steady:&nbsp;0-300000<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.
<br><br>This filter affects the GPIO samples returned to callbacks set up
with <a href="#gpioSetAlertFunc">gpioSetAlertFunc</a>, <a href="#gpioSetAlertFuncEx">gpioSetAlertFuncEx</a>, <a href="#gpioSetGetSamplesFunc">gpioSetGetSamplesFunc</a>,
and <a href="#gpioSetGetSamplesFuncEx">gpioSetGetSamplesFuncEx</a>.
<br><br>It does not affect interrupts set up with <a href="#gpioSetISRFunc">gpioSetISRFunc</a>,
<a href="#gpioSetISRFuncEx">gpioSetISRFuncEx</a>, or levels read by <a href="#gpioRead">gpioRead</a>,
<a href="#gpioRead_Bits_0_31">gpioRead_Bits_0_31</a>, or <a href="#gpioRead_Bits_32_53">gpioRead_Bits_32_53</a>.
<br><br>Each (stable) edge will be timestamped <a href="#steady">steady</a> microseconds
after it was first detected.
<h3><a name="gpioSetGetSamplesFunc"></a><a href="#int"><small>int</small></a> gpioSetGetSamplesFunc<small>(<a href="#gpioGetSamplesFunc_t">gpioGetSamplesFunc_t</a> <a href="#f">f</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Registers a function to be called (a callback) every millisecond
with the latest GPIO samples.
<br><br><code>&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;function&nbsp;to&nbsp;call<br>bits:&nbsp;the&nbsp;GPIO&nbsp;of&nbsp;interest<br></code><br><br>Returns 0 if OK.
<br><br>The function is passed a pointer to the samples (an array of
<a href="#gpioSample_t">gpioSample_t</a>),  and the number of samples.
<br><br>Only one function can be registered.
<br><br>The callback may be cancelled by passing NULL as the function.
<br><br>The samples returned will be the union of bits, plus any active alerts,
plus any active notifications.
<br><br>e.g.  if there are alerts for GPIO 7, 8, and 9, notifications for GPIO
8, 10, 23, 24, and bits is (1&lt;&lt;23)|(1&lt;&lt;17) then samples for GPIO
7, 8, 9, 10, 17, 23, and 24 will be reported.
<h3><a name="gpioSetGetSamplesFuncEx"></a><a href="#int"><small>int</small></a> gpioSetGetSamplesFuncEx<small>(<a href="#gpioGetSamplesFuncEx_t">gpioGetSamplesFuncEx_t</a> <a href="#f">f</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Registers a function to be called (a callback) every millisecond
with the latest GPIO samples.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;function&nbsp;to&nbsp;call<br>&nbsp;&nbsp;&nbsp;&nbsp;bits:&nbsp;the&nbsp;GPIO&nbsp;of&nbsp;interest<br>userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns 0 if OK.
<br><br>The function is passed a pointer to the samples (an array of
<a href="#gpioSample_t">gpioSample_t</a>), the number of samples, and the userdata pointer.
<br><br>Only one of <a href="#gpioGetSamplesFunc">gpioGetSamplesFunc</a> or <a href="#gpioGetSamplesFuncEx">gpioGetSamplesFuncEx</a> can be
registered.
<br><br>See <a href="#gpioSetGetSamplesFunc">gpioSetGetSamplesFunc</a> for further details.
<h3><a name="gpioSetTimerFunc"></a><a href="#int"><small>int</small></a> gpioSetTimerFunc<small>(<a href="#unsigned">unsigned</a> <a href="#timer">timer</a>, <a href="#unsigned">unsigned</a> <a href="#millis">millis</a>, <a href="#gpioTimerFunc_t">gpioTimerFunc_t</a> <a href="#f">f</a>)</small></h3>
Registers a function to be called (a callback) every millis milliseconds.
<br><br><code>&nbsp;timer:&nbsp;0-9<br>millis:&nbsp;10-60000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;function&nbsp;to&nbsp;call<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_TIMER, PI_BAD_MS, or PI_TIMER_FAILED.
<br><br>10 timers are supported numbered 0 to 9.
<br><br>One function may be registered per timer.
<br><br>The timer may be cancelled by passing NULL as the function.
<br><br><b><small>Example</small></b><br><br><code>void&nbsp;bFunction(void)<br>{<br>&nbsp;&nbsp;&nbsp;printf("two&nbsp;seconds&nbsp;have&nbsp;elapsed");<br>}<br><br>//&nbsp;call&nbsp;bFunction&nbsp;every&nbsp;2000&nbsp;milliseconds<br>gpioSetTimerFunc(0,&nbsp;2000,&nbsp;bFunction);<br></code><h3><a name="gpioSetTimerFuncEx"></a><a href="#int"><small>int</small></a> gpioSetTimerFuncEx<small>(<a href="#unsigned">unsigned</a> <a href="#timer">timer</a>, <a href="#unsigned">unsigned</a> <a href="#millis">millis</a>, <a href="#gpioTimerFuncEx_t">gpioTimerFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Registers a function to be called (a callback) every millis milliseconds.
<br><br><code>&nbsp;&nbsp;&nbsp;timer:&nbsp;0-9.<br>&nbsp;&nbsp;millis:&nbsp;10-60000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;function&nbsp;to&nbsp;call<br>userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_TIMER, PI_BAD_MS, or PI_TIMER_FAILED.
<br><br>The function is passed the userdata pointer.
<br><br>Only one of <a href="#gpioSetTimerFunc">gpioSetTimerFunc</a> or <a href="#gpioSetTimerFuncEx">gpioSetTimerFuncEx</a> can be
registered per timer.
<br><br>See <a href="#gpioSetTimerFunc">gpioSetTimerFunc</a> for further details.
<h3><a name="gpioStartThread"></a><a href="#pthread_t"><small>pthread_t</small></a> *gpioStartThread<small>(<a href="#gpioThreadFunc_t">gpioThreadFunc_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Starts a new thread of execution with f as the main routine.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;main&nbsp;function&nbsp;for&nbsp;the&nbsp;new&nbsp;thread<br>userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns a pointer to pthread_t if OK, otherwise NULL.
<br><br>The function is passed the single argument arg.
<br><br>The thread can be cancelled by passing the pointer to pthread_t to
<a href="#gpioStopThread">gpioStopThread</a>.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpio.h&gt;<br><br>void&nbsp;*myfunc(void&nbsp;*arg)<br>{<br>&nbsp;&nbsp;&nbsp;while&nbsp;(1)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s",&nbsp;arg);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;pthread_t&nbsp;*p1,&nbsp;*p2,&nbsp;*p3;<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(gpioInitialise()&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;1;<br><br>&nbsp;&nbsp;&nbsp;p1&nbsp;=&nbsp;gpioStartThread(myfunc,&nbsp;"thread&nbsp;1");&nbsp;sleep(3);<br><br>&nbsp;&nbsp;&nbsp;p2&nbsp;=&nbsp;gpioStartThread(myfunc,&nbsp;"thread&nbsp;2");&nbsp;sleep(3);<br><br>&nbsp;&nbsp;&nbsp;p3&nbsp;=&nbsp;gpioStartThread(myfunc,&nbsp;"thread&nbsp;3");&nbsp;sleep(3);<br><br>&nbsp;&nbsp;&nbsp;gpioStopThread(p3);&nbsp;sleep(3);<br><br>&nbsp;&nbsp;&nbsp;gpioStopThread(p2);&nbsp;sleep(3);<br><br>&nbsp;&nbsp;&nbsp;gpioStopThread(p1);&nbsp;sleep(3);<br><br>&nbsp;&nbsp;&nbsp;gpioTerminate();<br>}<br></code><h3><a name="gpioStopThread"></a><a href="#void"><small>void</small></a> gpioStopThread<small>(<a href="#pthread_t">pthread_t</a> <a href="#*pth">*pth</a>)</small></h3>
Cancels the thread pointed at by pth.
<br><br><code>pth:&nbsp;a&nbsp;thread&nbsp;pointer&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStartThread">gpioStartThread</a><br></code><br><br>No value is returned.
<br><br>The thread to be stopped should have been started with <a href="#gpioStartThread">gpioStartThread</a>.
<h3><a name="gpioStoreScript"></a><a href="#int"><small>int</small></a> gpioStoreScript<small>(<a href="#char">char</a> <a href="#*script">*script</a>)</small></h3>
This function stores a null terminated script for later execution.
<br><br>See <a href="http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts">http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts</a> for details.
<br><br><code>script:&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;script<br></code><br><br>The function returns a script id if the script is valid,
otherwise PI_BAD_SCRIPT.
<h3><a name="gpioRunScript"></a><a href="#int"><small>int</small></a> gpioRunScript<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#unsigned">unsigned</a> <a href="#numPar">numPar</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function runs a stored script.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br>&nbsp;&nbsp;&nbsp;numPar:&nbsp;0-10,&nbsp;the&nbsp;number&nbsp;of&nbsp;parameters<br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;of&nbsp;parameters<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.
<br><br>param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.
<h3><a name="gpioRunScript"></a><a href="#int"><small>int</small></a> gpioRunScript<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#unsigned">unsigned</a> <a href="#numPar">numPar</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function runs a stored script.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br>&nbsp;&nbsp;&nbsp;numPar:&nbsp;0-10,&nbsp;the&nbsp;number&nbsp;of&nbsp;parameters<br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;of&nbsp;parameters<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.
<br><br>param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.
<h3><a name="gpioUpdateScript"></a><a href="#int"><small>int</small></a> gpioUpdateScript<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#unsigned">unsigned</a> <a href="#numPar">numPar</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function sets the parameters of a script.  The script may or
may not be running.  The first numPar parameters of the script are
overwritten with the new values.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br>&nbsp;&nbsp;&nbsp;numPar:&nbsp;0-10,&nbsp;the&nbsp;number&nbsp;of&nbsp;parameters<br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;of&nbsp;parameters<br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID, or
PI_TOO_MANY_PARAM.
<br><br>param is an array of up to 10 parameters which may be referenced in
the script as p0 to p9.
<h3><a name="gpioScriptStatus"></a><a href="#int"><small>int</small></a> gpioScriptStatus<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>, <a href="#uint32_t">uint32_t</a> <a href="#*param">*param</a>)</small></h3>
This function returns the run status of a stored script as well as
the current values of parameters 0 to 9.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br>&nbsp;&nbsp;&nbsp;&nbsp;param:&nbsp;an&nbsp;array&nbsp;to&nbsp;hold&nbsp;the&nbsp;returned&nbsp;10&nbsp;parameters<br></code><br><br>The function returns greater than or equal to 0 if OK,
otherwise PI_BAD_SCRIPT_ID.
<br><br>The run status may be
<br><br><code>PI_SCRIPT_INITING<br>PI_SCRIPT_HALTED<br>PI_SCRIPT_RUNNING<br>PI_SCRIPT_WAITING<br>PI_SCRIPT_FAILED<br></code><br><br>The current value of script parameters 0 to 9 are returned in param.
<h3><a name="gpioStopScript"></a><a href="#int"><small>int</small></a> gpioStopScript<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>)</small></h3>
This function stops a running script.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.
<h3><a name="gpioDeleteScript"></a><a href="#int"><small>int</small></a> gpioDeleteScript<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>)</small></h3>
This function deletes a stored script.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br></code><br><br>The function returns 0 if OK, otherwise PI_BAD_SCRIPT_ID.
<h3><a name="gpioSetSignalFunc"></a><a href="#int"><small>int</small></a> gpioSetSignalFunc<small>(<a href="#unsigned">unsigned</a> <a href="#signum">signum</a>, <a href="#gpioSignalFunc_t">gpioSignalFunc_t</a> <a href="#f">f</a>)</small></h3>
Registers a function to be called (a callback) when a signal occurs.
<br><br><code>signum:&nbsp;0-63<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_SIGNUM.
<br><br>The function is passed the signal number.
<br><br>One function may be registered per signal.
<br><br>The callback may be cancelled by passing NULL.
<br><br>By default all signals are treated as fatal and cause the library
to call gpioTerminate and then exit.
<h3><a name="gpioSetSignalFuncEx"></a><a href="#int"><small>int</small></a> gpioSetSignalFuncEx<small>(<a href="#unsigned">unsigned</a> <a href="#signum">signum</a>, <a href="#gpioSignalFuncEx_t">gpioSignalFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Registers a function to be called (a callback) when a signal occurs.
<br><br><code>&nbsp;&nbsp;signum:&nbsp;0-63<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br>userdata:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_SIGNUM.
<br><br>The function is passed the signal number and the userdata pointer.
<br><br>Only one of gpioSetSignalFunc or gpioSetSignalFuncEx can be
registered per signal.
<br><br>See gpioSetSignalFunc for further details.
<h3><a name="gpioRead_Bits_0_31"></a><a href="#uint32_t"><small>uint32_t</small></a> gpioRead_Bits_0_31<small>(void)</small></h3>
Returns the current level of GPIO 0-31.
<h3><a name="gpioRead_Bits_32_53"></a><a href="#uint32_t"><small>uint32_t</small></a> gpioRead_Bits_32_53<small>(void)</small></h3>
Returns the current level of GPIO 32-53.
<h3><a name="gpioWrite_Bits_0_31_Clear"></a><a href="#int"><small>int</small></a> gpioWrite_Bits_0_31_Clear<small>(<a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Clears GPIO 0-31 if the corresponding bit in bits is set.
<br><br><code>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;of&nbsp;GPIO&nbsp;to&nbsp;clear<br></code><br><br>Returns 0 if OK.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;To&nbsp;clear&nbsp;(set&nbsp;to&nbsp;0)&nbsp;GPIO&nbsp;4,&nbsp;7,&nbsp;and&nbsp;15<br>gpioWrite_Bits_0_31_Clear(&nbsp;(1&lt;&lt;4)&nbsp;|&nbsp;(1&lt;&lt;7)&nbsp;|&nbsp;(1&lt;&lt;15)&nbsp;);<br></code><h3><a name="gpioWrite_Bits_32_53_Clear"></a><a href="#int"><small>int</small></a> gpioWrite_Bits_32_53_Clear<small>(<a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.
<br><br><code>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;of&nbsp;GPIO&nbsp;to&nbsp;clear<br></code><br><br>Returns 0 if OK.
<h3><a name="gpioWrite_Bits_0_31_Set"></a><a href="#int"><small>int</small></a> gpioWrite_Bits_0_31_Set<small>(<a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Sets GPIO 0-31 if the corresponding bit in bits is set.
<br><br><code>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;of&nbsp;GPIO&nbsp;to&nbsp;set<br></code><br><br>Returns 0 if OK.
<h3><a name="gpioWrite_Bits_32_53_Set"></a><a href="#int"><small>int</small></a> gpioWrite_Bits_32_53_Set<small>(<a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.
<br><br><code>bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;of&nbsp;GPIO&nbsp;to&nbsp;set<br></code><br><br>Returns 0 if OK.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;To&nbsp;set&nbsp;(set&nbsp;to&nbsp;1)&nbsp;GPIO&nbsp;32,&nbsp;40,&nbsp;and&nbsp;53<br>gpioWrite_Bits_32_53_Set((1&lt;&lt;(32-32))&nbsp;|&nbsp;(1&lt;&lt;(40-32))&nbsp;|&nbsp;(1&lt;&lt;(53-32)));<br></code><h3><a name="gpioHardwareClock"></a><a href="#int"><small>int</small></a> gpioHardwareClock<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#clkfreq">clkfreq</a>)</small></h3>
Starts a hardware clock on a GPIO at the specified frequency.
Frequencies above 30MHz are unlikely to work.
<br><br><code>&nbsp;&nbsp;&nbsp;gpio:&nbsp;see&nbsp;description<br>clkfreq:&nbsp;0&nbsp;(off)&nbsp;or&nbsp;4689-250M&nbsp;(13184-375M&nbsp;for&nbsp;the&nbsp;BCM2711)<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_NOT_HCLK_GPIO,
PI_BAD_HCLK_FREQ,or PI_BAD_HCLK_PASS.
<br><br>The same clock is available on multiple GPIO.  The latest
frequency setting will be used by all GPIO which share a clock.
<br><br>The GPIO must be one of the following.
<br><br><code>4&nbsp;&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;All&nbsp;models<br>5&nbsp;&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br>6&nbsp;&nbsp;&nbsp;clock&nbsp;2&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>20&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>21&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;Rev.2&nbsp;B&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br><br>32&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>34&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>42&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br>43&nbsp;&nbsp;clock&nbsp;2&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>44&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br></code><br><br>Access to clock 1 is protected by a password as its use will likely
crash the Pi.  The password is given by or'ing 0x5A000000 with the
GPIO number.
<h3><a name="gpioHardwarePWM"></a><a href="#int"><small>int</small></a> gpioHardwarePWM<small>(<a href="#unsigned">unsigned</a> <a href="#gpio">gpio</a>, <a href="#unsigned">unsigned</a> <a href="#PWMfreq">PWMfreq</a>, <a href="#unsigned">unsigned</a> <a href="#PWMduty">PWMduty</a>)</small></h3>
Starts hardware PWM on a GPIO at the specified frequency and dutycycle.
Frequencies above 30MHz are unlikely to work.
<br><br>NOTE: Any waveform started by <a href="#gpioWaveTxSend">gpioWaveTxSend</a>, or
<a href="#gpioWaveChain">gpioWaveChain</a> will be cancelled.
<br><br>This function is only valid if the pigpio main clock is PCM.  The
main clock defaults to PCM but may be overridden by a call to
<a href="#gpioCfgClock">gpioCfgClock</a>.
<br><br><code>&nbsp;&nbsp;&nbsp;gpio:&nbsp;see&nbsp;description<br>PWMfreq:&nbsp;0&nbsp;(off)&nbsp;or&nbsp;1-125M&nbsp;(1-187.5M&nbsp;for&nbsp;the&nbsp;BCM2711)<br>PWMduty:&nbsp;0&nbsp;(off)&nbsp;to&nbsp;1000000&nbsp;(1M)(fully&nbsp;on)<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_GPIO, PI_NOT_HPWM_GPIO,
PI_BAD_HPWM_DUTY, PI_BAD_HPWM_FREQ, or PI_HPWM_ILLEGAL.
<br><br>The same PWM channel is available on multiple GPIO.  The latest
frequency and dutycycle setting will be used by all GPIO which
share a PWM channel.
<br><br>The GPIO must be one of the following.
<br><br><code>12&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>13&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>18&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;All&nbsp;models<br>19&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br><br>40&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>41&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>45&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>52&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>53&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br></code><br><br>The actual number of steps beween off and fully on is the
integral part of 250M/PWMfreq (375M/PWMfreq for the BCM2711).
<br><br>The actual frequency set is 250M/steps (375M/steps for the BCM2711).
<br><br>There will only be a million steps for a PWMfreq of 250 (375 for
the BCM2711). Lower frequencies will have more steps and higher
frequencies will have fewer steps.  PWMduty is
automatically scaled to take this into account.
<h3><a name="gpioTime"></a><a href="#int"><small>int</small></a> gpioTime<small>(<a href="#unsigned">unsigned</a> <a href="#timetype">timetype</a>, <a href="#int">int</a> <a href="#*seconds">*seconds</a>, <a href="#int">int</a> <a href="#*micros">*micros</a>)</small></h3>
Updates the seconds and micros variables with the current time.
<br><br><code>timetype:&nbsp;0&nbsp;(relative),&nbsp;1&nbsp;(absolute)<br>&nbsp;seconds:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;an&nbsp;int&nbsp;to&nbsp;hold&nbsp;seconds<br>&nbsp;&nbsp;micros:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;an&nbsp;int&nbsp;to&nbsp;hold&nbsp;microseconds<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_TIMETYPE.
<br><br>If timetype is PI_TIME_ABSOLUTE updates seconds and micros with the
number of seconds and microseconds since the epoch (1st January 1970).
<br><br>If timetype is PI_TIME_RELATIVE updates seconds and micros with the
number of seconds and microseconds since the library was initialised.
<br><br><b><small>Example</small></b><br><br><code>int&nbsp;secs,&nbsp;mics;<br><br>//&nbsp;print&nbsp;the&nbsp;number&nbsp;of&nbsp;seconds&nbsp;since&nbsp;the&nbsp;library&nbsp;was&nbsp;started<br>gpioTime(PI_TIME_RELATIVE,&nbsp;&secs,&nbsp;&mics);<br>printf("library&nbsp;started&nbsp;%d.%03d&nbsp;seconds&nbsp;ago",&nbsp;secs,&nbsp;mics/1000);<br></code><h3><a name="gpioSleep"></a><a href="#int"><small>int</small></a> gpioSleep<small>(<a href="#unsigned">unsigned</a> <a href="#timetype">timetype</a>, <a href="#int">int</a> <a href="#seconds">seconds</a>, <a href="#int">int</a> <a href="#micros">micros</a>)</small></h3>
Sleeps for the number of seconds and microseconds specified by seconds
and micros.
<br><br><code>timetype:&nbsp;0&nbsp;(relative),&nbsp;1&nbsp;(absolute)<br>&nbsp;seconds:&nbsp;seconds&nbsp;to&nbsp;sleep<br>&nbsp;&nbsp;micros:&nbsp;microseconds&nbsp;to&nbsp;sleep<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_TIMETYPE, PI_BAD_SECONDS,
or PI_BAD_MICROS.
<br><br>If timetype is PI_TIME_ABSOLUTE the sleep ends when the number of seconds
and microseconds since the epoch (1st January 1970) has elapsed.  System
clock changes are taken into account.
<br><br>If timetype is PI_TIME_RELATIVE the sleep is for the specified number
of seconds and microseconds.  System clock changes do not effect the
sleep length.
<br><br>For short delays (say, 50 microseonds or less) use <a href="#gpioDelay">gpioDelay</a>.
<br><br><b><small>Example</small></b><br><br><code>gpioSleep(PI_TIME_RELATIVE,&nbsp;2,&nbsp;500000);&nbsp;//&nbsp;sleep&nbsp;for&nbsp;2.5&nbsp;seconds<br><br>gpioSleep(PI_TIME_RELATIVE,&nbsp;0,&nbsp;100000);&nbsp;//&nbsp;sleep&nbsp;for&nbsp;0.1&nbsp;seconds<br><br>gpioSleep(PI_TIME_RELATIVE,&nbsp;60,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;sleep&nbsp;for&nbsp;one&nbsp;minute<br></code><h3><a name="gpioDelay"></a><a href="#uint32_t"><small>uint32_t</small></a> gpioDelay<small>(<a href="#uint32_t">uint32_t</a> <a href="#micros">micros</a>)</small></h3>
Delays for at least the number of microseconds specified by micros.
<br><br><code>micros:&nbsp;the&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;to&nbsp;sleep<br></code><br><br>Returns the actual length of the delay in microseconds.
<br><br>Delays of 100 microseconds or less use busy waits.
<h3><a name="gpioTick"></a><a href="#uint32_t"><small>uint32_t</small></a> gpioTick<small>(void)</small></h3>
Returns the current system tick.
<br><br>Tick is the number of microseconds since system boot.
<br><br>As tick is an unsigned 32 bit quantity it wraps around after
2^32 microseconds, which is approximately 1 hour 12 minutes.
<br><br>You don't need to worry about the wrap around as long as you
take a tick (uint32_t) from another tick, i.e. the following
code will always provide the correct difference.
<br><br><b><small>Example</small></b><br><br><code>uint32_t&nbsp;startTick,&nbsp;endTick;<br>int&nbsp;diffTick;<br><br>startTick&nbsp;=&nbsp;gpioTick();<br><br>//&nbsp;do&nbsp;some&nbsp;processing<br><br>endTick&nbsp;=&nbsp;gpioTick();<br><br>diffTick&nbsp;=&nbsp;endTick&nbsp;-&nbsp;startTick;<br><br>printf("some&nbsp;processing&nbsp;took&nbsp;%d&nbsp;microseconds",&nbsp;diffTick);<br></code><h3><a name="gpioHardwareRevision"></a><a href="#unsigned"><small>unsigned</small></a> gpioHardwareRevision<small>(void)</small></h3>
Returns the hardware revision.
<br><br>If the hardware revision can not be found or is not a valid hexadecimal
number the function returns 0.
<br><br>The hardware revision is the last few characters on the Revision line of
/proc/cpuinfo.
<br><br>The revision number can be used to determine the assignment of GPIO
to pins (see <a href="#gpio">gpio</a>).
<br><br>There are at least three types of board.
<br><br>Type 1 boards have hardware revision numbers of 2 and 3.
<br><br>Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.
<br><br>Type 3 boards have hardware revision numbers of 16 or greater.
<br><br>for "Revision       : 0002" the function returns 2.<br>
for "Revision       : 000f" the function returns 15.<br>
for "Revision       : 000g" the function returns 0.
<h3><a name="gpioVersion"></a><a href="#unsigned"><small>unsigned</small></a> gpioVersion<small>(void)</small></h3>
Returns the pigpio version.
<h3><a name="gpioGetPad"></a><a href="#int"><small>int</small></a> gpioGetPad<small>(<a href="#unsigned">unsigned</a> <a href="#pad">pad</a>)</small></h3>
This function returns the pad drive strength in mA.
<br><br><code>pad:&nbsp;0-2,&nbsp;the&nbsp;pad&nbsp;to&nbsp;get<br></code><br><br>Returns the pad drive strength if OK, otherwise PI_BAD_PAD.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>strength&nbsp;=&nbsp;gpioGetPad(1);&nbsp;//&nbsp;get&nbsp;pad&nbsp;1&nbsp;strength<br></code><h3><a name="gpioSetPad"></a><a href="#int"><small>int</small></a> gpioSetPad<small>(<a href="#unsigned">unsigned</a> <a href="#pad">pad</a>, <a href="#unsigned">unsigned</a> <a href="#padStrength">padStrength</a>)</small></h3>
This function sets the pad drive strength in mA.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pad:&nbsp;0-2,&nbsp;the&nbsp;pad&nbsp;to&nbsp;set<br>padStrength:&nbsp;1-16&nbsp;mA<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_PAD, or PI_BAD_STRENGTH.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>gpioSetPad(0,&nbsp;16);&nbsp;//&nbsp;set&nbsp;pad&nbsp;0&nbsp;strength&nbsp;to&nbsp;16&nbsp;mA<br></code><h3><a name="eventMonitor"></a><a href="#int"><small>int</small></a> eventMonitor<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#uint32_t">uint32_t</a> <a href="#bits">bits</a>)</small></h3>
This function selects the events to be reported on a previously
opened handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;<a href="#gpioNotifyOpen">gpioNotifyOpen</a><br>&nbsp;&nbsp;bits:&nbsp;a&nbsp;bit&nbsp;mask&nbsp;indicating&nbsp;the&nbsp;events&nbsp;of&nbsp;interest<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br>A report is sent each time an event is triggered providing the
corresponding bit in bits is set.
<br><br>See <a href="#gpioNotifyBegin">gpioNotifyBegin</a> for the notification format.
<br><br><b><small>Example</small></b><br><br><code>//&nbsp;Start&nbsp;reporting&nbsp;events&nbsp;3,&nbsp;6,&nbsp;and&nbsp;7.<br><br>//&nbsp;&nbsp;bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76543210<br>//&nbsp;(0xC8&nbsp;=&nbsp;0b11001000)<br><br>eventMonitor(h,&nbsp;0xC8);<br></code><h3><a name="eventSetFunc"></a><a href="#int"><small>int</small></a> eventSetFunc<small>(<a href="#unsigned">unsigned</a> <a href="#event">event</a>, <a href="#eventFunc_t">eventFunc_t</a> <a href="#f">f</a>)</small></h3>
Registers a function to be called (a callback) when the specified
event occurs.
<br><br><code>event:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_EVENT_ID.
<br><br>One function may be registered per event.
<br><br>The function is passed the event, and the tick.
<br><br>The callback may be cancelled by passing NULL as the function.
<h3><a name="eventSetFuncEx"></a><a href="#int"><small>int</small></a> eventSetFuncEx<small>(<a href="#unsigned">unsigned</a> <a href="#event">event</a>, <a href="#eventFuncEx_t">eventFuncEx_t</a> <a href="#f">f</a>, <a href="#void">void</a> <a href="#*userdata">*userdata</a>)</small></h3>
Registers a function to be called (a callback) when the specified
event occurs.
<br><br><code>&nbsp;&nbsp;&nbsp;event:&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f:&nbsp;the&nbsp;callback&nbsp;function<br>userdata:&nbsp;pointer&nbsp;to&nbsp;arbitrary&nbsp;user&nbsp;data<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_EVENT_ID.
<br><br>One function may be registered per event.
<br><br>The function is passed the event, the tick, and the ueserdata pointer.
<br><br>The callback may be cancelled by passing NULL as the function.
<br><br>Only one of <a href="#eventSetFunc">eventSetFunc</a> or <a href="#eventSetFuncEx">eventSetFuncEx</a> can be
registered per event.
<h3><a name="eventTrigger"></a><a href="#int"><small>int</small></a> eventTrigger<small>(<a href="#unsigned">unsigned</a> <a href="#event">event</a>)</small></h3>
This function signals the occurrence of an event.
<br><br><code>event:&nbsp;0-31,&nbsp;the&nbsp;event<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_EVENT_ID.
<br><br>An event is a signal used to inform one or more consumers
to start an action.  Each consumer which has registered an interest
in the event (e.g. by calling <a href="#eventSetFunc">eventSetFunc</a>) will be informed by
a callback.
<br><br>One event, PI_EVENT_BSC (31) is predefined.  This event is
auto generated on BSC slave activity.
<br><br>The meaning of other events is arbitrary.
<br><br>Note that other than its id and its tick there is no data associated
with an event.
<h3><a name="shell"></a><a href="#int"><small>int</small></a> shell<small>(<a href="#char">char</a> <a href="#*scriptName">*scriptName</a>, <a href="#char">char</a> <a href="#*scriptString">*scriptString</a>)</small></h3>
This function uses the system call to execute a shell script
with the given string as its parameter.
<br><br><code>&nbsp;&nbsp;scriptName:&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;script,&nbsp;only&nbsp;alphanumeric&nbsp;characters,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-'&nbsp;and&nbsp;'_'&nbsp;are&nbsp;allowed&nbsp;in&nbsp;the&nbsp;name<br>scriptString:&nbsp;the&nbsp;string&nbsp;to&nbsp;pass&nbsp;to&nbsp;the&nbsp;script<br></code><br><br>The exit status of the system call is returned if OK, otherwise
PI_BAD_SHELL_STATUS.
<br><br>scriptName must exist in /opt/pigpio/cgi and must be executable.
<br><br>The returned exit status is normally 256 times that set by the
shell script exit function.  If the script can't be found 32512 will
be returned.
<br><br>The following table gives some example returned statuses.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Script exit status</td><td>Returned system call status</td></tr><tr><td>1</td><td>256</td></tr><tr><td>5</td><td>1280</td></tr><tr><td>10</td><td>2560</td></tr><tr><td>200</td><td>51200</td></tr><tr><td>script not found</td><td>32512</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>//&nbsp;pass&nbsp;two&nbsp;parameters,&nbsp;hello&nbsp;and&nbsp;world<br>status&nbsp;=&nbsp;shell("scr1",&nbsp;"hello&nbsp;world");<br><br>//&nbsp;pass&nbsp;three&nbsp;parameters,&nbsp;hello,&nbsp;string&nbsp;with&nbsp;spaces,&nbsp;and&nbsp;world<br>status&nbsp;=&nbsp;shell("scr1",&nbsp;"hello&nbsp;'string&nbsp;with&nbsp;spaces'&nbsp;world");<br><br>//&nbsp;pass&nbsp;one&nbsp;parameter,&nbsp;hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world<br>status&nbsp;=&nbsp;shell("scr1",&nbsp;"\"hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world\"");<br></code><h3><a name="fileOpen"></a><a href="#int"><small>int</small></a> fileOpen<small>(<a href="#char">char</a> <a href="#*file">*file</a>, <a href="#unsigned">unsigned</a> <a href="#mode">mode</a>)</small></h3>
This function returns a handle to a file opened in a specified mode.
<br><br><code>file:&nbsp;the&nbsp;file&nbsp;to&nbsp;open<br>mode:&nbsp;the&nbsp;file&nbsp;open&nbsp;mode<br></code><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE, PI_NO_FILE_ACCESS,
PI_BAD_FILE_MODE, PI_FILE_OPEN_FAILED, or PI_FILE_IS_A_DIR.
<br><br>File
<br><br>A file may only be opened if permission is granted by an entry in
/opt/pigpio/access.  This is intended to allow remote access to files
in a more or less controlled manner.
<br><br>Each entry in /opt/pigpio/access takes the form of a file path
which may contain wildcards followed by a single letter permission.
The permission may be R for read, W for write, U for read/write,
and N for no access.
<br><br>Where more than one entry matches a file the most specific rule
applies.  If no entry matches a file then access is denied.
<br><br>Suppose /opt/pigpio/access contains the following entries
<br><br><code>/home/*&nbsp;n<br>/home/pi/shared/dir_1/*&nbsp;w<br>/home/pi/shared/dir_2/*&nbsp;r<br>/home/pi/shared/dir_3/*&nbsp;u<br>/home/pi/shared/dir_1/file.txt&nbsp;n<br></code><br><br>Files may be written in directory dir_1 with the exception
of file.txt.
<br><br>Files may be read in directory dir_2.
<br><br>Files may be read and written in directory dir_3.
<br><br>If a directory allows read, write, or read/write access then files may
be created in that directory.
<br><br>In an attempt to prevent risky permissions the following paths are
ignored in /opt/pigpio/access.
<br><br><code>a&nbsp;path&nbsp;containing&nbsp;..<br>a&nbsp;path&nbsp;containing&nbsp;only&nbsp;wildcards&nbsp;(*?)<br>a&nbsp;path&nbsp;containing&nbsp;less&nbsp;than&nbsp;two&nbsp;non-wildcard&nbsp;parts<br></code><br><br>Mode
<br><br>The mode may have the following values.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Macro</td><td>Value</td><td>Meaning</td></tr><tr><td>PI_FILE_READ</td><td>1</td><td>open file for reading</td></tr><tr><td>PI_FILE_WRITE</td><td>2</td><td>open file for writing</td></tr><tr><td>PI_FILE_RW</td><td>3</td><td>open file for reading and writing</td></tr></tbody></table><br><br>The following values may be or'd into the mode.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Macro</td><td>Value</td><td>Meaning</td></tr><tr><td>PI_FILE_APPEND</td><td>4</td><td>Writes append data to the end of the file</td></tr><tr><td>PI_FILE_CREATE</td><td>8</td><td>The file is created if it doesn't exist</td></tr><tr><td>PI_FILE_TRUNC</td><td>16</td><td>The file is truncated</td></tr></tbody></table><br><br>Newly created files are owned by root with permissions owner read and write.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpio.h&gt;<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;handle,&nbsp;c;<br>&nbsp;&nbsp;&nbsp;char&nbsp;buf[60000];<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(gpioInitialise()&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;1;<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line<br>&nbsp;&nbsp;&nbsp;//&nbsp;/ram/*.c&nbsp;r<br><br>&nbsp;&nbsp;&nbsp;handle&nbsp;=&nbsp;fileOpen("/ram/pigpio.c",&nbsp;PI_FILE_READ);<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(handle&nbsp;&gt;=&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((c=fileRead(handle,&nbsp;buf,&nbsp;sizeof(buf)-1)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[c]&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s",&nbsp;buf);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileClose(handle);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;gpioTerminate();<br>}<br></code><h3><a name="fileClose"></a><a href="#int"><small>int</small></a> fileClose<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>)</small></h3>
This function closes the file associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#fileOpen">fileOpen</a><br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE.
<br><br><b><small>Example</small></b><br><br><code>fileClose(h);<br></code><h3><a name="fileWrite"></a><a href="#int"><small>int</small></a> fileWrite<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function writes count bytes from buf to the the file
associated with handle.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#fileOpen">fileOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;array&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br>&nbsp;count:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;write<br></code><br><br>Returns 0 if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM,
PI_FILE_NOT_WOPEN, or PI_BAD_FILE_WRITE.
<br><br><b><small>Example</small></b><br><br><code>status&nbsp;=&nbsp;fileWrite(h,&nbsp;buf,&nbsp;count);<br>if&nbsp;(status&nbsp;==&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;okay<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;error<br>}<br></code><h3><a name="fileRead"></a><a href="#int"><small>int</small></a> fileRead<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function reads up to count bytes from the the file
associated with handle and writes them to buf.
<br><br><code>handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#fileOpen">fileOpen</a><br>&nbsp;&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;read&nbsp;data<br>&nbsp;count:&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read<br></code><br><br>Returns the number of bytes read (&gt;=0) if OK, otherwise PI_BAD_HANDLE, PI_BAD_PARAM, PI_FILE_NOT_ROPEN, or PI_BAD_FILE_WRITE.
<br><br><b><small>Example</small></b><br><br><code>if&nbsp;(fileRead(h,&nbsp;buf,&nbsp;sizeof(buf))&nbsp;&gt;&nbsp;0)<br>{<br>&nbsp;&nbsp;&nbsp;//&nbsp;process&nbsp;read&nbsp;data<br>}<br></code><h3><a name="fileSeek"></a><a href="#int"><small>int</small></a> fileSeek<small>(<a href="#unsigned">unsigned</a> <a href="#handle">handle</a>, <a href="#int32_t">int32_t</a> <a href="#seekOffset">seekOffset</a>, <a href="#int">int</a> <a href="#seekFrom">seekFrom</a>)</small></h3>
This function seeks to a position within the file associated
with handle.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;handle:&nbsp;&gt;=0,&nbsp;as&nbsp;returned&nbsp;by&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#fileOpen">fileOpen</a><br>seekOffset:&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;move.&nbsp;&nbsp;Positive&nbsp;offsets<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;forward,&nbsp;negative&nbsp;offsets&nbsp;backwards.<br>&nbsp;&nbsp;seekFrom:&nbsp;one&nbsp;of&nbsp;PI_FROM_START&nbsp;(0),&nbsp;PI_FROM_CURRENT&nbsp;(1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;PI_FROM_END&nbsp;(2)<br></code><br><br>Returns the new byte position within the file (&gt;=0) if OK, otherwise PI_BAD_HANDLE, or PI_BAD_FILE_SEEK.
<br><br><b><small>Example</small></b><br><br><code>fileSeek(0,&nbsp;20,&nbsp;PI_FROM_START);&nbsp;//&nbsp;Seek&nbsp;to&nbsp;start&nbsp;plus&nbsp;20<br><br>size&nbsp;=&nbsp;fileSeek(0,&nbsp;0,&nbsp;PI_FROM_END);&nbsp;//&nbsp;Seek&nbsp;to&nbsp;end,&nbsp;return&nbsp;size<br><br>pos&nbsp;=&nbsp;fileSeek(0,&nbsp;0,&nbsp;PI_FROM_CURRENT);&nbsp;//&nbsp;Return&nbsp;current&nbsp;position<br></code><h3><a name="fileList"></a><a href="#int"><small>int</small></a> fileList<small>(<a href="#char">char</a> <a href="#*fpat">*fpat</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#count">count</a>)</small></h3>
This function returns a list of files which match a pattern.  The
pattern may contain wildcards.
<br><br><code>&nbsp;fpat:&nbsp;file&nbsp;pattern&nbsp;to&nbsp;match<br>&nbsp;&nbsp;buf:&nbsp;an&nbsp;array&nbsp;to&nbsp;receive&nbsp;the&nbsp;matching&nbsp;file&nbsp;names<br>count:&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read<br></code><br><br>Returns the number of returned bytes if OK, otherwise PI_NO_FILE_ACCESS,
or PI_NO_FILE_MATCH.
<br><br>The pattern must match an entry in /opt/pigpio/access.  The pattern
may contain wildcards.  See <a href="#fileOpen">fileOpen</a>.
<br><br>NOTE
<br><br>The returned value is not the number of files, it is the number
of bytes in the buffer.  The file names are separated by newline
characters.
<br><br><b><small>Example</small></b><br><br><code>#include&nbsp;&lt;stdio.h&gt;<br>#include&nbsp;&lt;pigpio.h&gt;<br><br>int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;c;<br>&nbsp;&nbsp;&nbsp;char&nbsp;buf[1000];<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(gpioInitialise()&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;1;<br><br>&nbsp;&nbsp;&nbsp;//&nbsp;assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line<br>&nbsp;&nbsp;&nbsp;//&nbsp;/ram/*.c&nbsp;r<br><br>&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;fileList("/ram/p*.c",&nbsp;buf,&nbsp;sizeof(buf));<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;&gt;=&nbsp;0)<br>&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;terminate&nbsp;string<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[c]&nbsp;=&nbsp;0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s",&nbsp;buf);<br>&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;gpioTerminate();<br>}<br></code><h3><a name="gpioCfgBufferSize"></a><a href="#int"><small>int</small></a> gpioCfgBufferSize<small>(<a href="#unsigned">unsigned</a> <a href="#cfgMillis">cfgMillis</a>)</small></h3>
Configures pigpio to buffer cfgMillis milliseconds of GPIO samples.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>cfgMillis:&nbsp;100-10000<br></code><br><br>The default setting is 120 milliseconds.
<br><br>The intention is to allow for bursts of data and protection against
other processes hogging cpu time.
<br><br>I haven't seen a process locked out for more than 100 milliseconds.
<br><br>Making the buffer bigger uses a LOT of memory at the more frequent
sampling rates as shown in the following table in MBs.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;milliseconds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;120&nbsp;250&nbsp;500&nbsp;1sec&nbsp;2sec&nbsp;4sec&nbsp;8sec<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;31&nbsp;&nbsp;55&nbsp;&nbsp;107&nbsp;&nbsp;---&nbsp;&nbsp;---&nbsp;&nbsp;---<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;18&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;55&nbsp;&nbsp;107&nbsp;&nbsp;---&nbsp;&nbsp;---<br>sample&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;12&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;55&nbsp;&nbsp;107&nbsp;&nbsp;---<br>&nbsp;rate&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;10&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;24&nbsp;&nbsp;&nbsp;45&nbsp;&nbsp;&nbsp;87&nbsp;&nbsp;---<br>&nbsp;(us)&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;55&nbsp;&nbsp;107<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;24&nbsp;&nbsp;&nbsp;45&nbsp;&nbsp;&nbsp;87<br></code><h3><a name="gpioCfgClock"></a><a href="#int"><small>int</small></a> gpioCfgClock<small>(<a href="#unsigned">unsigned</a> <a href="#cfgMicros">cfgMicros</a>, <a href="#unsigned">unsigned</a> <a href="#cfgPeripheral">cfgPeripheral</a>, <a href="#unsigned">unsigned</a> <a href="#cfgSource">cfgSource</a>)</small></h3>
Configures pigpio to use a particular sample rate timed by a specified
peripheral.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;cfgMicros:&nbsp;1,&nbsp;2,&nbsp;4,&nbsp;5,&nbsp;8,&nbsp;10<br>cfgPeripheral:&nbsp;0&nbsp;(PWM),&nbsp;1&nbsp;(PCM)<br>&nbsp;&nbsp;&nbsp;&nbsp;cfgSource:&nbsp;deprecated,&nbsp;value&nbsp;is&nbsp;ignored<br></code><br><br>The timings are provided by the specified peripheral (PWM or PCM).
<br><br>The default setting is 5 microseconds using the PCM peripheral.
<br><br>The approximate CPU percentage used for each sample rate is:
<br><br><code>sample&nbsp;&nbsp;cpu<br>&nbsp;rate&nbsp;&nbsp;&nbsp;&nbsp;%<br><br>&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25<br>&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16<br>&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11<br>&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15<br>&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14<br></code><br><br>A sample rate of 5 microseconds seeems to be the sweet spot.
<h3><a name="gpioCfgDMAchannel"></a><a href="#int"><small>int</small></a> gpioCfgDMAchannel<small>(<a href="#unsigned">unsigned</a> <a href="#DMAchannel">DMAchannel</a>)</small></h3>
Configures pigpio to use the specified DMA channel.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>DMAchannel:&nbsp;0-14<br></code><br><br>The default setting is to use channel 14.
<h3><a name="gpioCfgDMAchannels"></a><a href="#int"><small>int</small></a> gpioCfgDMAchannels<small>(<a href="#unsigned">unsigned</a> <a href="#primaryChannel">primaryChannel</a>, <a href="#unsigned">unsigned</a> <a href="#secondaryChannel">secondaryChannel</a>)</small></h3>
Configures pigpio to use the specified DMA channels.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>&nbsp;&nbsp;primaryChannel:&nbsp;0-14<br>secondaryChannel:&nbsp;0-14<br></code><br><br>The default setting depends on whether the Pi has a BCM2711 chip or
not (currently only the Pi4B has a BCM2711).
<br><br>The default setting for a non-BCM2711 is to use channel 14 for the
primary channel and channel 6 for the secondary channel.
<br><br>The default setting for a BCM2711 is to use channel 7 for the
primary channel and channel 6 for the secondary channel.
<br><br>The secondary channel is only used for the transmission of waves.
<br><br>If possible use one of channels 0 to 6 for the secondary channel
(a full channel).
<br><br>A full channel only requires one DMA control block regardless of the
length of a pulse delay.  Channels 7 to 14 (lite channels) require
one DMA control block for each 16383 microseconds of delay.  I.e.
a 10 second pulse delay requires one control block on a full channel
and 611 control blocks on a lite channel.
<h3><a name="gpioCfgPermissions"></a><a href="#int"><small>int</small></a> gpioCfgPermissions<small>(<a href="#uint64_t">uint64_t</a> <a href="#updateMask">updateMask</a>)</small></h3>
Configures pigpio to restrict GPIO updates via the socket or pipe
interfaces to the GPIO specified by the mask.  Programs directly
calling the pigpio library (i.e. linked with -lpigpio are not
affected).  A GPIO update is a write to a GPIO or a GPIO mode
change or any function which would force such an action.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>updateMask:&nbsp;bit&nbsp;(1&lt;&lt;n)&nbsp;is&nbsp;set&nbsp;for&nbsp;each&nbsp;GPIO&nbsp;n&nbsp;which&nbsp;may&nbsp;be&nbsp;updated<br></code><br><br>The default setting depends upon the Pi model. The user GPIO are
added to the mask.
<br><br>If the board revision is not recognised then GPIO 2-27 are allowed.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Unknown board</td><td>PI_DEFAULT_UPDATE_MASK_UNKNOWN</td><td>0x0FFFFFFC<br></td></tr><tr><td>Type 1 board</td><td>PI_DEFAULT_UPDATE_MASK_B1</td><td>0x03E6CF93<br></td></tr><tr><td>Type 2 board</td><td>PI_DEFAULT_UPDATE_MASK_A_B2</td><td>0xFBC6CF9C</td></tr><tr><td>Type 3 board</td><td>PI_DEFAULT_UPDATE_MASK_R3</td><td>0x0FFFFFFC</td></tr></tbody></table><h3><a name="gpioCfgSocketPort"></a><a href="#int"><small>int</small></a> gpioCfgSocketPort<small>(<a href="#unsigned">unsigned</a> <a href="#port">port</a>)</small></h3>
Configures pigpio to use the specified socket port.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>port:&nbsp;1024-32000<br></code><br><br>The default setting is to use port 8888.
<h3><a name="gpioCfgInterfaces"></a><a href="#int"><small>int</small></a> gpioCfgInterfaces<small>(<a href="#unsigned">unsigned</a> <a href="#ifFlags">ifFlags</a>)</small></h3>
Configures pigpio support of the fifo and socket interfaces.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>ifFlags:&nbsp;0-7<br></code><br><br>The default setting (0) is that both interfaces are enabled.
<br><br>Or in PI_DISABLE_FIFO_IF to disable the pipe interface.
<br><br>Or in PI_DISABLE_SOCK_IF to disable the socket interface.
<br><br>Or in PI_LOCALHOST_SOCK_IF to disable remote socket
access (this means that the socket interface is only
usable from the local Pi).
<h3><a name="gpioCfgMemAlloc"></a><a href="#int"><small>int</small></a> gpioCfgMemAlloc<small>(<a href="#unsigned">unsigned</a> <a href="#memAllocMode">memAllocMode</a>)</small></h3>
Selects the method of DMA memory allocation.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>memAllocMode:&nbsp;0-2<br></code><br><br>There are two methods of DMA memory allocation.  The original method
uses the /proc/self/pagemap file to allocate bus memory.  The new
method uses the mailbox property interface to allocate bus memory.
<br><br>Auto will use the mailbox method unless a larger than default buffer
size is requested with <a href="#gpioCfgBufferSize">gpioCfgBufferSize</a>.
<h3><a name="gpioCfgNetAddr"></a><a href="#int"><small>int</small></a> gpioCfgNetAddr<small>(<a href="#int">int</a> <a href="#numSockAddr">numSockAddr</a>, <a href="#uint32_t">uint32_t</a> <a href="#*sockAddr">*sockAddr</a>)</small></h3>
Sets the network addresses which are allowed to talk over the
socket interface.
<br><br>This function is only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><code>numSockAddr:&nbsp;0-256&nbsp;(0&nbsp;means&nbsp;all&nbsp;addresses&nbsp;allowed)<br>&nbsp;&nbsp;&nbsp;sockAddr:&nbsp;an&nbsp;array&nbsp;of&nbsp;permitted&nbsp;network&nbsp;addresses.<br></code><h3><a name="gpioCfgInternals"></a><a href="#int"><small>int</small></a> gpioCfgInternals<small>(<a href="#unsigned">unsigned</a> <a href="#cfgWhat">cfgWhat</a>, <a href="#unsigned">unsigned</a> <a href="#cfgVal">cfgVal</a>)</small></h3>
Used to tune internal settings.
<br><br><code>cfgWhat:&nbsp;see&nbsp;source&nbsp;code<br>&nbsp;cfgVal:&nbsp;see&nbsp;source&nbsp;code<br></code><h3><a name="gpioCfgGetInternals"></a><a href="#uint32_t"><small>uint32_t</small></a> gpioCfgGetInternals<small>(void)</small></h3>
This function returns the current library internal configuration
settings.
<h3><a name="gpioCfgSetInternals"></a><a href="#int"><small>int</small></a> gpioCfgSetInternals<small>(<a href="#uint32_t">uint32_t</a> <a href="#cfgVal">cfgVal</a>)</small></h3>
This function sets the current library internal configuration
settings.
<br><br><code>cfgVal:&nbsp;see&nbsp;source&nbsp;code<br></code><h3><a name="gpioCustom1"></a><a href="#int"><small>int</small></a> gpioCustom1<small>(<a href="#unsigned">unsigned</a> <a href="#arg1">arg1</a>, <a href="#unsigned">unsigned</a> <a href="#arg2">arg2</a>, <a href="#char">char</a> <a href="#*argx">*argx</a>, <a href="#unsigned">unsigned</a> <a href="#argc">argc</a>)</small></h3>
This function is available for user customisation.
<br><br>It returns a single integer value.
<br><br><code>arg1:&nbsp;&gt;=0<br>arg2:&nbsp;&gt;=0<br>argx:&nbsp;extra&nbsp;(byte)&nbsp;arguments<br>argc:&nbsp;number&nbsp;of&nbsp;extra&nbsp;arguments<br></code><br><br>Returns &gt;= 0 if OK, less than 0 indicates a user defined error.
<h3><a name="gpioCustom2"></a><a href="#int"><small>int</small></a> gpioCustom2<small>(<a href="#unsigned">unsigned</a> <a href="#arg1">arg1</a>, <a href="#char">char</a> <a href="#*argx">*argx</a>, <a href="#unsigned">unsigned</a> <a href="#argc">argc</a>, <a href="#char">char</a> <a href="#*retBuf">*retBuf</a>, <a href="#unsigned">unsigned</a> <a href="#retMax">retMax</a>)</small></h3>
This function is available for user customisation.
<br><br>It differs from gpioCustom1 in that it returns an array of bytes
rather than just an integer.
<br><br>The returned value is an integer indicating the number of returned bytes.
<code>&nbsp;&nbsp;arg1:&nbsp;&gt;=0<br>&nbsp;&nbsp;argx:&nbsp;extra&nbsp;(byte)&nbsp;arguments<br>&nbsp;&nbsp;argc:&nbsp;number&nbsp;of&nbsp;extra&nbsp;arguments<br>retBuf:&nbsp;buffer&nbsp;for&nbsp;returned&nbsp;bytes<br>retMax:&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;return<br></code><br><br>Returns &gt;= 0 if OK, less than 0 indicates a user defined error.
<br><br>The number of returned bytes must be retMax or less.
<h3><a name="rawWaveAddSPI"></a><a href="#int"><small>int</small></a> rawWaveAddSPI<small>(<a href="#rawSPI_t">rawSPI_t</a> <a href="#*spi">*spi</a>, <a href="#unsigned">unsigned</a> <a href="#offset">offset</a>, <a href="#unsigned">unsigned</a> <a href="#spiSS">spiSS</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#unsigned">unsigned</a> <a href="#spiTxBits">spiTxBits</a>, <a href="#unsigned">unsigned</a> <a href="#spiBitFirst">spiBitFirst</a>, <a href="#unsigned">unsigned</a> <a href="#spiBitLast">spiBitLast</a>, <a href="#unsigned">unsigned</a> <a href="#spiBits">spiBits</a>)</small></h3>
This function adds a waveform representing SPI data to the
existing waveform (if any).
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spi:&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;spi&nbsp;object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset:&nbsp;microseconds&nbsp;from&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;waveform<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spiSS:&nbsp;the&nbsp;slave&nbsp;select&nbsp;GPIO<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;the&nbsp;bits&nbsp;to&nbsp;transmit,&nbsp;most&nbsp;significant&nbsp;bit&nbsp;first<br>&nbsp;&nbsp;spiTxBits:&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;to&nbsp;write<br>spiBitFirst:&nbsp;the&nbsp;first&nbsp;bit&nbsp;to&nbsp;read<br>&nbsp;spiBitLast:&nbsp;the&nbsp;last&nbsp;bit&nbsp;to&nbsp;read<br>&nbsp;&nbsp;&nbsp;&nbsp;spiBits:&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;to&nbsp;transfer<br></code><br><br>Returns the new total number of pulses in the current waveform if OK,
otherwise PI_BAD_USER_GPIO, PI_BAD_SER_OFFSET, or PI_TOO_MANY_PULSES.
<br><br>Not intended for general use.
<h3><a name="rawWaveAddGeneric"></a><a href="#int"><small>int</small></a> rawWaveAddGeneric<small>(<a href="#unsigned">unsigned</a> <a href="#numPulses">numPulses</a>, <a href="#rawWave_t">rawWave_t</a> <a href="#*pulses">*pulses</a>)</small></h3>
This function adds a number of pulses to the current waveform.
<br><br><code>numPulses:&nbsp;the&nbsp;number&nbsp;of&nbsp;pulses<br>&nbsp;&nbsp;&nbsp;pulses:&nbsp;the&nbsp;array&nbsp;containing&nbsp;the&nbsp;pulses<br></code><br><br>Returns the new total number of pulses in the current waveform if OK,
otherwise PI_TOO_MANY_PULSES.
<br><br>The advantage of this function over gpioWaveAddGeneric is that it
allows the setting of the flags field.
<br><br>The pulses are interleaved in time order within the existing waveform
(if any).
<br><br>Merging allows the waveform to be built in parts, that is the settings
for GPIO#1 can be added, and then GPIO#2 etc.
<br><br>If the added waveform is intended to start after or within the existing
waveform then the first pulse should consist of a delay.
<br><br>Not intended for general use.
<h3><a name="rawWaveCB"></a><a href="#unsigned"><small>unsigned</small></a> rawWaveCB<small>(void)</small></h3>
Returns the number of the cb being currently output.
<br><br>Not intended for general use.
<h3><a name="rawWaveCBAdr"></a><a href="#rawCbs_t"><small>rawCbs_t</small></a> *rawWaveCBAdr<small>(<a href="#int">int</a> <a href="#cbNum">cbNum</a>)</small></h3>
Return the (Linux) address of contol block cbNum.
<br><br><code>cbNum:&nbsp;the&nbsp;cb&nbsp;of&nbsp;interest<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveGetOOL"></a><a href="#uint32_t"><small>uint32_t</small></a> rawWaveGetOOL<small>(<a href="#int">int</a> <a href="#pos">pos</a>)</small></h3>
Gets the OOL parameter stored at pos.
<br><br><code>pos:&nbsp;the&nbsp;position&nbsp;of&nbsp;interest.<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveSetOOL"></a><a href="#void"><small>void</small></a> rawWaveSetOOL<small>(<a href="#int">int</a> <a href="#pos">pos</a>, <a href="#uint32_t">uint32_t</a> <a href="#lVal">lVal</a>)</small></h3>
Sets the OOL parameter stored at pos to value.
<br><br><code>&nbsp;pos:&nbsp;the&nbsp;position&nbsp;of&nbsp;interest<br>lVal:&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveGetOut"></a><a href="#uint32_t"><small>uint32_t</small></a> rawWaveGetOut<small>(<a href="#int">int</a> <a href="#pos">pos</a>)</small></h3>
Gets the wave output parameter stored at pos.
<br><br>DEPRECATED: use rawWaveGetOOL instead.
<br><br><code>pos:&nbsp;the&nbsp;position&nbsp;of&nbsp;interest.<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveSetOut"></a><a href="#void"><small>void</small></a> rawWaveSetOut<small>(<a href="#int">int</a> <a href="#pos">pos</a>, <a href="#uint32_t">uint32_t</a> <a href="#lVal">lVal</a>)</small></h3>
Sets the wave output parameter stored at pos to value.
<br><br>DEPRECATED: use rawWaveSetOOL instead.
<br><br><code>&nbsp;pos:&nbsp;the&nbsp;position&nbsp;of&nbsp;interest<br>lVal:&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveGetIn"></a><a href="#uint32_t"><small>uint32_t</small></a> rawWaveGetIn<small>(<a href="#int">int</a> <a href="#pos">pos</a>)</small></h3>
Gets the wave input value parameter stored at pos.
<br><br>DEPRECATED: use rawWaveGetOOL instead.
<br><br><code>pos:&nbsp;the&nbsp;position&nbsp;of&nbsp;interest<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveSetIn"></a><a href="#void"><small>void</small></a> rawWaveSetIn<small>(<a href="#int">int</a> <a href="#pos">pos</a>, <a href="#uint32_t">uint32_t</a> <a href="#lVal">lVal</a>)</small></h3>
Sets the wave input value stored at pos to value.
<br><br>DEPRECATED: use rawWaveSetOOL instead.
<br><br><code>&nbsp;pos:&nbsp;the&nbsp;position&nbsp;of&nbsp;interest<br>lVal:&nbsp;the&nbsp;value&nbsp;to&nbsp;write<br></code><br><br>Not intended for general use.
<h3><a name="rawWaveInfo"></a><a href="#rawWaveInfo_t"><small>rawWaveInfo_t</small></a> rawWaveInfo<small>(<a href="#int">int</a> <a href="#wave_id">wave_id</a>)</small></h3>
Gets details about the wave with id wave_id.
<br><br><code>wave_id:&nbsp;the&nbsp;wave&nbsp;of&nbsp;interest<br></code><br><br>Not intended for general use.
<h3><a name="getBitInBytes"></a><a href="#int"><small>int</small></a> getBitInBytes<small>(<a href="#int">int</a> <a href="#bitPos">bitPos</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#int">int</a> <a href="#numBits">numBits</a>)</small></h3>
Returns the value of the bit bitPos bits from the start of buf.  Returns
0 if bitPos is greater than or equal to numBits.
<br><br><code>&nbsp;bitPos:&nbsp;bit&nbsp;index&nbsp;from&nbsp;the&nbsp;start&nbsp;of&nbsp;buf<br>&nbsp;&nbsp;&nbsp;&nbsp;buf:&nbsp;array&nbsp;of&nbsp;bits<br>numBits:&nbsp;number&nbsp;of&nbsp;valid&nbsp;bits&nbsp;in&nbsp;buf<br></code><h3><a name="putBitInBytes"></a><a href="#void"><small>void</small></a> putBitInBytes<small>(<a href="#int">int</a> <a href="#bitPos">bitPos</a>, <a href="#char">char</a> <a href="#*buf">*buf</a>, <a href="#int">int</a> <a href="#bit">bit</a>)</small></h3>
Sets the bit bitPos bits from the start of buf to bit.
<br><br><code>bitPos:&nbsp;bit&nbsp;index&nbsp;from&nbsp;the&nbsp;start&nbsp;of&nbsp;buf<br>&nbsp;&nbsp;&nbsp;buf:&nbsp;array&nbsp;of&nbsp;bits<br>&nbsp;&nbsp;&nbsp;bit:&nbsp;0-1,&nbsp;value&nbsp;to&nbsp;set<br></code><h3><a name="time_time"></a><a href="#double"><small>double</small></a> time_time<small>(void)</small></h3>
Return the current time in seconds since the Epoch.
<h3><a name="time_sleep"></a><a href="#void"><small>void</small></a> time_sleep<small>(<a href="#double">double</a> <a href="#seconds">seconds</a>)</small></h3>
Delay execution for a given number of seconds
<br><br><code>seconds:&nbsp;the&nbsp;number&nbsp;of&nbsp;seconds&nbsp;to&nbsp;sleep<br></code><h3><a name="rawDumpWave"></a><a href="#void"><small>void</small></a> rawDumpWave<small>(void)</small></h3>
Used to print a readable version of the current waveform to stderr.
<br><br>Not intended for general use.
<h3><a name="rawDumpScript"></a><a href="#void"><small>void</small></a> rawDumpScript<small>(<a href="#unsigned">unsigned</a> <a href="#script_id">script_id</a>)</small></h3>
Used to print a readable version of a script to stderr.
<br><br><code>script_id:&nbsp;&gt;=0,&nbsp;a&nbsp;script_id&nbsp;returned&nbsp;by&nbsp;<a href="#gpioStoreScript">gpioStoreScript</a><br></code><br><br>Not intended for general use.
<h2>PARAMETERS</h2><h3><a name="active">active</a>: 0-1000000</h3>
The number of microseconds level changes are reported for once
a noise filter has been triggered (by <a href="#steady">steady</a> microseconds of
a stable level).
<h3><a name="arg1">arg1</a></h3>
An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.
<h3><a name="arg2">arg2</a></h3>
An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.
<h3><a name="argc">argc</a></h3>
The count of bytes passed to a user customised function.
<h3><a name="*argx">*argx</a></h3>
A pointer to an array of bytes passed to a user customised function.
Its meaning and content is defined by the customiser.
<h3><a name="baud">baud</a></h3>
The speed of serial communication (I2C, SPI, serial link, waves) in
bits per second.
<h3><a name="bit">bit</a></h3>
A value of 0 or 1.
<h3><a name="bitPos">bitPos</a></h3>
A bit position within a byte or word.  The least significant bit is
position 0.
<h3><a name="bits">bits</a></h3>
A value used to select GPIO.  If bit n of bits is set then GPIO n is
selected.
<br><br>A convenient way to set bit n is to or in (1&lt;&lt;n).
<br><br>e.g. to select bits 5, 9, 23 you could use (1&lt;&lt;5) | (1&lt;&lt;9) | (1&lt;&lt;23).
<h3><a name="*bsc_xfer">*bsc_xfer</a></h3>
A pointer to a <a href="#bsc_xfer_t">bsc_xfer_t</a> object used to control a BSC transfer.
<h3><a name="bsc_xfer_t">bsc_xfer_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;control;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;int&nbsp;rxCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;char&nbsp;rxBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Read&nbsp;only<br>&nbsp;&nbsp;&nbsp;int&nbsp;txCnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Write<br>&nbsp;&nbsp;&nbsp;char&nbsp;txBuf[BSC_FIFO_SIZE];&nbsp;//&nbsp;Write<br>}&nbsp;bsc_xfer_t;<br></code><h3><a name="*buf">*buf</a></h3>
A buffer to hold data being sent or being received.
<h3><a name="bufSize">bufSize</a></h3>
The size in bytes of a buffer.
<h3><a name="bVal">bVal</a>: 0-255 (Hex 0x0-0xFF, Octal 0-0377)</h3>
An 8-bit byte value.
<h3><a name="cbNum">cbNum</a></h3>
A number identifying a DMA contol block.
<h3><a name="cfgMicros">cfgMicros</a></h3>
The GPIO sample rate in microseconds.  The default is 5us, or 200 thousand
samples per second.
<h3><a name="cfgMillis">cfgMillis</a>: 100-10000</h3>
The size of the sample buffer in milliseconds.  Generally this should be
left at the default of 120ms.  If you expect intense bursts of signals it
might be necessary to increase the buffer size.
<h3><a name="cfgPeripheral">cfgPeripheral</a></h3>
One of the PWM or PCM peripherals used to pace DMA transfers for timing
purposes.
<h3><a name="cfgSource">cfgSource</a></h3>
Deprecated.
<h3><a name="cfgVal">cfgVal</a></h3>
A number specifying the value of a configuration item.  See <a href="#cfgWhat">cfgWhat</a>.
<h3><a name="cfgWhat">cfgWhat</a></h3>
A number specifying a configuration item.
<br><br>562484977: print enhanced statistics at termination.<br>
984762879: set the initial debug level.
<h3><a name="char">char</a></h3>
A single character, an 8 bit quantity able to store 0-255.
<h3><a name="clkfreq">clkfreq</a>: 4689-250M (13184-375M for the BCM2711)</h3>
The hardware clock frequency.
<br><br><code>PI_HW_CLK_MIN_FREQ&nbsp;4689<br>PI_HW_CLK_MAX_FREQ&nbsp;250000000<br>PI_HW_CLK_MAX_FREQ_2711&nbsp;375000000<br></code><h3><a name="count">count</a></h3>
The number of bytes to be transferred in an I2C, SPI, or Serial
command.
<h3><a name="CS">CS</a></h3>
The GPIO used for the slave select signal when bit banging SPI.
<h3><a name="data_bits">data_bits</a>: 1-32</h3>
The number of data bits to be used when adding serial data to a
waveform.
<br><br><code>PI_MIN_WAVE_DATABITS&nbsp;1<br>PI_MAX_WAVE_DATABITS&nbsp;32<br></code><h3><a name="DMAchannel">DMAchannel</a>: 0-15</h3>
<code>PI_MIN_DMA_CHANNEL&nbsp;0<br>PI_MAX_DMA_CHANNEL&nbsp;15<br></code><h3><a name="double">double</a></h3>
A floating point number.
<h3><a name="dutycycle">dutycycle</a>: 0-range</h3>
A number representing the ratio of on time to off time for PWM.
<br><br>The number may vary between 0 and range (default 255) where
0 is off and range is fully on.
<h3><a name="edge">edge</a>: 0-2</h3>
The type of GPIO edge to generate an interrupt.  See <a href="#gpioSetISRFunc">gpioSetISRFunc</a>
and <a href="#gpioSetISRFuncEx">gpioSetISRFuncEx</a>.
<br><br><code>RISING_EDGE&nbsp;0<br>FALLING_EDGE&nbsp;1<br>EITHER_EDGE&nbsp;2<br></code><h3><a name="event">event</a>: 0-31</h3>
An event is a signal used to inform one or more consumers
to start an action.
<h3><a name="eventFunc_t">eventFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*eventFunc_t)&nbsp;(int&nbsp;event,&nbsp;uint32_t&nbsp;tick);<br></code><h3><a name="eventFuncEx_t">eventFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*eventFuncEx_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;event,&nbsp;uint32_t&nbsp;tick,&nbsp;void&nbsp;*userdata);<br></code><h3><a name="f">f</a></h3>
A function.
<h3><a name="*file">*file</a></h3>
A full file path.  To be accessible the path must match an entry in
/opt/pigpio/access.
<h3><a name="*fpat">*fpat</a></h3>
A file path which may contain wildcards.  To be accessible the path
must match an entry in /opt/pigpio/access.
<h3><a name="frequency">frequency</a>: &gt;=0</h3>
The number of times a GPIO is swiched on and off per second.  This
can be set per GPIO and may be as little as 5Hz or as much as
40KHz.  The GPIO will be on for a proportion of the time as defined
by its dutycycle.
<h3><a name="gpio">gpio</a></h3>
A Broadcom numbered GPIO, in the range 0-53.
<br><br>There  are 54 General Purpose Input Outputs (GPIO) named GPIO0 through
GPIO53.
<br><br>They are split into two  banks.   Bank  1  consists  of  GPIO0  through
GPIO31.  Bank 2 consists of GPIO32 through GPIO53.
<br><br>All the GPIO which are safe for the user to read and write are in
bank 1.  Not all GPIO in bank 1 are safe though.  Type 1 boards
have 17  safe GPIO.  Type 2 boards have 21.  Type 3 boards have 26.
<br><br>See <a href="#gpioHardwareRevision">gpioHardwareRevision</a>.
<br><br>The user GPIO are marked with an X in the following table.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15<br>Type&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;25&nbsp;26&nbsp;27&nbsp;28&nbsp;29&nbsp;30&nbsp;31<br>Type&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-<br>Type&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-<br></code><h3><a name="gpioAlertFunc_t">gpioAlertFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioAlertFunc_t)&nbsp;(int&nbsp;gpio,&nbsp;int&nbsp;level,&nbsp;uint32_t&nbsp;tick);<br></code><h3><a name="gpioAlertFuncEx_t">gpioAlertFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*eventFuncEx_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;event,&nbsp;int&nbsp;level,&nbsp;uint32_t&nbsp;tick,&nbsp;void&nbsp;*userdata);<br></code><h3><a name="gpioCfg*">gpioCfg*</a></h3>
These functions are only effective if called before <a href="#gpioInitialise">gpioInitialise</a>.
<br><br><a href="#gpioCfgBufferSize">gpioCfgBufferSize</a><br>
<a href="#gpioCfgClock">gpioCfgClock</a><br>
<a href="#gpioCfgDMAchannel">gpioCfgDMAchannel</a><br>
<a href="#gpioCfgDMAchannels">gpioCfgDMAchannels</a><br>
<a href="#gpioCfgPermissions">gpioCfgPermissions</a><br>
<a href="#gpioCfgInterfaces">gpioCfgInterfaces</a><br>
<a href="#gpioCfgSocketPort">gpioCfgSocketPort</a><br>
<a href="#gpioCfgMemAlloc">gpioCfgMemAlloc</a>
<h3><a name="gpioGetSamplesFunc_t">gpioGetSamplesFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioGetSamplesFunc_t)<br>&nbsp;&nbsp;&nbsp;(const&nbsp;gpioSample_t&nbsp;*samples,&nbsp;int&nbsp;numSamples);<br></code><h3><a name="gpioGetSamplesFuncEx_t">gpioGetSamplesFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioGetSamplesFuncEx_t)<br>&nbsp;&nbsp;&nbsp;(const&nbsp;gpioSample_t&nbsp;*samples,&nbsp;int&nbsp;numSamples,&nbsp;void&nbsp;*userdata);<br></code><h3><a name="gpioISRFunc_t">gpioISRFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioISRFunc_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;gpio,&nbsp;int&nbsp;level,&nbsp;uint32_t&nbsp;tick);<br></code><h3><a name="gpioISRFuncEx_t">gpioISRFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioISRFuncEx_t)<br>&nbsp;&nbsp;&nbsp;(int&nbsp;gpio,&nbsp;int&nbsp;level,&nbsp;uint32_t&nbsp;tick,&nbsp;void&nbsp;*userdata);<br></code><h3><a name="gpioPulse_t">gpioPulse_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOn;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOff;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;usDelay;<br>}&nbsp;gpioPulse_t;<br></code><h3><a name="gpioSample_t">gpioSample_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;tick;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;level;<br>}&nbsp;gpioSample_t;<br></code><h3><a name="gpioSignalFunc_t">gpioSignalFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioSignalFunc_t)&nbsp;(int&nbsp;signum);<br></code><h3><a name="gpioSignalFuncEx_t">gpioSignalFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioSignalFuncEx_t)&nbsp;(int&nbsp;signum,&nbsp;void&nbsp;*userdata);<br></code><h3><a name="gpioThreadFunc_t">gpioThreadFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;*(gpioThreadFunc_t)&nbsp;(void&nbsp;*);<br></code><h3><a name="gpioTimerFunc_t">gpioTimerFunc_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioTimerFunc_t)&nbsp;(void);<br></code><h3><a name="gpioTimerFuncEx_t">gpioTimerFuncEx_t</a></h3>
<code>typedef&nbsp;void&nbsp;(*gpioTimerFuncEx_t)&nbsp;(void&nbsp;*userdata);<br></code><h3><a name="gpioWaveAdd*">gpioWaveAdd*</a></h3>
One of
<br><br><a href="#gpioWaveAddNew">gpioWaveAddNew</a><br>
<a href="#gpioWaveAddGeneric">gpioWaveAddGeneric</a><br>
<a href="#gpioWaveAddSerial">gpioWaveAddSerial</a>
<h3><a name="handle">handle</a>: &gt;=0</h3>
A number referencing an object opened by one of
<br><br><a href="#fileOpen">fileOpen</a><br>
<a href="#gpioNotifyOpen">gpioNotifyOpen</a><br>
<a href="#i2cOpen">i2cOpen</a><br>
<a href="#serOpen">serOpen</a><br>
<a href="#spiOpen">spiOpen</a>
<h3><a name="i2cAddr">i2cAddr</a>: 0-0x7F</h3>
The address of a device on the I2C bus.
<h3><a name="i2cBus">i2cBus</a>: &gt;=0</h3>
An I2C bus number.
<h3><a name="i2cFlags">i2cFlags</a>: 0</h3>
Flags which modify an I2C open command.  None are currently defined.
<h3><a name="i2cReg">i2cReg</a>: 0-255</h3>
A register of an I2C device.
<h3><a name="ifFlags">ifFlags</a>: 0-3</h3>
<code>PI_DISABLE_FIFO_IF&nbsp;1<br>PI_DISABLE_SOCK_IF&nbsp;2<br></code><h3><a name="*inBuf">*inBuf</a></h3>
A buffer used to pass data to a function.
<h3><a name="inLen">inLen</a></h3>
The number of bytes of data in a buffer.
<h3><a name="int">int</a></h3>
A whole number, negative or positive.
<h3><a name="int32_t">int32_t</a></h3>
A 32-bit signed value.
<h3><a name="invert">invert</a></h3>
A flag used to set normal or inverted bit bang serial data level logic.
<h3><a name="level">level</a></h3>
The level of a GPIO.  Low or High.
<br><br><code>PI_OFF&nbsp;0<br>PI_ON&nbsp;1<br><br>PI_CLEAR&nbsp;0<br>PI_SET&nbsp;1<br><br>PI_LOW&nbsp;0<br>PI_HIGH&nbsp;1<br></code><br><br>There is one exception.  If a watchdog expires on a GPIO the level will be
reported as PI_TIMEOUT.  See <a href="#gpioSetWatchdog">gpioSetWatchdog</a>.
<br><br><code>PI_TIMEOUT&nbsp;2<br></code><h3><a name="lVal">lVal</a>: 0-4294967295 (Hex 0x0-0xFFFFFFFF, Octal 0-37777777777)</h3>
A 32-bit word value.
<h3><a name="memAllocMode">memAllocMode</a>: 0-2</h3>
The DMA memory allocation mode.
<br><br><code>PI_MEM_ALLOC_AUTO&nbsp;&nbsp;&nbsp;&nbsp;0<br>PI_MEM_ALLOC_PAGEMAP&nbsp;1<br>PI_MEM_ALLOC_MAILBOX&nbsp;2<br></code><h3><a name="*micros">*micros</a></h3>
A value representing microseconds.
<h3><a name="micros">micros</a></h3>
A value representing microseconds.
<h3><a name="millis">millis</a></h3>
A value representing milliseconds.
<h3><a name="MISO">MISO</a></h3>
The GPIO used for the MISO signal when bit banging SPI.
<h3><a name="mode">mode</a></h3>
1. The operational mode of a GPIO, normally INPUT or OUTPUT.
<br><br><code>PI_INPUT&nbsp;0<br>PI_OUTPUT&nbsp;1<br>PI_ALT0&nbsp;4<br>PI_ALT1&nbsp;5<br>PI_ALT2&nbsp;6<br>PI_ALT3&nbsp;7<br>PI_ALT4&nbsp;3<br>PI_ALT5&nbsp;2<br></code><br><br>2. A file open mode.
<br><br><code>PI_FILE_READ&nbsp;&nbsp;1<br>PI_FILE_WRITE&nbsp;2<br>PI_FILE_RW&nbsp;&nbsp;&nbsp;&nbsp;3<br></code><br><br>The following values can be or'd into the mode.
<br><br><code>PI_FILE_APPEND&nbsp;4<br>PI_FILE_CREATE&nbsp;8<br>PI_FILE_TRUNC&nbsp;&nbsp;16<br></code><h3><a name="MOSI">MOSI</a></h3>
The GPIO used for the MOSI signal when bit banging SPI.
<h3><a name="numBits">numBits</a></h3>
The number of bits stored in a buffer.
<h3><a name="numBytes">numBytes</a></h3>
The number of bytes used to store characters in a string.  Depending
on the number of bits per character there may be 1, 2, or 4 bytes
per character.
<h3><a name="numPar">numPar</a>: 0-10</h3>
The number of parameters passed to a script.
<h3><a name="numPulses">numPulses</a></h3>
The number of pulses to be added to a waveform.
<h3><a name="numSegs">numSegs</a></h3>
The number of segments in a combined I2C transaction.
<h3><a name="numSockAddr">numSockAddr</a></h3>
The number of network addresses allowed to use the socket interface.
<br><br>0 means all addresses allowed.
<h3><a name="offset">offset</a></h3>
The associated data starts this number of microseconds from the start of
the waveform.
<h3><a name="*outBuf">*outBuf</a></h3>
A buffer used to return data from a function.
<h3><a name="outLen">outLen</a></h3>
The size in bytes of an output buffer.
<h3><a name="pad">pad</a>: 0-2</h3>
A set of GPIO which share common drivers.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><h3><a name="padStrength">padStrength</a>: 1-16</h3>
The mA which may be drawn from each GPIO whilst still guaranteeing the
high and low levels.
<h3><a name="*param">*param</a></h3>
An array of script parameters.
<h3><a name="pi_i2c_msg_t">pi_i2c_msg_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;addr;&nbsp;&nbsp;//&nbsp;slave&nbsp;address<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;flags;<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;len;&nbsp;&nbsp;&nbsp;//&nbsp;msg&nbsp;length<br>&nbsp;&nbsp;&nbsp;uint8_t&nbsp;&nbsp;*buf;&nbsp;&nbsp;//&nbsp;pointer&nbsp;to&nbsp;msg&nbsp;data<br>}&nbsp;pi_i2c_msg_t;<br></code><h3><a name="port">port</a>: 1024-32000</h3>
The port used to bind to the pigpio socket.  Defaults to 8888.
<h3><a name="pos">pos</a></h3>
The position of an item.
<h3><a name="primaryChannel">primaryChannel</a>: 0-15</h3>
The DMA channel used to time the sampling of GPIO and to time servo and
PWM pulses.
<h3><a name="*pth">*pth</a></h3>
A thread identifier, returned by <a href="#gpioStartThread">gpioStartThread</a>.
<h3><a name="pthread_t">pthread_t</a></h3>
A thread identifier.
<h3><a name="pud">pud</a>: 0-2</h3>
The setting of the pull up/down resistor for a GPIO, which may be off,
pull-up, or pull-down.
<br><br><code>PI_PUD_OFF&nbsp;0<br>PI_PUD_DOWN&nbsp;1<br>PI_PUD_UP&nbsp;2<br></code><h3><a name="pulseLen">pulseLen</a></h3>
1-100, the length of a trigger pulse in microseconds.
<h3><a name="*pulses">*pulses</a></h3>
An array of pulses to be added to a waveform.
<h3><a name="pulsewidth">pulsewidth</a>: 0, 500-2500</h3>
<code>PI_SERVO_OFF&nbsp;0<br>PI_MIN_SERVO_PULSEWIDTH&nbsp;500<br>PI_MAX_SERVO_PULSEWIDTH&nbsp;2500<br></code><h3><a name="PWMduty">PWMduty</a>: 0-1000000 (1M)</h3>
The hardware PWM dutycycle.
<br><br><code>PI_HW_PWM_RANGE&nbsp;1000000<br></code><h3><a name="PWMfreq">PWMfreq</a>: 1-125M (1-187.5M for the BCM2711)</h3>
The hardware PWM frequency.
<br><br><code>PI_HW_PWM_MIN_FREQ&nbsp;1<br>PI_HW_PWM_MAX_FREQ&nbsp;125000000<br>PI_HW_PWM_MAX_FREQ_2711&nbsp;187500000<br></code><h3><a name="range">range</a>: 25-40000</h3>
<code>PI_MIN_DUTYCYCLE_RANGE&nbsp;25<br>PI_MAX_DUTYCYCLE_RANGE&nbsp;40000<br></code><h3><a name="rawCbs_t">rawCbs_t</a></h3>
<code>typedef&nbsp;struct&nbsp;//&nbsp;linux/arch/arm/mach-bcm2708/include/mach/dma.h<br>{<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;info;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;src;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;dst;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;length;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;stride;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;next;<br>&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;pad[2];<br>}&nbsp;rawCbs_t;<br></code><h3><a name="rawSPI_t">rawSPI_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;int&nbsp;clk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;GPIO&nbsp;for&nbsp;clock<br>&nbsp;&nbsp;&nbsp;int&nbsp;mosi;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;GPIO&nbsp;for&nbsp;MOSI<br>&nbsp;&nbsp;&nbsp;int&nbsp;miso;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;GPIO&nbsp;for&nbsp;MISO<br>&nbsp;&nbsp;&nbsp;int&nbsp;ss_pol;&nbsp;&nbsp;//&nbsp;slave&nbsp;select&nbsp;off&nbsp;state<br>&nbsp;&nbsp;&nbsp;int&nbsp;ss_us;&nbsp;&nbsp;&nbsp;//&nbsp;delay&nbsp;after&nbsp;slave&nbsp;select<br>&nbsp;&nbsp;&nbsp;int&nbsp;clk_pol;&nbsp;//&nbsp;clock&nbsp;off&nbsp;state<br>&nbsp;&nbsp;&nbsp;int&nbsp;clk_pha;&nbsp;//&nbsp;clock&nbsp;phase<br>&nbsp;&nbsp;&nbsp;int&nbsp;clk_us;&nbsp;&nbsp;//&nbsp;clock&nbsp;micros<br>}&nbsp;rawSPI_t;<br></code><h3><a name="rawWave_t">rawWave_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOn;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;gpioOff;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;usDelay;<br>&nbsp;&nbsp;&nbsp;uint32_t&nbsp;flags;<br>}&nbsp;rawWave_t;<br></code><h3><a name="rawWaveInfo_t">rawWaveInfo_t</a></h3>
<code>typedef&nbsp;struct<br>{<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;botCB;&nbsp;&nbsp;//&nbsp;first&nbsp;CB&nbsp;used&nbsp;by&nbsp;wave<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;topCB;&nbsp;&nbsp;//&nbsp;last&nbsp;CB&nbsp;used&nbsp;by&nbsp;wave<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;botOOL;&nbsp;//&nbsp;last&nbsp;OOL&nbsp;used&nbsp;by&nbsp;wave<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;topOOL;&nbsp;//&nbsp;first&nbsp;OOL&nbsp;used&nbsp;by&nbsp;wave<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;deleted;<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;numCB;<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;numBOOL;<br>&nbsp;&nbsp;&nbsp;uint16_t&nbsp;numTOOL;<br>}&nbsp;rawWaveInfo_t;<br></code><h3><a name="*retBuf">*retBuf</a></h3>
A buffer to hold a number of bytes returned to a used customised function,
<h3><a name="retMax">retMax</a></h3>
The maximum number of bytes a user customised function should return.
<h3><a name="*rxBuf">*rxBuf</a></h3>
A pointer to a buffer to receive data.
<h3><a name="SCL">SCL</a></h3>
The user GPIO to use for the clock when bit banging I2C.
<h3><a name="SCLK">SCLK</a></h3>
The GPIO used for the SCLK signal when bit banging SPI.
<h3><a name="*script">*script</a></h3>
A pointer to the text of a script.
<h3><a name="script_id">script_id</a></h3>
An id of a stored script as returned by <a href="#gpioStoreScript">gpioStoreScript</a>.
<h3><a name="*scriptName">*scriptName</a></h3>
The name of a <a href="#shell">shell</a> script to be executed.  The script must be present in
/opt/pigpio/cgi and must have execute permission.
<h3><a name="*scriptString">*scriptString</a></h3>
The string to be passed to a <a href="#shell">shell</a> script to be executed.
<h3><a name="SDA">SDA</a></h3>
The user GPIO to use for data when bit banging I2C.
<h3><a name="secondaryChannel">secondaryChannel</a>: 0-6</h3>
The DMA channel used to time output waveforms.
<h3><a name="*seconds">*seconds</a></h3>
A pointer to a uint32_t to store the second component of
a returned time.
<h3><a name="seconds">seconds</a></h3>
The number of seconds.
<h3><a name="seekFrom">seekFrom</a></h3>
<code>PI_FROM_START&nbsp;&nbsp;&nbsp;0<br>PI_FROM_CURRENT&nbsp;1<br>PI_FROM_END&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br></code><h3><a name="seekOffset">seekOffset</a></h3>
The number of bytes to move forward (positive) or backwards (negative)
from the seek position (start, current, or end of file).
<h3><a name="*segs">*segs</a></h3>
An array of segments which make up a combined I2C transaction.
<h3><a name="serFlags">serFlags</a></h3>
Flags which modify a serial open command.  None are currently defined.
<h3><a name="*sertty">*sertty</a></h3>
The name of a serial tty device, e.g. /dev/ttyAMA0, /dev/ttyUSB0, /dev/tty1.
<h3><a name="setting">setting</a></h3>
A value used to set a flag, 0 for false, non-zero for true.
<h3><a name="signum">signum</a>: 0-63</h3>
<code>PI_MIN_SIGNUM&nbsp;0<br>PI_MAX_SIGNUM&nbsp;63<br></code><h3><a name="size_t">size_t</a></h3>
A standard type used to indicate the size of an object in bytes.
<h3><a name="*sockAddr">*sockAddr</a></h3>
An array of network addresses allowed to use the socket interface encoded
as 32 bit numbers.
<br><br>E.g. address 192.168.1.66 would be encoded as 0x4201a8c0.
<h3><a name="*spi">*spi</a></h3>
A pointer to a <a href="#rawSPI_t">rawSPI_t</a> structure.
<h3><a name="spiBitFirst">spiBitFirst</a></h3>
GPIO reads are made from spiBitFirst to spiBitLast.
<h3><a name="spiBitLast">spiBitLast</a></h3>
GPIO reads are made from spiBitFirst to spiBitLast.
<h3><a name="spiBits">spiBits</a></h3>
The number of bits to transfer in a raw SPI transaction.
<h3><a name="spiChan">spiChan</a></h3>
A SPI channel, 0-2.
<h3><a name="spiFlags">spiFlags</a></h3>
See <a href="#spiOpen">spiOpen</a> and <a href="#bbSPIOpen">bbSPIOpen</a>.
<h3><a name="spiSS">spiSS</a></h3>
The SPI slave select GPIO in a raw SPI transaction.
<h3><a name="spiTxBits">spiTxBits</a></h3>
The number of bits to transfer dring a raw SPI transaction
<h3><a name="steady">steady</a>: 0-300000</h3>
The number of microseconds level changes must be stable for
before reporting the level changed (<a href="#gpioGlitchFilter">gpioGlitchFilter</a>) or triggering
the active part of a noise filter (<a href="#gpioNoiseFilter">gpioNoiseFilter</a>).
<h3><a name="stop_bits">stop_bits</a>: 2-8</h3>
The number of (half) stop bits to be used when adding serial data
to a waveform.
<br><br><code>PI_MIN_WAVE_HALFSTOPBITS&nbsp;2<br>PI_MAX_WAVE_HALFSTOPBITS&nbsp;8<br></code><h3><a name="*str">*str</a></h3>
An array of characters.
<h3><a name="timeout">timeout</a></h3>
A GPIO level change timeout in milliseconds.
<br><br><a href="#gpioSetWatchdog">gpioSetWatchdog</a>
<code>PI_MIN_WDOG_TIMEOUT&nbsp;0<br>PI_MAX_WDOG_TIMEOUT&nbsp;60000<br></code><br><br><a href="#gpioSetISRFunc">gpioSetISRFunc</a> and <a href="#gpioSetISRFuncEx">gpioSetISRFuncEx</a>
<code>&lt;=0&nbsp;cancel&nbsp;timeout<br>&gt;0&nbsp;timeout&nbsp;after&nbsp;specified&nbsp;milliseconds<br></code><h3><a name="timer">timer</a></h3>
<code>PI_MIN_TIMER&nbsp;0<br>PI_MAX_TIMER&nbsp;9<br></code><h3><a name="timetype">timetype</a></h3>
<code>PI_TIME_RELATIVE&nbsp;0<br>PI_TIME_ABSOLUTE&nbsp;1<br></code><h3><a name="*txBuf">*txBuf</a></h3>
An array of bytes to transmit.
<h3><a name="uint32_t">uint32_t</a>: 0-0-4,294,967,295 (Hex 0x0-0xFFFFFFFF)</h3>
A 32-bit unsigned value.
<h3><a name="uint64_t">uint64_t</a>: 0-(2^64)-1</h3>
A 64-bit unsigned value.
<h3><a name="unsigned">unsigned</a></h3>
A whole number &gt;= 0.
<h3><a name="updateMask">updateMask</a></h3>
A 64 bit mask indicating which GPIO may be written to by the user.
<br><br>If GPIO#n may be written then bit (1&lt;&lt;n) is set.
<h3><a name="user_gpio">user_gpio</a></h3>
0-31, a Broadcom numbered GPIO.
<br><br>See <a href="#gpio">gpio</a>.
<h3><a name="*userdata">*userdata</a></h3>
A pointer to arbitrary user data.  This may be used to identify the instance.
<br><br>You must ensure that the pointer is in scope at the time it is processed.  If
it is a pointer to a global this is automatic.  Do not pass the address of a
local variable.  If you want to pass a transient object then use the
following technique.
<br><br>In the calling function:
<br><br><code>user_type&nbsp;*userdata;<br><br>user_type&nbsp;my_userdata;<br><br>userdata&nbsp;=&nbsp;malloc(sizeof(user_type));<br><br>*userdata&nbsp;=&nbsp;my_userdata;<br></code><br><br>In the receiving function:
<br><br><code>user_type&nbsp;my_userdata&nbsp;=&nbsp;*(user_type*)userdata;<br><br>free(userdata);<br></code><h3><a name="void">void</a></h3>
Denoting no parameter is required
<h3><a name="wave_id">wave_id</a></h3>
A number identifying a waveform created by <a href="#gpioWaveCreate">gpioWaveCreate</a>.
<h3><a name="wave_mode">wave_mode</a></h3>
The mode determines if the waveform is sent once or cycles
repeatedly.  The SYNC variants wait for the current waveform
to reach the end of a cycle or finish before starting the new
waveform.
<br><br><code>PI_WAVE_MODE_ONE_SHOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>PI_WAVE_MODE_REPEAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>PI_WAVE_MODE_ONE_SHOT_SYNC&nbsp;2<br>PI_WAVE_MODE_REPEAT_SYNC&nbsp;&nbsp;&nbsp;3<br></code><h3><a name="wVal">wVal</a>: 0-65535 (Hex 0x0-0xFFFF, Octal 0-0177777)</h3>
A 16-bit word value.
<h2>Socket Command Codes</h2><code><br>#define&nbsp;PI_CMD_MODES&nbsp;&nbsp;0<br>#define&nbsp;PI_CMD_MODEG&nbsp;&nbsp;1<br>#define&nbsp;PI_CMD_PUD&nbsp;&nbsp;&nbsp;&nbsp;2<br>#define&nbsp;PI_CMD_READ&nbsp;&nbsp;&nbsp;3<br>#define&nbsp;PI_CMD_WRITE&nbsp;&nbsp;4<br>#define&nbsp;PI_CMD_PWM&nbsp;&nbsp;&nbsp;&nbsp;5<br>#define&nbsp;PI_CMD_PRS&nbsp;&nbsp;&nbsp;&nbsp;6<br>#define&nbsp;PI_CMD_PFS&nbsp;&nbsp;&nbsp;&nbsp;7<br>#define&nbsp;PI_CMD_SERVO&nbsp;&nbsp;8<br>#define&nbsp;PI_CMD_WDOG&nbsp;&nbsp;&nbsp;9<br>#define&nbsp;PI_CMD_BR1&nbsp;&nbsp;&nbsp;10<br>#define&nbsp;PI_CMD_BR2&nbsp;&nbsp;&nbsp;11<br>#define&nbsp;PI_CMD_BC1&nbsp;&nbsp;&nbsp;12<br>#define&nbsp;PI_CMD_BC2&nbsp;&nbsp;&nbsp;13<br>#define&nbsp;PI_CMD_BS1&nbsp;&nbsp;&nbsp;14<br>#define&nbsp;PI_CMD_BS2&nbsp;&nbsp;&nbsp;15<br>#define&nbsp;PI_CMD_TICK&nbsp;&nbsp;16<br>#define&nbsp;PI_CMD_HWVER&nbsp;17<br>#define&nbsp;PI_CMD_NO&nbsp;&nbsp;&nbsp;&nbsp;18<br>#define&nbsp;PI_CMD_NB&nbsp;&nbsp;&nbsp;&nbsp;19<br>#define&nbsp;PI_CMD_NP&nbsp;&nbsp;&nbsp;&nbsp;20<br>#define&nbsp;PI_CMD_NC&nbsp;&nbsp;&nbsp;&nbsp;21<br>#define&nbsp;PI_CMD_PRG&nbsp;&nbsp;&nbsp;22<br>#define&nbsp;PI_CMD_PFG&nbsp;&nbsp;&nbsp;23<br>#define&nbsp;PI_CMD_PRRG&nbsp;&nbsp;24<br>#define&nbsp;PI_CMD_HELP&nbsp;&nbsp;25<br>#define&nbsp;PI_CMD_PIGPV&nbsp;26<br>#define&nbsp;PI_CMD_WVCLR&nbsp;27<br>#define&nbsp;PI_CMD_WVAG&nbsp;&nbsp;28<br>#define&nbsp;PI_CMD_WVAS&nbsp;&nbsp;29<br>#define&nbsp;PI_CMD_WVGO&nbsp;&nbsp;30<br>#define&nbsp;PI_CMD_WVGOR&nbsp;31<br>#define&nbsp;PI_CMD_WVBSY&nbsp;32<br>#define&nbsp;PI_CMD_WVHLT&nbsp;33<br>#define&nbsp;PI_CMD_WVSM&nbsp;&nbsp;34<br>#define&nbsp;PI_CMD_WVSP&nbsp;&nbsp;35<br>#define&nbsp;PI_CMD_WVSC&nbsp;&nbsp;36<br>#define&nbsp;PI_CMD_TRIG&nbsp;&nbsp;37<br>#define&nbsp;PI_CMD_PROC&nbsp;&nbsp;38<br>#define&nbsp;PI_CMD_PROCD&nbsp;39<br>#define&nbsp;PI_CMD_PROCR&nbsp;40<br>#define&nbsp;PI_CMD_PROCS&nbsp;41<br>#define&nbsp;PI_CMD_SLRO&nbsp;&nbsp;42<br>#define&nbsp;PI_CMD_SLR&nbsp;&nbsp;&nbsp;43<br>#define&nbsp;PI_CMD_SLRC&nbsp;&nbsp;44<br>#define&nbsp;PI_CMD_PROCP&nbsp;45<br>#define&nbsp;PI_CMD_MICS&nbsp;&nbsp;46<br>#define&nbsp;PI_CMD_MILS&nbsp;&nbsp;47<br>#define&nbsp;PI_CMD_PARSE&nbsp;48<br>#define&nbsp;PI_CMD_WVCRE&nbsp;49<br>#define&nbsp;PI_CMD_WVDEL&nbsp;50<br>#define&nbsp;PI_CMD_WVTX&nbsp;&nbsp;51<br>#define&nbsp;PI_CMD_WVTXR&nbsp;52<br>#define&nbsp;PI_CMD_WVNEW&nbsp;53<br><br>#define&nbsp;PI_CMD_I2CO&nbsp;&nbsp;54<br>#define&nbsp;PI_CMD_I2CC&nbsp;&nbsp;55<br>#define&nbsp;PI_CMD_I2CRD&nbsp;56<br>#define&nbsp;PI_CMD_I2CWD&nbsp;57<br>#define&nbsp;PI_CMD_I2CWQ&nbsp;58<br>#define&nbsp;PI_CMD_I2CRS&nbsp;59<br>#define&nbsp;PI_CMD_I2CWS&nbsp;60<br>#define&nbsp;PI_CMD_I2CRB&nbsp;61<br>#define&nbsp;PI_CMD_I2CWB&nbsp;62<br>#define&nbsp;PI_CMD_I2CRW&nbsp;63<br>#define&nbsp;PI_CMD_I2CWW&nbsp;64<br>#define&nbsp;PI_CMD_I2CRK&nbsp;65<br>#define&nbsp;PI_CMD_I2CWK&nbsp;66<br>#define&nbsp;PI_CMD_I2CRI&nbsp;67<br>#define&nbsp;PI_CMD_I2CWI&nbsp;68<br>#define&nbsp;PI_CMD_I2CPC&nbsp;69<br>#define&nbsp;PI_CMD_I2CPK&nbsp;70<br><br>#define&nbsp;PI_CMD_SPIO&nbsp;&nbsp;71<br>#define&nbsp;PI_CMD_SPIC&nbsp;&nbsp;72<br>#define&nbsp;PI_CMD_SPIR&nbsp;&nbsp;73<br>#define&nbsp;PI_CMD_SPIW&nbsp;&nbsp;74<br>#define&nbsp;PI_CMD_SPIX&nbsp;&nbsp;75<br><br>#define&nbsp;PI_CMD_SERO&nbsp;&nbsp;76<br>#define&nbsp;PI_CMD_SERC&nbsp;&nbsp;77<br>#define&nbsp;PI_CMD_SERRB&nbsp;78<br>#define&nbsp;PI_CMD_SERWB&nbsp;79<br>#define&nbsp;PI_CMD_SERR&nbsp;&nbsp;80<br>#define&nbsp;PI_CMD_SERW&nbsp;&nbsp;81<br>#define&nbsp;PI_CMD_SERDA&nbsp;82<br><br>#define&nbsp;PI_CMD_GDC&nbsp;&nbsp;&nbsp;83<br>#define&nbsp;PI_CMD_GPW&nbsp;&nbsp;&nbsp;84<br><br>#define&nbsp;PI_CMD_HC&nbsp;&nbsp;&nbsp;&nbsp;85<br>#define&nbsp;PI_CMD_HP&nbsp;&nbsp;&nbsp;&nbsp;86<br><br>#define&nbsp;PI_CMD_CF1&nbsp;&nbsp;&nbsp;87<br>#define&nbsp;PI_CMD_CF2&nbsp;&nbsp;&nbsp;88<br><br>#define&nbsp;PI_CMD_BI2CC&nbsp;89<br>#define&nbsp;PI_CMD_BI2CO&nbsp;90<br>#define&nbsp;PI_CMD_BI2CZ&nbsp;91<br><br>#define&nbsp;PI_CMD_I2CZ&nbsp;&nbsp;92<br><br>#define&nbsp;PI_CMD_WVCHA&nbsp;93<br><br>#define&nbsp;PI_CMD_SLRI&nbsp;&nbsp;94<br><br>#define&nbsp;PI_CMD_CGI&nbsp;&nbsp;&nbsp;95<br>#define&nbsp;PI_CMD_CSI&nbsp;&nbsp;&nbsp;96<br><br>#define&nbsp;PI_CMD_FG&nbsp;&nbsp;&nbsp;&nbsp;97<br>#define&nbsp;PI_CMD_FN&nbsp;&nbsp;&nbsp;&nbsp;98<br><br>#define&nbsp;PI_CMD_NOIB&nbsp;&nbsp;99<br><br>#define&nbsp;PI_CMD_WVTXM&nbsp;100<br>#define&nbsp;PI_CMD_WVTAT&nbsp;101<br><br>#define&nbsp;PI_CMD_PADS&nbsp;&nbsp;102<br>#define&nbsp;PI_CMD_PADG&nbsp;&nbsp;103<br><br>#define&nbsp;PI_CMD_FO&nbsp;&nbsp;&nbsp;&nbsp;104<br>#define&nbsp;PI_CMD_FC&nbsp;&nbsp;&nbsp;&nbsp;105<br>#define&nbsp;PI_CMD_FR&nbsp;&nbsp;&nbsp;&nbsp;106<br>#define&nbsp;PI_CMD_FW&nbsp;&nbsp;&nbsp;&nbsp;107<br>#define&nbsp;PI_CMD_FS&nbsp;&nbsp;&nbsp;&nbsp;108<br>#define&nbsp;PI_CMD_FL&nbsp;&nbsp;&nbsp;&nbsp;109<br><br>#define&nbsp;PI_CMD_SHELL&nbsp;110<br><br>#define&nbsp;PI_CMD_BSPIC&nbsp;111<br>#define&nbsp;PI_CMD_BSPIO&nbsp;112<br>#define&nbsp;PI_CMD_BSPIX&nbsp;113<br><br>#define&nbsp;PI_CMD_BSCX&nbsp;&nbsp;114<br><br>#define&nbsp;PI_CMD_EVM&nbsp;&nbsp;&nbsp;115<br>#define&nbsp;PI_CMD_EVT&nbsp;&nbsp;&nbsp;116<br><br>#define&nbsp;PI_CMD_PROCU&nbsp;117<br>#define&nbsp;PI_CMD_WVCAP&nbsp;118<br><br></code><h2>Error Codes</h2><code><br>#define&nbsp;PI_INIT_FAILED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;//&nbsp;gpioInitialise&nbsp;failed<br>#define&nbsp;PI_BAD_USER_GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-2&nbsp;//&nbsp;GPIO&nbsp;not&nbsp;0-31<br>#define&nbsp;PI_BAD_GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-3&nbsp;//&nbsp;GPIO&nbsp;not&nbsp;0-53<br>#define&nbsp;PI_BAD_MODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-4&nbsp;//&nbsp;mode&nbsp;not&nbsp;0-7<br>#define&nbsp;PI_BAD_LEVEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-5&nbsp;//&nbsp;level&nbsp;not&nbsp;0-1<br>#define&nbsp;PI_BAD_PUD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-6&nbsp;//&nbsp;pud&nbsp;not&nbsp;0-2<br>#define&nbsp;PI_BAD_PULSEWIDTH&nbsp;&nbsp;&nbsp;&nbsp;-7&nbsp;//&nbsp;pulsewidth&nbsp;not&nbsp;0&nbsp;or&nbsp;500-2500<br>#define&nbsp;PI_BAD_DUTYCYCLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-8&nbsp;//&nbsp;dutycycle&nbsp;outside&nbsp;set&nbsp;range<br>#define&nbsp;PI_BAD_TIMER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-9&nbsp;//&nbsp;timer&nbsp;not&nbsp;0-9<br>#define&nbsp;PI_BAD_MS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-10&nbsp;//&nbsp;ms&nbsp;not&nbsp;10-60000<br>#define&nbsp;PI_BAD_TIMETYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-11&nbsp;//&nbsp;timetype&nbsp;not&nbsp;0-1<br>#define&nbsp;PI_BAD_SECONDS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-12&nbsp;//&nbsp;seconds&nbsp;&lt;&nbsp;0<br>#define&nbsp;PI_BAD_MICROS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-13&nbsp;//&nbsp;micros&nbsp;not&nbsp;0-999999<br>#define&nbsp;PI_TIMER_FAILED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-14&nbsp;//&nbsp;gpioSetTimerFunc&nbsp;failed<br>#define&nbsp;PI_BAD_WDOG_TIMEOUT&nbsp;-15&nbsp;//&nbsp;timeout&nbsp;not&nbsp;0-60000<br>#define&nbsp;PI_NO_ALERT_FUNC&nbsp;&nbsp;&nbsp;&nbsp;-16&nbsp;//&nbsp;DEPRECATED<br>#define&nbsp;PI_BAD_CLK_PERIPH&nbsp;&nbsp;&nbsp;-17&nbsp;//&nbsp;clock&nbsp;peripheral&nbsp;not&nbsp;0-1<br>#define&nbsp;PI_BAD_CLK_SOURCE&nbsp;&nbsp;&nbsp;-18&nbsp;//&nbsp;DEPRECATED<br>#define&nbsp;PI_BAD_CLK_MICROS&nbsp;&nbsp;&nbsp;-19&nbsp;//&nbsp;clock&nbsp;micros&nbsp;not&nbsp;1,&nbsp;2,&nbsp;4,&nbsp;5,&nbsp;8,&nbsp;or&nbsp;10<br>#define&nbsp;PI_BAD_BUF_MILLIS&nbsp;&nbsp;&nbsp;-20&nbsp;//&nbsp;buf&nbsp;millis&nbsp;not&nbsp;100-10000<br>#define&nbsp;PI_BAD_DUTYRANGE&nbsp;&nbsp;&nbsp;&nbsp;-21&nbsp;//&nbsp;dutycycle&nbsp;range&nbsp;not&nbsp;25-40000<br>#define&nbsp;PI_BAD_DUTY_RANGE&nbsp;&nbsp;&nbsp;-21&nbsp;//&nbsp;DEPRECATED&nbsp;(use&nbsp;PI_BAD_DUTYRANGE)<br>#define&nbsp;PI_BAD_SIGNUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-22&nbsp;//&nbsp;signum&nbsp;not&nbsp;0-63<br>#define&nbsp;PI_BAD_PATHNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-23&nbsp;//&nbsp;can't&nbsp;open&nbsp;pathname<br>#define&nbsp;PI_NO_HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-24&nbsp;//&nbsp;no&nbsp;handle&nbsp;available<br>#define&nbsp;PI_BAD_HANDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-25&nbsp;//&nbsp;unknown&nbsp;handle<br>#define&nbsp;PI_BAD_IF_FLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-26&nbsp;//&nbsp;ifFlags&nbsp;&gt;&nbsp;4<br>#define&nbsp;PI_BAD_CHANNEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-27&nbsp;//&nbsp;DMA&nbsp;channel&nbsp;not&nbsp;0-15<br>#define&nbsp;PI_BAD_PRIM_CHANNEL&nbsp;-27&nbsp;//&nbsp;DMA&nbsp;primary&nbsp;channel&nbsp;not&nbsp;0-15<br>#define&nbsp;PI_BAD_SOCKET_PORT&nbsp;&nbsp;-28&nbsp;//&nbsp;socket&nbsp;port&nbsp;not&nbsp;1024-32000<br>#define&nbsp;PI_BAD_FIFO_COMMAND&nbsp;-29&nbsp;//&nbsp;unrecognized&nbsp;fifo&nbsp;command<br>#define&nbsp;PI_BAD_SECO_CHANNEL&nbsp;-30&nbsp;//&nbsp;DMA&nbsp;secondary&nbsp;channel&nbsp;not&nbsp;0-15<br>#define&nbsp;PI_NOT_INITIALISED&nbsp;&nbsp;-31&nbsp;//&nbsp;function&nbsp;called&nbsp;before&nbsp;gpioInitialise<br>#define&nbsp;PI_INITIALISED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-32&nbsp;//&nbsp;function&nbsp;called&nbsp;after&nbsp;gpioInitialise<br>#define&nbsp;PI_BAD_WAVE_MODE&nbsp;&nbsp;&nbsp;&nbsp;-33&nbsp;//&nbsp;waveform&nbsp;mode&nbsp;not&nbsp;0-3<br>#define&nbsp;PI_BAD_CFG_INTERNAL&nbsp;-34&nbsp;//&nbsp;bad&nbsp;parameter&nbsp;in&nbsp;gpioCfgInternals&nbsp;call<br>#define&nbsp;PI_BAD_WAVE_BAUD&nbsp;&nbsp;&nbsp;&nbsp;-35&nbsp;//&nbsp;baud&nbsp;rate&nbsp;not&nbsp;50-250K(RX)/50-1M(TX)<br>#define&nbsp;PI_TOO_MANY_PULSES&nbsp;&nbsp;-36&nbsp;//&nbsp;waveform&nbsp;has&nbsp;too&nbsp;many&nbsp;pulses<br>#define&nbsp;PI_TOO_MANY_CHARS&nbsp;&nbsp;&nbsp;-37&nbsp;//&nbsp;waveform&nbsp;has&nbsp;too&nbsp;many&nbsp;chars<br>#define&nbsp;PI_NOT_SERIAL_GPIO&nbsp;&nbsp;-38&nbsp;//&nbsp;no&nbsp;bit&nbsp;bang&nbsp;serial&nbsp;read&nbsp;on&nbsp;GPIO<br>#define&nbsp;PI_BAD_SERIAL_STRUC&nbsp;-39&nbsp;//&nbsp;bad&nbsp;(null)&nbsp;serial&nbsp;structure&nbsp;parameter<br>#define&nbsp;PI_BAD_SERIAL_BUF&nbsp;&nbsp;&nbsp;-40&nbsp;//&nbsp;bad&nbsp;(null)&nbsp;serial&nbsp;buf&nbsp;parameter<br>#define&nbsp;PI_NOT_PERMITTED&nbsp;&nbsp;&nbsp;&nbsp;-41&nbsp;//&nbsp;GPIO&nbsp;operation&nbsp;not&nbsp;permitted<br>#define&nbsp;PI_SOME_PERMITTED&nbsp;&nbsp;&nbsp;-42&nbsp;//&nbsp;one&nbsp;or&nbsp;more&nbsp;GPIO&nbsp;not&nbsp;permitted<br>#define&nbsp;PI_BAD_WVSC_COMMND&nbsp;&nbsp;-43&nbsp;//&nbsp;bad&nbsp;WVSC&nbsp;subcommand<br>#define&nbsp;PI_BAD_WVSM_COMMND&nbsp;&nbsp;-44&nbsp;//&nbsp;bad&nbsp;WVSM&nbsp;subcommand<br>#define&nbsp;PI_BAD_WVSP_COMMND&nbsp;&nbsp;-45&nbsp;//&nbsp;bad&nbsp;WVSP&nbsp;subcommand<br>#define&nbsp;PI_BAD_PULSELEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-46&nbsp;//&nbsp;trigger&nbsp;pulse&nbsp;length&nbsp;not&nbsp;1-100<br>#define&nbsp;PI_BAD_SCRIPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-47&nbsp;//&nbsp;invalid&nbsp;script<br>#define&nbsp;PI_BAD_SCRIPT_ID&nbsp;&nbsp;&nbsp;&nbsp;-48&nbsp;//&nbsp;unknown&nbsp;script&nbsp;id<br>#define&nbsp;PI_BAD_SER_OFFSET&nbsp;&nbsp;&nbsp;-49&nbsp;//&nbsp;add&nbsp;serial&nbsp;data&nbsp;offset&nbsp;&gt;&nbsp;30&nbsp;minutes<br>#define&nbsp;PI_GPIO_IN_USE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-50&nbsp;//&nbsp;GPIO&nbsp;already&nbsp;in&nbsp;use<br>#define&nbsp;PI_BAD_SERIAL_COUNT&nbsp;-51&nbsp;//&nbsp;must&nbsp;read&nbsp;at&nbsp;least&nbsp;a&nbsp;byte&nbsp;at&nbsp;a&nbsp;time<br>#define&nbsp;PI_BAD_PARAM_NUM&nbsp;&nbsp;&nbsp;&nbsp;-52&nbsp;//&nbsp;script&nbsp;parameter&nbsp;id&nbsp;not&nbsp;0-9<br>#define&nbsp;PI_DUP_TAG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-53&nbsp;//&nbsp;script&nbsp;has&nbsp;duplicate&nbsp;tag<br>#define&nbsp;PI_TOO_MANY_TAGS&nbsp;&nbsp;&nbsp;&nbsp;-54&nbsp;//&nbsp;script&nbsp;has&nbsp;too&nbsp;many&nbsp;tags<br>#define&nbsp;PI_BAD_SCRIPT_CMD&nbsp;&nbsp;&nbsp;-55&nbsp;//&nbsp;illegal&nbsp;script&nbsp;command<br>#define&nbsp;PI_BAD_VAR_NUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-56&nbsp;//&nbsp;script&nbsp;variable&nbsp;id&nbsp;not&nbsp;0-149<br>#define&nbsp;PI_NO_SCRIPT_ROOM&nbsp;&nbsp;&nbsp;-57&nbsp;//&nbsp;no&nbsp;more&nbsp;room&nbsp;for&nbsp;scripts<br>#define&nbsp;PI_NO_MEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-58&nbsp;//&nbsp;can't&nbsp;allocate&nbsp;temporary&nbsp;memory<br>#define&nbsp;PI_SOCK_READ_FAILED&nbsp;-59&nbsp;//&nbsp;socket&nbsp;read&nbsp;failed<br>#define&nbsp;PI_SOCK_WRIT_FAILED&nbsp;-60&nbsp;//&nbsp;socket&nbsp;write&nbsp;failed<br>#define&nbsp;PI_TOO_MANY_PARAM&nbsp;&nbsp;&nbsp;-61&nbsp;//&nbsp;too&nbsp;many&nbsp;script&nbsp;parameters&nbsp;(&gt;&nbsp;10)<br>#define&nbsp;PI_NOT_HALTED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-62&nbsp;//&nbsp;DEPRECATED<br>#define&nbsp;PI_SCRIPT_NOT_READY&nbsp;-62&nbsp;//&nbsp;script&nbsp;initialising<br>#define&nbsp;PI_BAD_TAG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-63&nbsp;//&nbsp;script&nbsp;has&nbsp;unresolved&nbsp;tag<br>#define&nbsp;PI_BAD_MICS_DELAY&nbsp;&nbsp;&nbsp;-64&nbsp;//&nbsp;bad&nbsp;MICS&nbsp;delay&nbsp;(too&nbsp;large)<br>#define&nbsp;PI_BAD_MILS_DELAY&nbsp;&nbsp;&nbsp;-65&nbsp;//&nbsp;bad&nbsp;MILS&nbsp;delay&nbsp;(too&nbsp;large)<br>#define&nbsp;PI_BAD_WAVE_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-66&nbsp;//&nbsp;non&nbsp;existent&nbsp;wave&nbsp;id<br>#define&nbsp;PI_TOO_MANY_CBS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-67&nbsp;//&nbsp;No&nbsp;more&nbsp;CBs&nbsp;for&nbsp;waveform<br>#define&nbsp;PI_TOO_MANY_OOL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-68&nbsp;//&nbsp;No&nbsp;more&nbsp;OOL&nbsp;for&nbsp;waveform<br>#define&nbsp;PI_EMPTY_WAVEFORM&nbsp;&nbsp;&nbsp;-69&nbsp;//&nbsp;attempt&nbsp;to&nbsp;create&nbsp;an&nbsp;empty&nbsp;waveform<br>#define&nbsp;PI_NO_WAVEFORM_ID&nbsp;&nbsp;&nbsp;-70&nbsp;//&nbsp;no&nbsp;more&nbsp;waveforms<br>#define&nbsp;PI_I2C_OPEN_FAILED&nbsp;&nbsp;-71&nbsp;//&nbsp;can't&nbsp;open&nbsp;I2C&nbsp;device<br>#define&nbsp;PI_SER_OPEN_FAILED&nbsp;&nbsp;-72&nbsp;//&nbsp;can't&nbsp;open&nbsp;serial&nbsp;device<br>#define&nbsp;PI_SPI_OPEN_FAILED&nbsp;&nbsp;-73&nbsp;//&nbsp;can't&nbsp;open&nbsp;SPI&nbsp;device<br>#define&nbsp;PI_BAD_I2C_BUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-74&nbsp;//&nbsp;bad&nbsp;I2C&nbsp;bus<br>#define&nbsp;PI_BAD_I2C_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-75&nbsp;//&nbsp;bad&nbsp;I2C&nbsp;address<br>#define&nbsp;PI_BAD_SPI_CHANNEL&nbsp;&nbsp;-76&nbsp;//&nbsp;bad&nbsp;SPI&nbsp;channel<br>#define&nbsp;PI_BAD_FLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-77&nbsp;//&nbsp;bad&nbsp;i2c/spi/ser&nbsp;open&nbsp;flags<br>#define&nbsp;PI_BAD_SPI_SPEED&nbsp;&nbsp;&nbsp;&nbsp;-78&nbsp;//&nbsp;bad&nbsp;SPI&nbsp;speed<br>#define&nbsp;PI_BAD_SER_DEVICE&nbsp;&nbsp;&nbsp;-79&nbsp;//&nbsp;bad&nbsp;serial&nbsp;device&nbsp;name<br>#define&nbsp;PI_BAD_SER_SPEED&nbsp;&nbsp;&nbsp;&nbsp;-80&nbsp;//&nbsp;bad&nbsp;serial&nbsp;baud&nbsp;rate<br>#define&nbsp;PI_BAD_PARAM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-81&nbsp;//&nbsp;bad&nbsp;i2c/spi/ser&nbsp;parameter<br>#define&nbsp;PI_I2C_WRITE_FAILED&nbsp;-82&nbsp;//&nbsp;i2c&nbsp;write&nbsp;failed<br>#define&nbsp;PI_I2C_READ_FAILED&nbsp;&nbsp;-83&nbsp;//&nbsp;i2c&nbsp;read&nbsp;failed<br>#define&nbsp;PI_BAD_SPI_COUNT&nbsp;&nbsp;&nbsp;&nbsp;-84&nbsp;//&nbsp;bad&nbsp;SPI&nbsp;count<br>#define&nbsp;PI_SER_WRITE_FAILED&nbsp;-85&nbsp;//&nbsp;ser&nbsp;write&nbsp;failed<br>#define&nbsp;PI_SER_READ_FAILED&nbsp;&nbsp;-86&nbsp;//&nbsp;ser&nbsp;read&nbsp;failed<br>#define&nbsp;PI_SER_READ_NO_DATA&nbsp;-87&nbsp;//&nbsp;ser&nbsp;read&nbsp;no&nbsp;data&nbsp;available<br>#define&nbsp;PI_UNKNOWN_COMMAND&nbsp;&nbsp;-88&nbsp;//&nbsp;unknown&nbsp;command<br>#define&nbsp;PI_SPI_XFER_FAILED&nbsp;&nbsp;-89&nbsp;//&nbsp;spi&nbsp;xfer/read/write&nbsp;failed<br>#define&nbsp;PI_BAD_POINTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-90&nbsp;//&nbsp;bad&nbsp;(NULL)&nbsp;pointer<br>#define&nbsp;PI_NO_AUX_SPI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-91&nbsp;//&nbsp;no&nbsp;auxiliary&nbsp;SPI&nbsp;on&nbsp;Pi&nbsp;A&nbsp;or&nbsp;B<br>#define&nbsp;PI_NOT_PWM_GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-92&nbsp;//&nbsp;GPIO&nbsp;is&nbsp;not&nbsp;in&nbsp;use&nbsp;for&nbsp;PWM<br>#define&nbsp;PI_NOT_SERVO_GPIO&nbsp;&nbsp;&nbsp;-93&nbsp;//&nbsp;GPIO&nbsp;is&nbsp;not&nbsp;in&nbsp;use&nbsp;for&nbsp;servo&nbsp;pulses<br>#define&nbsp;PI_NOT_HCLK_GPIO&nbsp;&nbsp;&nbsp;&nbsp;-94&nbsp;//&nbsp;GPIO&nbsp;has&nbsp;no&nbsp;hardware&nbsp;clock<br>#define&nbsp;PI_NOT_HPWM_GPIO&nbsp;&nbsp;&nbsp;&nbsp;-95&nbsp;//&nbsp;GPIO&nbsp;has&nbsp;no&nbsp;hardware&nbsp;PWM<br>#define&nbsp;PI_BAD_HPWM_FREQ&nbsp;&nbsp;&nbsp;&nbsp;-96&nbsp;//&nbsp;invalid&nbsp;hardware&nbsp;PWM&nbsp;frequency<br>#define&nbsp;PI_BAD_HPWM_DUTY&nbsp;&nbsp;&nbsp;&nbsp;-97&nbsp;//&nbsp;hardware&nbsp;PWM&nbsp;dutycycle&nbsp;not&nbsp;0-1M<br>#define&nbsp;PI_BAD_HCLK_FREQ&nbsp;&nbsp;&nbsp;&nbsp;-98&nbsp;//&nbsp;invalid&nbsp;hardware&nbsp;clock&nbsp;frequency<br>#define&nbsp;PI_BAD_HCLK_PASS&nbsp;&nbsp;&nbsp;&nbsp;-99&nbsp;//&nbsp;need&nbsp;password&nbsp;to&nbsp;use&nbsp;hardware&nbsp;clock&nbsp;1<br>#define&nbsp;PI_HPWM_ILLEGAL&nbsp;&nbsp;&nbsp;&nbsp;-100&nbsp;//&nbsp;illegal,&nbsp;PWM&nbsp;in&nbsp;use&nbsp;for&nbsp;main&nbsp;clock<br>#define&nbsp;PI_BAD_DATABITS&nbsp;&nbsp;&nbsp;&nbsp;-101&nbsp;//&nbsp;serial&nbsp;data&nbsp;bits&nbsp;not&nbsp;1-32<br>#define&nbsp;PI_BAD_STOPBITS&nbsp;&nbsp;&nbsp;&nbsp;-102&nbsp;//&nbsp;serial&nbsp;(half)&nbsp;stop&nbsp;bits&nbsp;not&nbsp;2-8<br>#define&nbsp;PI_MSG_TOOBIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-103&nbsp;//&nbsp;socket/pipe&nbsp;message&nbsp;too&nbsp;big<br>#define&nbsp;PI_BAD_MALLOC_MODE&nbsp;-104&nbsp;//&nbsp;bad&nbsp;memory&nbsp;allocation&nbsp;mode<br>#define&nbsp;PI_TOO_MANY_SEGS&nbsp;&nbsp;&nbsp;-105&nbsp;//&nbsp;too&nbsp;many&nbsp;I2C&nbsp;transaction&nbsp;segments<br>#define&nbsp;PI_BAD_I2C_SEG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-106&nbsp;//&nbsp;an&nbsp;I2C&nbsp;transaction&nbsp;segment&nbsp;failed<br>#define&nbsp;PI_BAD_SMBUS_CMD&nbsp;&nbsp;&nbsp;-107&nbsp;//&nbsp;SMBus&nbsp;command&nbsp;not&nbsp;supported&nbsp;by&nbsp;driver<br>#define&nbsp;PI_NOT_I2C_GPIO&nbsp;&nbsp;&nbsp;&nbsp;-108&nbsp;//&nbsp;no&nbsp;bit&nbsp;bang&nbsp;I2C&nbsp;in&nbsp;progress&nbsp;on&nbsp;GPIO<br>#define&nbsp;PI_BAD_I2C_WLEN&nbsp;&nbsp;&nbsp;&nbsp;-109&nbsp;//&nbsp;bad&nbsp;I2C&nbsp;write&nbsp;length<br>#define&nbsp;PI_BAD_I2C_RLEN&nbsp;&nbsp;&nbsp;&nbsp;-110&nbsp;//&nbsp;bad&nbsp;I2C&nbsp;read&nbsp;length<br>#define&nbsp;PI_BAD_I2C_CMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-111&nbsp;//&nbsp;bad&nbsp;I2C&nbsp;command<br>#define&nbsp;PI_BAD_I2C_BAUD&nbsp;&nbsp;&nbsp;&nbsp;-112&nbsp;//&nbsp;bad&nbsp;I2C&nbsp;baud&nbsp;rate,&nbsp;not&nbsp;50-500k<br>#define&nbsp;PI_CHAIN_LOOP_CNT&nbsp;&nbsp;-113&nbsp;//&nbsp;bad&nbsp;chain&nbsp;loop&nbsp;count<br>#define&nbsp;PI_BAD_CHAIN_LOOP&nbsp;&nbsp;-114&nbsp;//&nbsp;empty&nbsp;chain&nbsp;loop<br>#define&nbsp;PI_CHAIN_COUNTER&nbsp;&nbsp;&nbsp;-115&nbsp;//&nbsp;too&nbsp;many&nbsp;chain&nbsp;counters<br>#define&nbsp;PI_BAD_CHAIN_CMD&nbsp;&nbsp;&nbsp;-116&nbsp;//&nbsp;bad&nbsp;chain&nbsp;command<br>#define&nbsp;PI_BAD_CHAIN_DELAY&nbsp;-117&nbsp;//&nbsp;bad&nbsp;chain&nbsp;delay&nbsp;micros<br>#define&nbsp;PI_CHAIN_NESTING&nbsp;&nbsp;&nbsp;-118&nbsp;//&nbsp;chain&nbsp;counters&nbsp;nested&nbsp;too&nbsp;deeply<br>#define&nbsp;PI_CHAIN_TOO_BIG&nbsp;&nbsp;&nbsp;-119&nbsp;//&nbsp;chain&nbsp;is&nbsp;too&nbsp;long<br>#define&nbsp;PI_DEPRECATED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-120&nbsp;//&nbsp;deprecated&nbsp;function&nbsp;removed<br>#define&nbsp;PI_BAD_SER_INVERT&nbsp;&nbsp;-121&nbsp;//&nbsp;bit&nbsp;bang&nbsp;serial&nbsp;invert&nbsp;not&nbsp;0&nbsp;or&nbsp;1<br>#define&nbsp;PI_BAD_EDGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-122&nbsp;//&nbsp;bad&nbsp;ISR&nbsp;edge&nbsp;value,&nbsp;not&nbsp;0-2<br>#define&nbsp;PI_BAD_ISR_INIT&nbsp;&nbsp;&nbsp;&nbsp;-123&nbsp;//&nbsp;bad&nbsp;ISR&nbsp;initialisation<br>#define&nbsp;PI_BAD_FOREVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-124&nbsp;//&nbsp;loop&nbsp;forever&nbsp;must&nbsp;be&nbsp;last&nbsp;command<br>#define&nbsp;PI_BAD_FILTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-125&nbsp;//&nbsp;bad&nbsp;filter&nbsp;parameter<br>#define&nbsp;PI_BAD_PAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-126&nbsp;//&nbsp;bad&nbsp;pad&nbsp;number<br>#define&nbsp;PI_BAD_STRENGTH&nbsp;&nbsp;&nbsp;&nbsp;-127&nbsp;//&nbsp;bad&nbsp;pad&nbsp;drive&nbsp;strength<br>#define&nbsp;PI_FIL_OPEN_FAILED&nbsp;-128&nbsp;//&nbsp;file&nbsp;open&nbsp;failed<br>#define&nbsp;PI_BAD_FILE_MODE&nbsp;&nbsp;&nbsp;-129&nbsp;//&nbsp;bad&nbsp;file&nbsp;mode<br>#define&nbsp;PI_BAD_FILE_FLAG&nbsp;&nbsp;&nbsp;-130&nbsp;//&nbsp;bad&nbsp;file&nbsp;flag<br>#define&nbsp;PI_BAD_FILE_READ&nbsp;&nbsp;&nbsp;-131&nbsp;//&nbsp;bad&nbsp;file&nbsp;read<br>#define&nbsp;PI_BAD_FILE_WRITE&nbsp;&nbsp;-132&nbsp;//&nbsp;bad&nbsp;file&nbsp;write<br>#define&nbsp;PI_FILE_NOT_ROPEN&nbsp;&nbsp;-133&nbsp;//&nbsp;file&nbsp;not&nbsp;open&nbsp;for&nbsp;read<br>#define&nbsp;PI_FILE_NOT_WOPEN&nbsp;&nbsp;-134&nbsp;//&nbsp;file&nbsp;not&nbsp;open&nbsp;for&nbsp;write<br>#define&nbsp;PI_BAD_FILE_SEEK&nbsp;&nbsp;&nbsp;-135&nbsp;//&nbsp;bad&nbsp;file&nbsp;seek<br>#define&nbsp;PI_NO_FILE_MATCH&nbsp;&nbsp;&nbsp;-136&nbsp;//&nbsp;no&nbsp;files&nbsp;match&nbsp;pattern<br>#define&nbsp;PI_NO_FILE_ACCESS&nbsp;&nbsp;-137&nbsp;//&nbsp;no&nbsp;permission&nbsp;to&nbsp;access&nbsp;file<br>#define&nbsp;PI_FILE_IS_A_DIR&nbsp;&nbsp;&nbsp;-138&nbsp;//&nbsp;file&nbsp;is&nbsp;a&nbsp;directory<br>#define&nbsp;PI_BAD_SHELL_STATUS&nbsp;-139&nbsp;//&nbsp;bad&nbsp;shell&nbsp;return&nbsp;status<br>#define&nbsp;PI_BAD_SCRIPT_NAME&nbsp;-140&nbsp;//&nbsp;bad&nbsp;script&nbsp;name<br>#define&nbsp;PI_BAD_SPI_BAUD&nbsp;&nbsp;&nbsp;&nbsp;-141&nbsp;//&nbsp;bad&nbsp;SPI&nbsp;baud&nbsp;rate,&nbsp;not&nbsp;50-500k<br>#define&nbsp;PI_NOT_SPI_GPIO&nbsp;&nbsp;&nbsp;&nbsp;-142&nbsp;//&nbsp;no&nbsp;bit&nbsp;bang&nbsp;SPI&nbsp;in&nbsp;progress&nbsp;on&nbsp;GPIO<br>#define&nbsp;PI_BAD_EVENT_ID&nbsp;&nbsp;&nbsp;&nbsp;-143&nbsp;//&nbsp;bad&nbsp;event&nbsp;id<br>#define&nbsp;PI_CMD_INTERRUPTED&nbsp;-144&nbsp;//&nbsp;Used&nbsp;by&nbsp;Python<br>#define&nbsp;PI_NOT_ON_BCM2711&nbsp;&nbsp;-145&nbsp;//&nbsp;not&nbsp;available&nbsp;on&nbsp;BCM2711<br>#define&nbsp;PI_ONLY_ON_BCM2711&nbsp;-146&nbsp;//&nbsp;only&nbsp;available&nbsp;on&nbsp;BCM2711<br><br>#define&nbsp;PI_PIGIF_ERR_0&nbsp;&nbsp;&nbsp;&nbsp;-2000<br>#define&nbsp;PI_PIGIF_ERR_99&nbsp;&nbsp;&nbsp;-2099<br><br>#define&nbsp;PI_CUSTOM_ERR_0&nbsp;&nbsp;&nbsp;-3000<br>#define&nbsp;PI_CUSTOM_ERR_999&nbsp;-3999<br><br></code><h2>Defaults</h2><code><br>#define&nbsp;PI_DEFAULT_BUFFER_MILLIS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;120<br>#define&nbsp;PI_DEFAULT_CLK_MICROS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>#define&nbsp;PI_DEFAULT_CLK_PERIPHERAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PI_CLOCK_PCM<br>#define&nbsp;PI_DEFAULT_IF_FLAGS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>#define&nbsp;PI_DEFAULT_FOREGROUND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>#define&nbsp;PI_DEFAULT_DMA_CHANNEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14<br>#define&nbsp;PI_DEFAULT_DMA_PRIMARY_CHANNEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14<br>#define&nbsp;PI_DEFAULT_DMA_SECONDARY_CHANNEL&nbsp;&nbsp;&nbsp;6<br>#define&nbsp;PI_DEFAULT_DMA_PRIMARY_CH_2711&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7<br>#define&nbsp;PI_DEFAULT_DMA_SECONDARY_CH_2711&nbsp;&nbsp;&nbsp;6<br>#define&nbsp;PI_DEFAULT_DMA_NOT_SET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15<br>#define&nbsp;PI_DEFAULT_SOCKET_PORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8888<br>#define&nbsp;PI_DEFAULT_SOCKET_PORT_STR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"8888"<br>#define&nbsp;PI_DEFAULT_SOCKET_ADDR_STR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"localhost"<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_UNKNOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000000FFFFFFCLL<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_B1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x03E7CF93<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_A_B2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xFBC7CF9C<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_APLUS_BPLUS&nbsp;0x0080480FFFFFFCLL<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_ZERO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0080000FFFFFFCLL<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_PI2B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0080480FFFFFFCLL<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_PI3B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000000FFFFFFCLL<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_PI4B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0000000FFFFFFCLL<br>#define&nbsp;PI_DEFAULT_UPDATE_MASK_COMPUTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00FFFFFFFFFFFFLL<br>#define&nbsp;PI_DEFAULT_MEM_ALLOC_MODE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PI_MEM_ALLOC_AUTO<br><br>#define&nbsp;PI_DEFAULT_CFG_INTERNALS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br><br></code>