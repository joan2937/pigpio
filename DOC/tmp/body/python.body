pigpio is a Python module for the Raspberry which talks to
the pigpio daemon to allow control of the general purpose
input outputs (GPIO).
<h3>Features</h3>o the pigpio Python module can run on Windows, Macs, or Linux
<br><br>o controls one or more Pi's
<br><br>o hardware timed PWM on any of GPIO 0-31
<br><br>o hardware timed servo pulses on any of GPIO 0-31
<br><br>o callbacks when any of GPIO 0-31 change state
<br><br>o creating and transmitting precisely timed waveforms
<br><br>o reading/writing GPIO and setting their modes
<br><br>o wrappers for I2C, SPI, and serial links
<br><br>o creating and running scripts on the pigpio daemon
<h3>GPIO</h3>ALL GPIO are identified by their Broadcom number.
<h3>Notes</h3>Transmitted waveforms are accurate to a microsecond.
<br><br>Callback level changes are time-stamped and will be
accurate to within a few microseconds.
<h3>Settings</h3>A number of settings are determined when the pigpio daemon is started.
<br><br>o the sample rate (1, 2, 4, 5, 8, or 10 us, default 5 us).
<br><br>o the set of GPIO which may be updated (generally written to).  The
  default set is those available on the Pi board revision.
<br><br>o the available PWM frequencies (see <a href="#set_PWM_frequency">set_PWM_frequency</a>).
<h3>Exceptions</h3>By default a fatal exception is raised if you pass an invalid
argument to a pigpio function.
<br><br>If you wish to handle the returned status yourself you should set
pigpio.exceptions to False.
<br><br>You may prefer to check the returned status in only a few parts
of your code.  In that case do the following:
<br><br><b><small>Example</small></b><br><br><code>pigpio.exceptions&nbsp;=&nbsp;False<br><br>#&nbsp;Code&nbsp;where&nbsp;you&nbsp;want&nbsp;to&nbsp;test&nbsp;the&nbsp;error&nbsp;status.<br><br>pigpio.exceptions&nbsp;=&nbsp;True<br></code><h3>Usage</h3>This module uses the services of the C pigpio library.  pigpio
must be running on the Pi(s) whose GPIO are to be manipulated.
<br><br>The normal way to start pigpio is as a daemon (during system
start).
<br><br>sudo pigpiod
<br><br>Your Python program must import pigpio and create one or more
instances of the pigpio.pi class.  This class gives access to
a specified Pi's GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi1&nbsp;=&nbsp;pigpio.pi()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;pi1&nbsp;accesses&nbsp;the&nbsp;local&nbsp;Pi's&nbsp;GPIO<br>pi2&nbsp;=&nbsp;pigpio.pi('tom')&nbsp;&nbsp;#&nbsp;pi2&nbsp;accesses&nbsp;tom's&nbsp;GPIO<br>pi3&nbsp;=&nbsp;pigpio.pi('dick')&nbsp;#&nbsp;pi3&nbsp;accesses&nbsp;dick's&nbsp;GPIO<br><br>pi1.write(4,&nbsp;0)&nbsp;#&nbsp;set&nbsp;local&nbsp;Pi's&nbsp;GPIO&nbsp;4&nbsp;low<br>pi2.write(4,&nbsp;1)&nbsp;#&nbsp;set&nbsp;tom's&nbsp;GPIO&nbsp;4&nbsp;to&nbsp;high<br>pi3.read(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;get&nbsp;level&nbsp;of&nbsp;dick's&nbsp;GPIO&nbsp;4<br></code><br><br>The later example code snippets assume that pi is an instance of
the pigpio.pi class.
<h2>OVERVIEW</h2><table border="0" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td></td></tr><tr><td><b>ESSENTIAL
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#pigpio.pi">pigpio.pi</a></td><td>                Initialise Pi connection
</td></tr><tr><td><a href="#stop">stop</a></td><td>                     Stop a Pi connection
</td></tr><tr><td></td><td></td></tr><tr><td><b>BASIC
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_mode">set_mode</a></td><td>                 Set a GPIO mode
</td></tr><tr><td><a href="#get_mode">get_mode</a></td><td>                 Get a GPIO mode
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_pull_up_down">set_pull_up_down</a></td><td>         Set/clear GPIO pull up/down resistor
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#read">read</a></td><td>                     Read a GPIO
</td></tr><tr><td><a href="#write">write</a></td><td>                    Write a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>PWM (overrides servo commands on same GPIO)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_PWM_dutycycle">set_PWM_dutycycle</a></td><td>        Start/stop PWM pulses on a GPIO
</td></tr><tr><td><a href="#set_PWM_frequency">set_PWM_frequency</a></td><td>        Set PWM frequency of a GPIO
</td></tr><tr><td><a href="#set_PWM_range">set_PWM_range</a></td><td>            Configure PWM range of a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_PWM_dutycycle">get_PWM_dutycycle</a></td><td>        Get PWM dutycycle set on a GPIO
</td></tr><tr><td><a href="#get_PWM_frequency">get_PWM_frequency</a></td><td>        Get PWM frequency of a GPIO
</td></tr><tr><td><a href="#get_PWM_range">get_PWM_range</a></td><td>            Get configured PWM range of a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_PWM_real_range">get_PWM_real_range</a></td><td>       Get underlying PWM range for a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>Servo (overrides PWM commands on same GPIO)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_servo_pulsewidth">set_servo_pulsewidth</a></td><td>     Start/Stop servo pulses on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_servo_pulsewidth">get_servo_pulsewidth</a></td><td>     Get servo pulsewidth set on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>INTERMEDIATE
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#gpio_trigger">gpio_trigger</a></td><td>             Send a trigger pulse to a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_watchdog">set_watchdog</a></td><td>             Set a watchdog on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#read_bank_1">read_bank_1</a></td><td>              Read all bank 1 GPIO
</td></tr><tr><td><a href="#read_bank_2">read_bank_2</a></td><td>              Read all bank 2 GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#clear_bank_1">clear_bank_1</a></td><td>             Clear selected GPIO in bank 1
</td></tr><tr><td><a href="#clear_bank_2">clear_bank_2</a></td><td>             Clear selected GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_bank_1">set_bank_1</a></td><td>               Set selected GPIO in bank 1
</td></tr><tr><td><a href="#set_bank_2">set_bank_2</a></td><td>               Set selected GPIO in bank 2
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#callback">callback</a></td><td>                 Create GPIO level change callback
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wait_for_edge">wait_for_edge</a></td><td>            Wait for GPIO level change
</td></tr><tr><td></td><td></td></tr><tr><td><b>ADVANCED
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#notify_open">notify_open</a></td><td>              Request a notification handle
</td></tr><tr><td><a href="#notify_begin">notify_begin</a></td><td>             Start notifications for selected GPIO
</td></tr><tr><td><a href="#notify_pause">notify_pause</a></td><td>             Pause notifications
</td></tr><tr><td><a href="#notify_close">notify_close</a></td><td>             Close a notification
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#hardware_clock">hardware_clock</a></td><td>           Start hardware clock on supported GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#hardware_PWM">hardware_PWM</a></td><td>             Start hardware PWM on supported GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_glitch_filter">set_glitch_filter</a></td><td>        Set a glitch filter on a GPIO
</td></tr><tr><td><a href="#set_noise_filter">set_noise_filter</a></td><td>         Set a noise filter on a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#set_pad_strength">set_pad_strength</a></td><td>         Sets a pads drive strength
</td></tr><tr><td><a href="#get_pad_strength">get_pad_strength</a></td><td>         Gets a pads drive strength
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#shell">shell</a></td><td>                    Executes a shell command
</td></tr><tr><td></td><td></td></tr><tr><td><b>Custom
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#custom_1">custom_1</a></td><td>                 User custom function 1
</td></tr><tr><td><a href="#custom_2">custom_2</a></td><td>                 User custom function 2
</td></tr><tr><td></td><td></td></tr><tr><td><b>Events
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#event_callback">event_callback</a></td><td>           Sets a callback for an event
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#event_trigger">event_trigger</a></td><td>            Triggers an event
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wait_for_event">wait_for_event</a></td><td>           Wait for an event
</td></tr><tr><td></td><td></td></tr><tr><td><b>Scripts
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#store_script">store_script</a></td><td>             Store a script
</td></tr><tr><td><a href="#run_script">run_script</a></td><td>               Run a stored script
</td></tr><tr><td><a href="#update_script">update_script</a></td><td>            Set a scripts parameters
</td></tr><tr><td><a href="#script_status">script_status</a></td><td>            Get script status and parameters
</td></tr><tr><td><a href="#stop_script">stop_script</a></td><td>              Stop a running script
</td></tr><tr><td><a href="#delete_script">delete_script</a></td><td>            Delete a stored script
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_open">i2c_open</a></td><td>                 Opens an I2C device
</td></tr><tr><td><a href="#i2c_close">i2c_close</a></td><td>                Closes an I2C device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_write_quick">i2c_write_quick</a></td><td>          SMBus write quick
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_byte">i2c_read_byte</a></td><td>            SMBus read byte
</td></tr><tr><td><a href="#i2c_write_byte">i2c_write_byte</a></td><td>           SMBus write byte
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_byte_data">i2c_read_byte_data</a></td><td>       SMBus read byte data
</td></tr><tr><td><a href="#i2c_write_byte_data">i2c_write_byte_data</a></td><td>      SMBus write byte data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_word_data">i2c_read_word_data</a></td><td>       SMBus read word data
</td></tr><tr><td><a href="#i2c_write_word_data">i2c_write_word_data</a></td><td>      SMBus write word data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_block_data">i2c_read_block_data</a></td><td>      SMBus read block data
</td></tr><tr><td><a href="#i2c_write_block_data">i2c_write_block_data</a></td><td>     SMBus write block data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_i2c_block_data">i2c_read_i2c_block_data</a></td><td>  SMBus read I2C block data
</td></tr><tr><td><a href="#i2c_write_i2c_block_data">i2c_write_i2c_block_data</a></td><td> SMBus write I2C block data
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_read_device">i2c_read_device</a></td><td>          Reads the raw I2C device
</td></tr><tr><td><a href="#i2c_write_device">i2c_write_device</a></td><td>         Writes the raw I2C device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_process_call">i2c_process_call</a></td><td>         SMBus process call
</td></tr><tr><td><a href="#i2c_block_process_call">i2c_block_process_call</a></td><td>   SMBus block process call
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#i2c_zip">i2c_zip</a></td><td>                  Performs multiple I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C BIT BANG
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_i2c_open">bb_i2c_open</a></td><td>              Opens GPIO for bit banging I2C
</td></tr><tr><td><a href="#bb_i2c_close">bb_i2c_close</a></td><td>             Closes GPIO for bit banging I2C
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_i2c_zip">bb_i2c_zip</a></td><td>               Performs multiple bit banged I2C transactions
</td></tr><tr><td></td><td></td></tr><tr><td><b>I2C/SPI SLAVE
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bsc_xfer">bsc_xfer</a></td><td>                 I2C/SPI as slave transfer
</td></tr><tr><td><a href="#bsc_i2c">bsc_i2c</a></td><td>                  I2C as slave transfer
</td></tr><tr><td></td><td></td></tr><tr><td><b>SERIAL
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_open">serial_open</a></td><td>              Opens a serial device
</td></tr><tr><td><a href="#serial_close">serial_close</a></td><td>             Closes a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_read_byte">serial_read_byte</a></td><td>         Reads a byte from a serial device
</td></tr><tr><td><a href="#serial_write_byte">serial_write_byte</a></td><td>        Writes a byte to a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_read">serial_read</a></td><td>              Reads bytes from a serial device
</td></tr><tr><td><a href="#serial_write">serial_write</a></td><td>             Writes bytes to a serial device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#serial_data_available">serial_data_available</a></td><td>    Returns number of bytes ready to be read
</td></tr><tr><td></td><td></td></tr><tr><td><b>SERIAL BIT BANG (read only)
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_serial_read_open">bb_serial_read_open</a></td><td>      Open a GPIO for bit bang serial reads
</td></tr><tr><td><a href="#bb_serial_read_close">bb_serial_read_close</a></td><td>     Close a GPIO for bit bang serial reads
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_serial_invert">bb_serial_invert</a></td><td>         Invert serial logic (1 invert, 0 normal)
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_serial_read">bb_serial_read</a></td><td>           Read bit bang serial data from  a GPIO
</td></tr><tr><td></td><td></td></tr><tr><td><b>SPI
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#spi_open">spi_open</a></td><td>                 Opens a SPI device
</td></tr><tr><td><a href="#spi_close">spi_close</a></td><td>                Closes a SPI device
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#spi_read">spi_read</a></td><td>                 Reads bytes from a SPI device
</td></tr><tr><td><a href="#spi_write">spi_write</a></td><td>                Writes bytes to a SPI device
</td></tr><tr><td><a href="#spi_xfer">spi_xfer</a></td><td>                 Transfers bytes with a SPI device
</td></tr><tr><td></td><td></td></tr><tr><td><b>SPI BIT BANG
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#bb_spi_open">bb_spi_open</a></td><td>              Opens GPIO for bit banging SPI
</td></tr><tr><td><a href="#bb_spi_close">bb_spi_close</a></td><td>             Closes GPIO for bit banging SPI
</td></tr><tr><td><a href="#bb_spi_xfer">bb_spi_xfer</a></td><td>              Transfers bytes with bit banging SPI
</td></tr><tr><td></td><td></td></tr><tr><td><b>FILES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_open">file_open</a></td><td>                Opens a file
</td></tr><tr><td><a href="#file_close">file_close</a></td><td>               Closes a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_read">file_read</a></td><td>                Reads bytes from a file
</td></tr><tr><td><a href="#file_write">file_write</a></td><td>               Writes bytes to a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_seek">file_seek</a></td><td>                Seeks to a position within a file
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#file_list">file_list</a></td><td>                List files which match a pattern
</td></tr><tr><td></td><td></td></tr><tr><td><b>WAVES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_clear">wave_clear</a></td><td>               Deletes all waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_add_new">wave_add_new</a></td><td>             Starts a new waveform
</td></tr><tr><td><a href="#wave_add_generic">wave_add_generic</a></td><td>         Adds a series of pulses to the waveform
</td></tr><tr><td><a href="#wave_add_serial">wave_add_serial</a></td><td>          Adds serial data to the waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_create">wave_create</a></td><td>              Creates a waveform from added data
</td></tr><tr><td><a href="#wave_create_and_pad">wave_create_and_pad</a></td><td>      Creates a waveform of fixed size from added data
</td></tr><tr><td><a href="#wave_delete">wave_delete</a></td><td>              Deletes a waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_send_once">wave_send_once</a></td><td>           Transmits a waveform once
</td></tr><tr><td><a href="#wave_send_repeat">wave_send_repeat</a></td><td>         Transmits a waveform repeatedly
</td></tr><tr><td><a href="#wave_send_using_mode">wave_send_using_mode</a></td><td>     Transmits a waveform in the chosen mode
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_chain">wave_chain</a></td><td>               Transmits a chain of waveforms
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_tx_at">wave_tx_at</a></td><td>               Returns the current transmitting waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_tx_busy">wave_tx_busy</a></td><td>             Checks to see if a waveform has ended
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_tx_stop">wave_tx_stop</a></td><td>             Aborts the current waveform
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_get_cbs">wave_get_cbs</a></td><td>             Length in cbs of the current waveform
</td></tr><tr><td><a href="#wave_get_max_cbs">wave_get_max_cbs</a></td><td>         Absolute maximum allowed cbs
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_get_micros">wave_get_micros</a></td><td>          Length in microseconds of the current waveform
</td></tr><tr><td><a href="#wave_get_max_micros">wave_get_max_micros</a></td><td>      Absolute maximum allowed micros
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#wave_get_pulses">wave_get_pulses</a></td><td>          Length in pulses of the current waveform
</td></tr><tr><td><a href="#wave_get_max_pulses">wave_get_max_pulses</a></td><td>      Absolute maximum allowed pulses
</td></tr><tr><td></td><td></td></tr><tr><td><b>UTILITIES
</b></td><td></td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_current_tick">get_current_tick</a></td><td>         Get current tick (microseconds)
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#get_hardware_revision">get_hardware_revision</a></td><td>    Get hardware revision
</td></tr><tr><td><a href="#get_pigpio_version">get_pigpio_version</a></td><td>       Get the pigpio version
</td></tr><tr><td></td><td></td></tr><tr><td><a href="#pigpio.error_text">pigpio.error_text</a></td><td>        Gets error text from error number
</td></tr><tr><td><a href="#pigpio.tickDiff">pigpio.tickDiff</a></td><td>          Returns difference between two ticks
</td></tr><tr><td><b></b></td><td></td></tr></tbody></table><h2>    class pi
</h2><h3><a name="pigpio.pi">pigpio.pi<small>(<a href="#host">host</a>, <a href="#port">port</a>, <a href="#show_errors">show_errors</a>)</small></h3>
Grants access to a Pi's GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>host:=&nbsp;the&nbsp;host&nbsp;name&nbsp;of&nbsp;the&nbsp;Pi&nbsp;on&nbsp;which&nbsp;the&nbsp;pigpio&nbsp;daemon&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running.&nbsp;&nbsp;The&nbsp;default&nbsp;is&nbsp;localhost&nbsp;unless&nbsp;overridden&nbsp;by<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;PIGPIO_ADDR&nbsp;environment&nbsp;variable.<br></samp><br><br><b><small>Parameters</small></b><br><br><samp>port:=&nbsp;the&nbsp;port&nbsp;number&nbsp;on&nbsp;which&nbsp;the&nbsp;pigpio&nbsp;daemon&nbsp;is&nbsp;listening.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;default&nbsp;is&nbsp;8888&nbsp;unless&nbsp;overridden&nbsp;by&nbsp;the&nbsp;PIGPIO_PORT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;environment&nbsp;variable.&nbsp;&nbsp;The&nbsp;pigpio&nbsp;daemon&nbsp;must&nbsp;have&nbsp;been<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;started&nbsp;with&nbsp;the&nbsp;same&nbsp;port&nbsp;number.<br></samp><br><br>This connects to the pigpio daemon and reserves resources
to be used for sending commands and receiving notifications.
<br><br>An instance attribute <a href="#connected">connected</a> may be used to check the
success of the connection.  If the connection is established
successfully <a href="#connected">connected</a> will be True, otherwise False.
<br><br><b><small>Example</small></b><br><br><code>pi&nbsp;=&nbsp;pigio.pi()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;use&nbsp;defaults<br>pi&nbsp;=&nbsp;pigpio.pi('mypi')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;specify&nbsp;host,&nbsp;default&nbsp;port<br>pi&nbsp;=&nbsp;pigpio.pi('mypi',&nbsp;7777)&nbsp;#&nbsp;specify&nbsp;host&nbsp;and&nbsp;port<br><br>pi&nbsp;=&nbsp;pigpio.pi()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;exit&nbsp;script&nbsp;if&nbsp;no&nbsp;connection<br>if&nbsp;not&nbsp;pi.connected:<br>&nbsp;&nbsp;&nbsp;exit()<br></code><h3><a name="__repr__">__repr__<small>()</small></h3>
<h3><a name="bb_i2c_close">bb_i2c_close<small>(<a href="#SDA">SDA</a>)</small></h3>
This function stops bit banging I2C on a pair of GPIO
previously opened with <a href="#bb_i2c_open">bb_i2c_open</a>.
<br><br><b><small>Parameters</small></b><br><br><samp>SDA:=&nbsp;0-31,&nbsp;the&nbsp;SDA&nbsp;GPIO&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_i2c_open">bb_i2c_open</a><br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_I2C_GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi.bb_i2c_close(SDA)<br></code><h3><a name="bb_i2c_open">bb_i2c_open<small>(<a href="#SDA">SDA</a>, <a href="#SCL">SCL</a>, <a href="#baud">baud</a>)</small></h3>
This function selects a pair of GPIO for bit banging I2C at a
specified baud rate.
<br><br>Bit banging I2C allows for certain operations which are not possible
with the standard I2C driver.
<br><br>o baud rates as low as 50
o repeated starts
o clock stretching
o I2C on any pair of spare GPIO
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;SDA:=&nbsp;0-31<br>&nbsp;SCL:=&nbsp;0-31<br>baud:=&nbsp;50-500000<br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_I2C_BAUD, or
PI_GPIO_IN_USE.
<br><br>NOTE:
<br><br>The GPIO used for SDA and SCL must have pull-ups to 3V3 connected.
As a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.
<br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.bb_i2c_open(4,&nbsp;5,&nbsp;50000)&nbsp;#&nbsp;bit&nbsp;bang&nbsp;on&nbsp;GPIO&nbsp;4/5&nbsp;at&nbsp;50kbps<br></code><h3><a name="bb_i2c_zip">bb_i2c_zip<small>(<a href="#SDA">SDA</a>, <a href="#data">data</a>)</small></h3>
This function executes a sequence of bit banged I2C operations.
The operations to be performed are specified by the contents
of data which contains the concatenated command codes and
associated data.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;SDA:=&nbsp;0-31&nbsp;(as&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_i2c_open">bb_i2c_open</a>)<br>data:=&nbsp;the&nbsp;concatenated&nbsp;I2C&nbsp;commands,&nbsp;see&nbsp;below<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(count,&nbsp;data)&nbsp;=&nbsp;pi.bb_i2c_zip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDA,&nbsp;[4,&nbsp;0x53,&nbsp;2,&nbsp;7,&nbsp;1,&nbsp;0x32,&nbsp;2,&nbsp;6,&nbsp;6,&nbsp;3,&nbsp;0])<br></code><br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>Start</td><td>2</td><td>Start condition</td></tr><tr><td>Stop</td><td>3</td><td>Stop condition</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address and flags default to 0.  The address and flags maintain
their previous value until updated.
<br><br>No flags are currently defined.
<br><br>Any read I2C data is concatenated in the returned bytearray.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53<br>start,&nbsp;write&nbsp;0x32,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x1E<br>start,&nbsp;write&nbsp;0x03,&nbsp;(re)start,&nbsp;read&nbsp;6&nbsp;bytes,&nbsp;stop<br>Set&nbsp;address&nbsp;0x68<br>start,&nbsp;write&nbsp;0x1B,&nbsp;(re)start,&nbsp;read&nbsp;8&nbsp;bytes,&nbsp;stop<br>End<br><br>0x04&nbsp;0x53<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x1E<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x06&nbsp;0x03<br><br>0x04&nbsp;0x68<br>0x02&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x02&nbsp;0x06&nbsp;0x08&nbsp;0x03<br><br>0x00<br></code><h3><a name="bb_serial_invert">bb_serial_invert<small>(<a href="#user_gpio">user_gpio</a>, <a href="#invert">invert</a>)</small></h3>
Invert serial logic.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31&nbsp;(opened&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_serial_read_open">bb_serial_read_open</a>)<br>&nbsp;&nbsp;&nbsp;&nbsp;invert:=&nbsp;0-1&nbsp;(1&nbsp;invert,&nbsp;0&nbsp;normal)<br></samp><br><br><b><small>Example</small></b><br><br><code>status&nbsp;=&nbsp;pi.bb_serial_invert(17,&nbsp;1)<br></code><h3><a name="bb_serial_read">bb_serial_read<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Returns data from the bit bang serial cyclic buffer.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31&nbsp;(opened&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_serial_read_open">bb_serial_read_open</a>)<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br>The bytes returned for each character depend upon the number of
data bits <a href="#bb_bits">bb_bits</a> specified in the <a href="#bb_serial_read_open">bb_serial_read_open</a>
command.
<br><br>For <a href="#bb_bits">bb_bits</a> 1-8 there will be one byte per character.
For <a href="#bb_bits">bb_bits</a> 9-16 there will be two bytes per character.
For <a href="#bb_bits">bb_bits</a> 17-32 there will be four bytes per character.
<br><br><b><small>Example</small></b><br><br><code>(count,&nbsp;data)&nbsp;=&nbsp;pi.bb_serial_read(4)<br></code><h3><a name="bb_serial_read_close">bb_serial_read_close<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Closes a GPIO for bit bang reading of serial data.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31&nbsp;(opened&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_serial_read_open">bb_serial_read_open</a>)<br></samp><br><br><b><small>Example</small></b><br><br><code>status&nbsp;=&nbsp;pi.bb_serial_read_close(17)<br></code><h3><a name="bb_serial_read_open">bb_serial_read_open<small>(<a href="#user_gpio">user_gpio</a>, <a href="#baud">baud</a>, <a href="#bb_bits">bb_bits</a>)</small></h3>
Opens a GPIO for bit bang reading of serial data.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31,&nbsp;the&nbsp;GPIO&nbsp;to&nbsp;use.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:=&nbsp;50-250000,&nbsp;the&nbsp;baud&nbsp;rate.<br>&nbsp;&nbsp;bb_bits:=&nbsp;1-32,&nbsp;the&nbsp;number&nbsp;of&nbsp;bits&nbsp;per&nbsp;word,&nbsp;default&nbsp;8.<br></samp><br><br>The serial data is held in a cyclic buffer and is read using
<a href="#bb_serial_read">bb_serial_read</a>.
<br><br>It is the caller's responsibility to read data from the cyclic
buffer in a timely fashion.
<br><br><b><small>Example</small></b><br><br><code>status&nbsp;=&nbsp;pi.bb_serial_read_open(4,&nbsp;19200)<br>status&nbsp;=&nbsp;pi.bb_serial_read_open(17,&nbsp;9600)<br></code><h3><a name="bb_spi_close">bb_spi_close<small>(<a href="#CS">CS</a>)</small></h3>
This function stops bit banging SPI on a set of GPIO
opened with <a href="#bb_spi_open">bb_spi_open</a>.
<br><br><b><small>Parameters</small></b><br><br><samp>CS:=&nbsp;0-31,&nbsp;the&nbsp;CS&nbsp;GPIO&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_spi_open">bb_spi_open</a><br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_NOT_SPI_GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi.bb_spi_close(CS)<br></code><h3><a name="bb_spi_open">bb_spi_open<small>(<a href="#CS">CS</a>, <a href="#MISO">MISO</a>, <a href="#MOSI">MOSI</a>, <a href="#SCLK">SCLK</a>, <a href="#baud">baud</a>, <a href="#spi_flags">spi_flags</a>)</small></h3>
This function selects a set of GPIO for bit banging SPI at a
specified baud rate.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CS&nbsp;:=&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;MISO&nbsp;:=&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;MOSI&nbsp;:=&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;SCLK&nbsp;:=&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;&nbsp;baud&nbsp;:=&nbsp;50-250000<br>spiFlags&nbsp;:=&nbsp;see&nbsp;below<br></samp><br><br>spiFlags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;0&nbsp;&nbsp;p&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode, defaults to 0
<br><br><code>Mode&nbsp;CPOL&nbsp;CPHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1<br></code><br><br>The following constants may be used to set the mode:
<br><br><code>pigpio.SPI_MODE_0<br>pigpio.SPI_MODE_1<br>pigpio.SPI_MODE_2<br>pigpio.SPI_MODE_3<br></code><br><br>Alternatively pigpio.SPI_CPOL and/or pigpio.SPI_CPHA
may be used.
<br><br>p is 0 if CS is active low (default) and 1 for active high.
pigpio.SPI_CS_HIGH_ACTIVE may be used to set this flag.
<br><br>T is 1 if the least significant bit is transmitted on MOSI first,
the default (0) shifts the most significant bit out first.
pigpio.SPI_TX_LSBFIRST may be used to set this flag.
<br><br>R is 1 if the least significant bit is received on MISO first,
the default (0) receives the most significant bit first.
pigpio.SPI_RX_LSBFIRST may be used to set this flag.
<br><br>The other bits in spiFlags should be set to zero.
<br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, PI_BAD_SPI_BAUD, or
PI_GPIO_IN_USE.
<br><br>If more than one device is connected to the SPI bus (defined by
SCLK, MOSI, and MISO) each must have its own CS.
<br><br><b><small>Example</small></b><br><br><code>bb_spi_open(10,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;10000,&nbsp;0);&nbsp;//&nbsp;device&nbsp;1<br>bb_spi_open(11,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;20000,&nbsp;3);&nbsp;//&nbsp;device&nbsp;2<br></code><h3><a name="bb_spi_xfer">bb_spi_xfer<small>(<a href="#CS">CS</a>, <a href="#data">data</a>)</small></h3>
This function executes a bit banged SPI transfer.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;CS:=&nbsp;0-31&nbsp;(as&nbsp;used&nbsp;in&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#bb_spi_open">bb_spi_open</a>)<br>data:=&nbsp;data&nbsp;to&nbsp;be&nbsp;sent<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>#!/usr/bin/env&nbsp;python<br><br>import&nbsp;pigpio<br><br>CE0=5<br>CE1=6<br>MISO=13<br>MOSI=19<br>SCLK=12<br><br>pi&nbsp;=&nbsp;pigpio.pi()<br>if&nbsp;not&nbsp;pi.connected:<br>&nbsp;&nbsp;&nbsp;exit()<br><br>pi.bb_spi_open(CE0,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;10000,&nbsp;0)&nbsp;#&nbsp;MCP4251&nbsp;DAC<br>pi.bb_spi_open(CE1,&nbsp;MISO,&nbsp;MOSI,&nbsp;SCLK,&nbsp;20000,&nbsp;3)&nbsp;#&nbsp;MCP3008&nbsp;ADC<br><br>for&nbsp;i&nbsp;in&nbsp;range(256):<br><br>&nbsp;&nbsp;&nbsp;count,&nbsp;data&nbsp;=&nbsp;pi.bb_spi_xfer(CE0,&nbsp;[0,&nbsp;i])&nbsp;#&nbsp;Set&nbsp;DAC&nbsp;value<br><br>&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;==&nbsp;2:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count,&nbsp;data&nbsp;=&nbsp;pi.bb_spi_xfer(CE0,&nbsp;[12,&nbsp;0])&nbsp;#&nbsp;Read&nbsp;back&nbsp;DAC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;==&nbsp;2:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_val&nbsp;=&nbsp;data[1]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count,&nbsp;data&nbsp;=&nbsp;pi.bb_spi_xfer(CE1,&nbsp;[1,&nbsp;128,&nbsp;0])&nbsp;#&nbsp;Read&nbsp;ADC<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;==&nbsp;3:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_val&nbsp;=&nbsp;((data[1]&3)&lt;&lt;8)&nbsp;|&nbsp;data[2]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("{}&nbsp;{}".format(set_val,&nbsp;read_val))<br><br>pi.bb_spi_close(CE0)<br>pi.bb_spi_close(CE1)<br><br>pi.stop()<br></code><h3><a name="bsc_i2c">bsc_i2c<small>(<a href="#i2c_address">i2c_address</a>, <a href="#data">data</a>)</small></h3>
This function allows the Pi to act as a slave I2C device.
<br><br>This function is not available on the BCM2711 (e.g. as
used in the Pi4B).
<br><br>The data bytes (if any) are written to the BSC transmit
FIFO and the bytes in the BSC receive FIFO are returned.
<br><br><b><small>Parameters</small></b><br><br><samp>i2c_address:=&nbsp;the&nbsp;I2C&nbsp;slave&nbsp;address.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:=&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;transmit.<br></samp><br><br>The returned value is a tuple of the status, the number
of bytes read, and a bytearray containing the read bytes.
<br><br>See <a href="#bsc_xfer">bsc_xfer</a> for details of the status value.
<br><br>If there was an error the status will be less than zero
(and will contain the error code).
<br><br>Note that an i2c_address of 0 may be used to close
the BSC device and reassign the used GPIO as inputs.
<br><br>This example assumes GPIO 2/3 are connected to GPIO 18/19
(GPIO 10/11 on the BCM2711).
<br><br><b><small>Example</small></b><br><br><code>#!/usr/bin/env&nbsp;python<br>import&nbsp;time<br>import&nbsp;pigpio<br><br>I2C_ADDR=0x13<br><br>def&nbsp;i2c(id,&nbsp;tick):<br>&nbsp;&nbsp;&nbsp;&nbsp;global&nbsp;pi<br><br>&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;b,&nbsp;d&nbsp;=&nbsp;pi.bsc_i2c(I2C_ADDR)<br>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;b:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;d[0]&nbsp;==&nbsp;ord('t'):&nbsp;#&nbsp;116&nbsp;send&nbsp;'HH:MM:SS*'<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("sent={}&nbsp;FR={}&nbsp;received={}&nbsp;[{}]".<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format(s&gt;&gt;16,&nbsp;s&0xfff,b,d))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;b,&nbsp;d&nbsp;=&nbsp;pi.bsc_i2c(I2C_ADDR,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{}*".format(time.asctime()[11:19]))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;d[0]&nbsp;==&nbsp;ord('d'):&nbsp;#&nbsp;100&nbsp;send&nbsp;'Sun&nbsp;Oct&nbsp;30*'<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("sent={}&nbsp;FR={}&nbsp;received={}&nbsp;[{}]".<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format(s&gt;&gt;16,&nbsp;s&0xfff,b,d))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;b,&nbsp;d&nbsp;=&nbsp;pi.bsc_i2c(I2C_ADDR,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{}*".format(time.asctime()[:10]))<br><br>pi&nbsp;=&nbsp;pigpio.pi()<br><br>if&nbsp;not&nbsp;pi.connected:<br>&nbsp;&nbsp;&nbsp;&nbsp;exit()<br><br>#&nbsp;Respond&nbsp;to&nbsp;BSC&nbsp;slave&nbsp;activity<br><br>e&nbsp;=&nbsp;pi.event_callback(pigpio.EVENT_BSC,&nbsp;i2c)<br><br>pi.bsc_i2c(I2C_ADDR)&nbsp;#&nbsp;Configure&nbsp;BSC&nbsp;as&nbsp;I2C&nbsp;slave<br><br>time.sleep(600)<br><br>e.cancel()<br><br>pi.bsc_i2c(0)&nbsp;#&nbsp;Disable&nbsp;BSC&nbsp;peripheral<br><br>pi.stop()<br></code><br><br>While running the above.
<br><br><code>$&nbsp;i2cdetect&nbsp;-y&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;&nbsp;a&nbsp;&nbsp;b&nbsp;&nbsp;c&nbsp;&nbsp;d&nbsp;&nbsp;e&nbsp;&nbsp;f<br>00:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>10:&nbsp;--&nbsp;--&nbsp;--&nbsp;13&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>20:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>30:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>40:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>50:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>60:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br>70:&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--&nbsp;--<br><br>$&nbsp;pigs&nbsp;i2co&nbsp;1&nbsp;0x13&nbsp;0<br>0<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;116<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;9&nbsp;-a<br>9&nbsp;10:13:58*<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;116<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;9&nbsp;-a<br>9&nbsp;10:14:29*<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;100<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;11&nbsp;-a<br>11&nbsp;Sun&nbsp;Oct&nbsp;30*<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;100<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;11&nbsp;-a<br>11&nbsp;Sun&nbsp;Oct&nbsp;30*<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;116<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;9&nbsp;-a<br>9&nbsp;10:23:16*<br><br>$&nbsp;pigs&nbsp;i2cwd&nbsp;0&nbsp;100<br>$&nbsp;pigs&nbsp;i2crd&nbsp;0&nbsp;11&nbsp;-a<br>11&nbsp;Sun&nbsp;Oct&nbsp;30*<br></code><h3><a name="bsc_xfer">bsc_xfer<small>(<a href="#bsc_control">bsc_control</a>, <a href="#data">data</a>)</small></h3>
This function provides a low-level interface to the SPI/I2C Slave
peripheral on the BCM chip.
<br><br>This peripheral allows the Pi to act as a hardware slave device
on an I2C or SPI bus.
<br><br>This is not a bit bang version and as such is OS timing
independent. The bus timing is handled directly by the chip.
<br><br>The output process is simple. You simply append data to the FIFO
buffer on the chip.  This works like a queue, you add data to the
queue and the master removes it.
<br><br>I can't get SPI to work properly.  I tried with a
control word of 0x303 and swapped MISO and MOSI.
<br><br>The function sets the BSC mode, writes any data in
the transmit buffer to the BSC transmit FIFO, and
copies any data in the BSC receive FIFO to the
receive buffer.
<br><br><b><small>Parameters</small></b><br><br><samp>bsc_control:=&nbsp;see&nbsp;below<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:=&nbsp;the&nbsp;data&nbsp;bytes&nbsp;to&nbsp;place&nbsp;in&nbsp;the&nbsp;transmit&nbsp;FIFO.<br></samp><br><br>The returned value is a tuple of the status (see below),
the number of bytes read, and a bytearray containing the
read bytes.  If there was an error the status will be less
than zero (and will contain the error code).
<br><br>Note that the control word sets the BSC mode.  The BSC will
stay in that mode until a different control word is sent.
<br><br>GPIO used for models other than those based on the BCM2711.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>18</td><td>19</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>18</td><td>19</td><td>20</td><td>21</td></tr></tbody></table><br><br>GPIO used for models based on the BCM2711 (e.g. the Pi4B).
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td><td>MOSI</td><td>SCLK</td><td>MISO</td><td>CE</td></tr><tr><td>I2C</td><td>10</td><td>11</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>SPI</td><td>-</td><td>-</td><td>10</td><td>11</td><td>9</td><td>8</td></tr></tbody></table><br><br>When a zero control word is received the used GPIO will be reset
to INPUT mode.
<br><br>bsc_control consists of the following bits:
<br><br><code>22&nbsp;21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;IT&nbsp;HC&nbsp;TF&nbsp;IR&nbsp;RE&nbsp;TE&nbsp;BK&nbsp;EC&nbsp;ES&nbsp;PL&nbsp;PH&nbsp;I2&nbsp;SP&nbsp;EN<br></code><br><br>Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>aaaaaaa</td><td>defines the I2C slave address (only relevant in I2C mode)</td></tr><tr><td>IT</td><td>invert transmit status flags</td></tr><tr><td>HC</td><td>enable host control</td></tr><tr><td>TF</td><td>enable test FIFO</td></tr><tr><td>IR</td><td>invert receive status flags</td></tr><tr><td>RE</td><td>enable receive</td></tr><tr><td>TE</td><td>enable transmit</td></tr><tr><td>BK</td><td>abort operation and clear FIFOs</td></tr><tr><td>EC</td><td>send control register as first I2C byte</td></tr><tr><td>ES</td><td>send status register as first I2C byte</td></tr><tr><td>PL</td><td>set SPI polarity high</td></tr><tr><td>PH</td><td>set SPI phase high</td></tr><tr><td>I2</td><td>enable I2C mode</td></tr><tr><td>SP</td><td>enable SPI mode</td></tr><tr><td>EN</td><td>enable BSC peripheral</td></tr></tbody></table><br><br>The status has the following format:
<br><br><code>20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;S&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;&nbsp;T&nbsp;RB&nbsp;TE&nbsp;RF&nbsp;TF&nbsp;RE&nbsp;TB<br></code><br><br>Bits 0-15 are copied unchanged from the BSC FR register.  See
pages 165-166 of the Broadcom peripherals document for full
details.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>SSSSS</td><td>number of bytes successfully copied to transmit FIFO</td></tr><tr><td>RRRRR</td><td>number of bytes in receieve FIFO</td></tr><tr><td>TTTTT</td><td>number of bytes in transmit FIFO</td></tr><tr><td>RB</td><td>receive busy</td></tr><tr><td>TE</td><td>transmit FIFO empty</td></tr><tr><td>RF</td><td>receive FIFO full</td></tr><tr><td>TF</td><td>transmit FIFO full</td></tr><tr><td>RE</td><td>receive FIFO empty</td></tr><tr><td>TB</td><td>transmit busy</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>(status,&nbsp;count,&nbsp;data)&nbsp;=&nbsp;pi.bsc_xfer(0x330305,&nbsp;"Hello!")<br></code><h3><a name="callback">callback<small>(<a href="#user_gpio">user_gpio</a>, <a href="#edge">edge</a>, <a href="#func">func</a>)</small></h3>
Calls a user supplied function (a callback) whenever the
specified GPIO edge is detected.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge:=&nbsp;EITHER_EDGE,&nbsp;RISING_EDGE&nbsp;(default),&nbsp;or&nbsp;FALLING_EDGE.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func:=&nbsp;user&nbsp;supplied&nbsp;callback&nbsp;function.<br></samp><br><br>The user supplied callback receives three parameters, the GPIO,
the level, and the tick.
<br><br><code>Parameter&nbsp;&nbsp;&nbsp;Value&nbsp;&nbsp;&nbsp;&nbsp;Meaning<br><br>GPIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;GPIO&nbsp;which&nbsp;has&nbsp;changed&nbsp;state<br><br>level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0-2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;change&nbsp;to&nbsp;low&nbsp;(a&nbsp;falling&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;change&nbsp;to&nbsp;high&nbsp;(a&nbsp;rising&nbsp;edge)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&nbsp;no&nbsp;level&nbsp;change&nbsp;(a&nbsp;watchdog&nbsp;timeout)<br><br>tick&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;bit&nbsp;&nbsp;&nbsp;The&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;since&nbsp;boot<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING:&nbsp;this&nbsp;wraps&nbsp;around&nbsp;from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4294967295&nbsp;to&nbsp;0&nbsp;roughly&nbsp;every&nbsp;72&nbsp;minutes<br></code><br><br>If a user callback is not specified a default tally callback is
provided which simply counts edges.  The count may be retrieved
by calling the tally function.  The count may be reset to zero
by calling the reset_tally function.
<br><br>The callback may be cancelled by calling the cancel function.
<br><br>A GPIO may have multiple callbacks (although I can't think of
a reason to do so).
<br><br>The GPIO are sampled at a rate set when the pigpio daemon
is started (default 5 us).
<br><br>The number of samples per second is given in the following table.
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;samples<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;per&nbsp;sec<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1,000,000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;500,000<br>sample&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;250,000<br>rate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;200,000<br>(us)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;125,000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;100,000<br></code><br><br>GPIO level changes shorter than the sample rate may be missed.
<br><br>The daemon software which generates the callbacks is triggered
1000 times per second.  The callbacks will be called once per
level change since the last time they were called.
i.e. The callbacks will get all level changes but there will
be a latency.
<br><br>If you want to track the level of more than one GPIO do so by
maintaining the state in the callback.  Do not use <a href="#read">read</a>.
Remember the event that triggered the callback may have
happened several milliseconds before and the GPIO may have
changed level many times since then.
<br><br><b><small>Example</small></b><br><br><code>def&nbsp;cbf(gpio,&nbsp;level,&nbsp;tick):<br>&nbsp;&nbsp;&nbsp;print(gpio,&nbsp;level,&nbsp;tick)<br><br>cb1&nbsp;=&nbsp;pi.callback(22,&nbsp;pigpio.EITHER_EDGE,&nbsp;cbf)<br><br>cb2&nbsp;=&nbsp;pi.callback(4,&nbsp;pigpio.EITHER_EDGE)<br><br>cb3&nbsp;=&nbsp;pi.callback(17)<br><br>print(cb3.tally())<br><br>cb3.reset_tally()<br><br>cb1.cancel()&nbsp;#&nbsp;To&nbsp;cancel&nbsp;callback&nbsp;cb1.<br></code><h3><a name="clear_bank_1">clear_bank_1<small>(<a href="#bits">bits</a>)</small></h3>
Clears GPIO 0-31 if the corresponding bit in bits is set.
<br><br><b><small>Parameters</small></b><br><br><samp>bits:=&nbsp;a&nbsp;32&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;cleared.<br></samp><br><br>A returned status of PI_SOME_PERMITTED indicates that the user
is not allowed to write to one or more of the GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi.clear_bank_1(int("111110010000",2))<br></code><h3><a name="clear_bank_2">clear_bank_2<small>(<a href="#bits">bits</a>)</small></h3>
Clears GPIO 32-53 if the corresponding bit (0-21) in bits is set.
<br><br><b><small>Parameters</small></b><br><br><samp>bits:=&nbsp;a&nbsp;32&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;cleared.<br></samp><br><br>A returned status of PI_SOME_PERMITTED indicates that the user
is not allowed to write to one or more of the GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi.clear_bank_2(0x1010)<br></code><h3><a name="custom_1">custom_1<small>(<a href="#arg1">arg1</a>, <a href="#arg2">arg2</a>, <a href="#argx">argx</a>)</small></h3>
Calls a pigpio function customised by the user.
<br><br><b><small>Parameters</small></b><br><br><samp>arg1:=&nbsp;&gt;=0,&nbsp;default&nbsp;0.<br>arg2:=&nbsp;&gt;=0,&nbsp;default&nbsp;0.<br>argx:=&nbsp;extra&nbsp;arguments&nbsp;(each&nbsp;0-255),&nbsp;default&nbsp;empty.<br></samp><br><br>The returned value is an integer which by convention
should be &gt;=0 for OK and &lt;0 for error.
<br><br><b><small>Example</small></b><br><br><code>value&nbsp;=&nbsp;pi.custom_1()<br><br>value&nbsp;=&nbsp;pi.custom_1(23)<br><br>value&nbsp;=&nbsp;pi.custom_1(0,&nbsp;55)<br><br>value&nbsp;=&nbsp;pi.custom_1(23,&nbsp;56,&nbsp;[1,&nbsp;5,&nbsp;7])<br><br>value&nbsp;=&nbsp;pi.custom_1(23,&nbsp;56,&nbsp;b"hello")<br><br>value&nbsp;=&nbsp;pi.custom_1(23,&nbsp;56,&nbsp;"hello")<br></code><h3><a name="custom_2">custom_2<small>(<a href="#arg1">arg1</a>, <a href="#argx">argx</a>, <a href="#retMax">retMax</a>)</small></h3>
Calls a pigpio function customised by the user.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;arg1:=&nbsp;&gt;=0,&nbsp;default&nbsp;0.<br>&nbsp;&nbsp;argx:=&nbsp;extra&nbsp;arguments&nbsp;(each&nbsp;0-255),&nbsp;default&nbsp;empty.<br>retMax:=&nbsp;&gt;=0,&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;return,&nbsp;default&nbsp;8192.<br></samp><br><br>The returned value is a tuple of the number of bytes
returned and a bytearray containing the bytes.  If
there was an error the number of bytes read will be
less than zero (and will contain the error code).
<br><br><b><small>Example</small></b><br><br><code>(count,&nbsp;data)&nbsp;=&nbsp;pi.custom_2()<br><br>(count,&nbsp;data)&nbsp;=&nbsp;pi.custom_2(23)<br><br>(count,&nbsp;data)&nbsp;=&nbsp;pi.custom_2(23,&nbsp;[1,&nbsp;5,&nbsp;7])<br><br>(count,&nbsp;data)&nbsp;=&nbsp;pi.custom_2(23,&nbsp;b"hello")<br><br>(count,&nbsp;data)&nbsp;=&nbsp;pi.custom_2(23,&nbsp;"hello",&nbsp;128)<br></code><h3><a name="delete_script">delete_script<small>(<a href="#script_id">script_id</a>)</small></h3>
Deletes a stored script.
<br><br><b><small>Parameters</small></b><br><br><samp>script_id:=&nbsp;id&nbsp;of&nbsp;stored&nbsp;script.<br></samp><br><br><b><small>Example</small></b><br><br><code>status&nbsp;=&nbsp;pi.delete_script(sid)<br></code><h3><a name="event_callback">event_callback<small>(<a href="#event">event</a>, <a href="#func">func</a>)</small></h3>
Calls a user supplied function (a callback) whenever the
specified event is signalled.
<br><br><b><small>Parameters</small></b><br><br><samp>event:=&nbsp;0-31.<br>&nbsp;func:=&nbsp;user&nbsp;supplied&nbsp;callback&nbsp;function.<br></samp><br><br>The user supplied callback receives two parameters, the event id,
and the tick.
<br><br>If a user callback is not specified a default tally callback is
provided which simply counts events.  The count may be retrieved
by calling the tally function.  The count may be reset to zero
by calling the reset_tally function.
<br><br>The callback may be cancelled by calling the event_cancel function.
<br><br>An event may have multiple callbacks (although I can't think of
a reason to do so).
<br><br><b><small>Example</small></b><br><br><code>def&nbsp;cbf(event,&nbsp;tick):<br>&nbsp;&nbsp;&nbsp;print(event,&nbsp;tick)<br><br>cb1&nbsp;=&nbsp;pi.event_callback(22,&nbsp;cbf)<br><br>cb2&nbsp;=&nbsp;pi.event_callback(4)<br><br>print(cb2.tally())<br><br>cb2.reset_tally()<br><br>cb1.event_cancel()&nbsp;#&nbsp;To&nbsp;cancel&nbsp;callback&nbsp;cb1.<br></code><h3><a name="event_trigger">event_trigger<small>(<a href="#event">event</a>)</small></h3>
This function signals the occurrence of an event.
<br><br><b><small>Parameters</small></b><br><br><samp>event:=&nbsp;0-31,&nbsp;the&nbsp;event<br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_EVENT_ID.
<br><br>An event is a signal used to inform one or more consumers
to start an action.  Each consumer which has registered an
interest in the event (e.g. by calling <a href="#event_callback">event_callback</a>) will
be informed by a callback.
<br><br>One event, EVENT_BSC (31) is predefined.  This event is
auto generated on BSC slave activity.
<br><br>The meaning of other events is arbitrary.
<br><br>Note that other than its id and its tick there is no data associated
with an event.
<br><br><b><small>Example</small></b><br><br><code>pi.event_trigger(23)<br></code><h3><a name="file_close">file_close<small>(<a href="#handle">handle</a>)</small></h3>
Closes the file associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#file_open">file_open</a>).<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.file_close(handle)<br></code><h3><a name="file_list">file_list<small>(<a href="#fpattern">fpattern</a>)</small></h3>
Returns a list of files which match a pattern.
<br><br><b><small>Parameters</small></b><br><br><samp>fpattern:=&nbsp;file&nbsp;pattern&nbsp;to&nbsp;match.<br></samp><br><br>Returns the number of returned bytes if OK, otherwise
PI_NO_FILE_ACCESS, or PI_NO_FILE_MATCH.
<br><br>The pattern must match an entry in /opt/pigpio/access.  The
pattern may contain wildcards.  See <a href="#file_open">file_open</a>.
<br><br>NOTE
<br><br>The returned value is not the number of files, it is the number
of bytes in the buffer.  The file names are separated by newline
characters.
<br><br><b><small>Example</small></b><br><br><code>#!/usr/bin/env&nbsp;python<br><br>import&nbsp;pigpio<br><br>pi&nbsp;=&nbsp;pigpio.pi()<br><br>if&nbsp;not&nbsp;pi.connected:<br>&nbsp;&nbsp;&nbsp;exit()<br><br>#&nbsp;Assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line:<br>#&nbsp;/ram/*.c&nbsp;r<br><br>c,&nbsp;d&nbsp;=&nbsp;pi.file_list("/ram/p*.c")<br>if&nbsp;c&nbsp;&gt;&nbsp;0:<br>&nbsp;&nbsp;&nbsp;print(d)<br><br>pi.stop()<br></code><h3><a name="file_open">file_open<small>(<a href="#file_name">file_name</a>, <a href="#file_mode">file_mode</a>)</small></h3>
This function returns a handle to a file opened in a specified mode.
<br><br><b><small>Parameters</small></b><br><br><samp>file_name:=&nbsp;the&nbsp;file&nbsp;to&nbsp;open.<br>file_mode:=&nbsp;the&nbsp;file&nbsp;open&nbsp;mode.<br></samp><br><br>Returns a handle (&gt;=0) if OK, otherwise PI_NO_HANDLE,
PI_NO_FILE_ACCESS, PI_BAD_FILE_MODE,
PI_FILE_OPEN_FAILED, or PI_FILE_IS_A_DIR.
<br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.file_open("/home/pi/shared/dir_3/file.txt",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pigpio.FILE_WRITE&nbsp;|&nbsp;pigpio.FILE_CREATE)<br><br>pi.file_write(h,&nbsp;"Hello&nbsp;world")<br><br>pi.file_close(h)<br></code><br><br>File
<br><br>A file may only be opened if permission is granted by an entry
in /opt/pigpio/access.  This is intended to allow remote access
to files in a more or less controlled manner.
<br><br>Each entry in /opt/pigpio/access takes the form of a file path
which may contain wildcards followed by a single letter permission.
The permission may be R for read, W for write, U for read/write,
and N for no access.
<br><br>Where more than one entry matches a file the most specific rule
applies.  If no entry matches a file then access is denied.
<br><br>Suppose /opt/pigpio/access contains the following entries:
<br><br><code>/home/*&nbsp;n<br>/home/pi/shared/dir_1/*&nbsp;w<br>/home/pi/shared/dir_2/*&nbsp;r<br>/home/pi/shared/dir_3/*&nbsp;u<br>/home/pi/shared/dir_1/file.txt&nbsp;n<br></code><br><br>Files may be written in directory dir_1 with the exception
of file.txt.
<br><br>Files may be read in directory dir_2.
<br><br>Files may be read and written in directory dir_3.
<br><br>If a directory allows read, write, or read/write access then files
may be created in that directory.
<br><br>In an attempt to prevent risky permissions the following paths are
ignored in /opt/pigpio/access:
<br><br><code>a&nbsp;path&nbsp;containing&nbsp;..<br>a&nbsp;path&nbsp;containing&nbsp;only&nbsp;wildcards&nbsp;(*?)<br>a&nbsp;path&nbsp;containing&nbsp;less&nbsp;than&nbsp;two&nbsp;non-wildcard&nbsp;parts<br></code><br><br>Mode
<br><br>The mode may have the following values:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Constant</td><td>Value</td><td>Meaning</td></tr><tr><td>FILE_READ</td><td>1</td><td>open file for reading</td></tr><tr><td>FILE_WRITE</td><td>2</td><td>open file for writing</td></tr><tr><td>FILE_RW</td><td>3</td><td>open file for reading and writing</td></tr></tbody></table><br><br>The following values may be or'd into the mode:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Value</td><td>Meaning</td></tr><tr><td>FILE_APPEND</td><td>4</td><td>All writes append data to the end of the file</td></tr><tr><td>FILE_CREATE</td><td>8</td><td>The file is created if it doesn't exist</td></tr><tr><td>FILE_TRUNC</td><td>16</td><td>The file is truncated</td></tr></tbody></table><br><br>Newly created files are owned by root with permissions owner
read and write.
<br><br><b><small>Example</small></b><br><br><code>#!/usr/bin/env&nbsp;python<br><br>import&nbsp;pigpio<br><br>pi&nbsp;=&nbsp;pigpio.pi()<br><br>if&nbsp;not&nbsp;pi.connected:<br>&nbsp;&nbsp;&nbsp;exit()<br><br>#&nbsp;Assumes&nbsp;/opt/pigpio/access&nbsp;contains&nbsp;the&nbsp;following&nbsp;line:<br>#&nbsp;/ram/*.c&nbsp;r<br><br>handle&nbsp;=&nbsp;pi.file_open("/ram/pigpio.c",&nbsp;pigpio.FILE_READ)<br><br>done&nbsp;=&nbsp;False<br><br>while&nbsp;not&nbsp;done:<br>&nbsp;&nbsp;&nbsp;c,&nbsp;d&nbsp;=&nbsp;pi.file_read(handle,&nbsp;60000)<br>&nbsp;&nbsp;&nbsp;if&nbsp;c&nbsp;&gt;&nbsp;0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(d)<br>&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done&nbsp;=&nbsp;True<br><br>pi.file_close(handle)<br><br>pi.stop()<br></code><h3><a name="file_read">file_read<small>(<a href="#handle">handle</a>, <a href="#count">count</a>)</small></h3>
Reads up to count bytes from the file associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#file_open">file_open</a>).<br>&nbsp;count:=&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(b,&nbsp;d)&nbsp;=&nbsp;pi.file_read(h2,&nbsp;100)<br>if&nbsp;b&nbsp;&gt;&nbsp;0:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;read&nbsp;data<br></code><h3><a name="file_seek">file_seek<small>(<a href="#handle">handle</a>, <a href="#seek_offset">seek_offset</a>, <a href="#seek_from">seek_from</a>)</small></h3>
Seeks to a position relative to the start, current position,
or end of the file.  Returns the new position.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#file_open">file_open</a>).<br>seek_offset:=&nbsp;byte&nbsp;offset.<br>&nbsp;&nbsp;seek_from:=&nbsp;FROM_START,&nbsp;FROM_CURRENT,&nbsp;or&nbsp;FROM_END.<br></samp><br><br><b><small>Example</small></b><br><br><code>new_pos&nbsp;=&nbsp;pi.file_seek(h,&nbsp;100,&nbsp;pigpio.FROM_START)<br><br>cur_pos&nbsp;=&nbsp;pi.file_seek(h,&nbsp;0,&nbsp;pigpio.FROM_CURRENT)<br><br>file_size&nbsp;=&nbsp;pi.file_seek(h,&nbsp;0,&nbsp;pigpio.FROM_END)<br></code><h3><a name="file_write">file_write<small>(<a href="#handle">handle</a>, <a href="#data">data</a>)</small></h3>
Writes the data bytes to the file associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#file_open">file_open</a>).<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.file_write(h1,&nbsp;b'\x02\x03\x04')<br><br>pi.file_write(h2,&nbsp;b'help')<br><br>pi.file_write(h2,&nbsp;"hello")<br><br>pi.file_write(h1,&nbsp;[2,&nbsp;3,&nbsp;4])<br></code><h3><a name="get_PWM_dutycycle">get_PWM_dutycycle<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the PWM dutycycle being used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br></samp><br><br>Returns the PWM dutycycle.
<br><br>For normal PWM the dutycycle will be out of the defined range
for the GPIO (see <a href="#get_PWM_range">get_PWM_range</a>).
<br><br>If a hardware clock is active on the GPIO the reported
dutycycle will be 500000 (500k) out of 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported dutycycle
will be out of a 1000000 (1M).
<br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_dutycycle(4,&nbsp;25)<br>print(pi.get_PWM_dutycycle(4))<br>25<br><br>pi.set_PWM_dutycycle(4,&nbsp;203)<br>print(pi.get_PWM_dutycycle(4))<br>203<br></code><h3><a name="get_PWM_frequency">get_PWM_frequency<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the frequency of PWM being used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br></samp><br><br>Returns the frequency (in Hz) used for the GPIO.
<br><br>For normal PWM the frequency will be that defined for the GPIO
by <a href="#set_PWM_frequency">set_PWM_frequency</a>.
<br><br>If a hardware clock is active on the GPIO the reported frequency
will be that set by <a href="#hardware_clock">hardware_clock</a>.
<br><br>If hardware PWM is active on the GPIO the reported frequency
will be that set by <a href="#hardware_PWM">hardware_PWM</a>.
<br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_frequency(4,0)<br>print(pi.get_PWM_frequency(4))<br>10<br><br>pi.set_PWM_frequency(4,&nbsp;800)<br>print(pi.get_PWM_frequency(4))<br>800<br></code><h3><a name="get_PWM_range">get_PWM_range<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the range of PWM values being used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br></samp><br><br>If a hardware clock or hardware PWM is active on the GPIO
the reported range will be 1000000 (1M).
<br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_range(9,&nbsp;500)<br>print(pi.get_PWM_range(9))<br>500<br></code><h3><a name="get_PWM_real_range">get_PWM_real_range<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the real (underlying) range of PWM values being
used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br></samp><br><br>If a hardware clock is active on the GPIO the reported
real range will be 1000000 (1M).
<br><br>If hardware PWM is active on the GPIO the reported real range
will be approximately 250M divided by the set PWM frequency.
<br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_frequency(4,&nbsp;800)<br>print(pi.get_PWM_real_range(4))<br>250<br></code><h3><a name="get_current_tick">get_current_tick<small>()</small></h3>
Returns the current system tick.
<br><br>Tick is the number of microseconds since system boot.  As an
unsigned 32 bit quantity tick wraps around approximately
every 71.6 minutes.
<br><br><b><small>Example</small></b><br><br><code>t1&nbsp;=&nbsp;pi.get_current_tick()<br>time.sleep(1)<br>t2&nbsp;=&nbsp;pi.get_current_tick()<br></code><h3><a name="get_hardware_revision">get_hardware_revision<small>()</small></h3>
Returns the Pi's hardware revision number.
<br><br>The hardware revision is the last few characters on the
Revision line of /proc/cpuinfo.
<br><br>The revision number can be used to determine the assignment
of GPIO to pins (see <a href="#gpio">gpio</a>).
<br><br>There are at least three types of board.
<br><br>Type 1 boards have hardware revision numbers of 2 and 3.
<br><br>Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.
<br><br>Type 3 boards have hardware revision numbers of 16 or greater.
<br><br>If the hardware revision can not be found or is not a valid
hexadecimal number the function returns 0.
<br><br><b><small>Example</small></b><br><br><code>print(pi.get_hardware_revision())<br>2<br></code><h3><a name="get_mode">get_mode<small>(<a href="#gpio">gpio</a>)</small></h3>
Returns the GPIO mode.
<br><br><b><small>Parameters</small></b><br><br><samp>gpio:=&nbsp;0-53.<br></samp><br><br>Returns a value as follows
<br><br><code>0&nbsp;=&nbsp;INPUT<br>1&nbsp;=&nbsp;OUTPUT<br>2&nbsp;=&nbsp;ALT5<br>3&nbsp;=&nbsp;ALT4<br>4&nbsp;=&nbsp;ALT0<br>5&nbsp;=&nbsp;ALT1<br>6&nbsp;=&nbsp;ALT2<br>7&nbsp;=&nbsp;ALT3<br></code><br><br><b><small>Example</small></b><br><br><code>print(pi.get_mode(0))<br>4<br></code><h3><a name="get_pad_strength">get_pad_strength<small>(<a href="#pad">pad</a>)</small></h3>
This function returns the pad drive strength in mA.
<br><br><b><small>Parameters</small></b><br><br><samp>pad:=&nbsp;0-2,&nbsp;the&nbsp;pad&nbsp;to&nbsp;get.<br></samp><br><br>Returns the pad drive strength if OK, otherwise PI_BAD_PAD.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>strength&nbsp;=&nbsp;pi.get_pad_strength(0)&nbsp;#&nbsp;Get&nbsp;pad&nbsp;0&nbsp;strength.<br></code><h3><a name="get_pigpio_version">get_pigpio_version<small>()</small></h3>
Returns the pigpio software version.
<br><br><b><small>Example</small></b><br><br><code>v&nbsp;=&nbsp;pi.get_pigpio_version()<br></code><h3><a name="get_servo_pulsewidth">get_servo_pulsewidth<small>(<a href="#user_gpio">user_gpio</a>)</small></h3>
Returns the servo pulsewidth being used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br></samp><br><br>Returns the servo pulsewidth.
<br><br><b><small>Example</small></b><br><br><code>pi.set_servo_pulsewidth(4,&nbsp;525)<br>print(pi.get_servo_pulsewidth(4))<br>525<br><br>pi.set_servo_pulsewidth(4,&nbsp;2130)<br>print(pi.get_servo_pulsewidth(4))<br>2130<br></code><h3><a name="gpio_trigger">gpio_trigger<small>(<a href="#user_gpio">user_gpio</a>, <a href="#pulse_len">pulse_len</a>, <a href="#level">level</a>)</small></h3>
Send a trigger pulse to a GPIO.  The GPIO is set to
level for pulse_len microseconds and then reset to not level.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31<br>pulse_len:=&nbsp;1-100<br>&nbsp;&nbsp;&nbsp;&nbsp;level:=&nbsp;0-1<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.gpio_trigger(23,&nbsp;10,&nbsp;1)<br></code><h3><a name="hardware_PWM">hardware_PWM<small>(<a href="#gpio">gpio</a>, <a href="#PWMfreq">PWMfreq</a>, <a href="#PWMduty">PWMduty</a>)</small></h3>
Starts hardware PWM on a GPIO at the specified frequency
and dutycycle. Frequencies above 30MHz are unlikely to work.
<br><br>NOTE: Any waveform started by <a href="#wave_send_once">wave_send_once</a>,
<a href="#wave_send_repeat">wave_send_repeat</a>, or <a href="#wave_chain">wave_chain</a> will be cancelled.
<br><br>This function is only valid if the pigpio main clock is PCM.
The main clock defaults to PCM but may be overridden when the
pigpio daemon is started (option -t).
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;gpio:=&nbsp;see&nbsp;descripton<br>PWMfreq:=&nbsp;0&nbsp;(off)&nbsp;or&nbsp;1-125M&nbsp;(1-187.5M&nbsp;for&nbsp;the&nbsp;BCM2711).<br>PWMduty:=&nbsp;0&nbsp;(off)&nbsp;to&nbsp;1000000&nbsp;(1M)(fully&nbsp;on).<br></samp><br><br>Returns 0 if OK, otherwise PI_NOT_PERMITTED, PI_BAD_GPIO,
PI_NOT_HPWM_GPIO, PI_BAD_HPWM_DUTY, PI_BAD_HPWM_FREQ.
<br><br>The same PWM channel is available on multiple GPIO.
The latest frequency and dutycycle setting will be used
by all GPIO which share a PWM channel.
<br><br>The GPIO must be one of the following:
<br><br><code>12&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>13&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>18&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;All&nbsp;models<br>19&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br><br>40&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>41&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>45&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>52&nbsp;&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>53&nbsp;&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br></code><br><br>The actual number of steps beween off and fully on is the
integral part of 250M/PWMfreq (375M/PWMfreq for the BCM2711).
<br><br>The actual frequency set is 250M/steps (375M/steps
for the BCM2711).
<br><br>There will only be a million steps for a PWMfreq of 250
(375 for the BCM2711). Lower frequencies will have more
steps and higher frequencies will have fewer steps.
PWMduty is automatically scaled to take this into account.
<br><br><b><small>Example</small></b><br><br><code>pi.hardware_PWM(18,&nbsp;800,&nbsp;250000)&nbsp;#&nbsp;800Hz&nbsp;25%&nbsp;dutycycle<br><br>pi.hardware_PWM(18,&nbsp;2000,&nbsp;750000)&nbsp;#&nbsp;2000Hz&nbsp;75%&nbsp;dutycycle<br></code><h3><a name="hardware_clock">hardware_clock<small>(<a href="#gpio">gpio</a>, <a href="#clkfreq">clkfreq</a>)</small></h3>
Starts a hardware clock on a GPIO at the specified frequency.
Frequencies above 30MHz are unlikely to work.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;gpio:=&nbsp;see&nbsp;description<br>clkfreq:=&nbsp;0&nbsp;(off)&nbsp;or&nbsp;4689-250M&nbsp;(13184-375M&nbsp;for&nbsp;the&nbsp;BCM2711)<br></samp><br><br>Returns 0 if OK, otherwise PI_NOT_PERMITTED, PI_BAD_GPIO,
PI_NOT_HCLK_GPIO, PI_BAD_HCLK_FREQ,or PI_BAD_HCLK_PASS.
<br><br>The same clock is available on multiple GPIO.  The latest
frequency setting will be used by all GPIO which share a clock.
<br><br>The GPIO must be one of the following:
<br><br><code>4&nbsp;&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;All&nbsp;models<br>5&nbsp;&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br>6&nbsp;&nbsp;&nbsp;clock&nbsp;2&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>20&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;B<br>21&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;All&nbsp;models&nbsp;but&nbsp;A&nbsp;and&nbsp;Rev.2&nbsp;B&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br><br>32&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>34&nbsp;&nbsp;clock&nbsp;0&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>42&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br>43&nbsp;&nbsp;clock&nbsp;2&nbsp;&nbsp;Compute&nbsp;module&nbsp;only<br>44&nbsp;&nbsp;clock&nbsp;1&nbsp;&nbsp;Compute&nbsp;module&nbsp;only&nbsp;(reserved&nbsp;for&nbsp;system&nbsp;use)<br></code><br><br>Access to clock 1 is protected by a password as its use will
likely crash the Pi.  The password is given by or'ing 0x5A000000
with the GPIO number.
<br><br><b><small>Example</small></b><br><br><code>pi.hardware_clock(4,&nbsp;5000)&nbsp;#&nbsp;5&nbsp;KHz&nbsp;clock&nbsp;on&nbsp;GPIO&nbsp;4<br><br>pi.hardware_clock(4,&nbsp;40000000)&nbsp;#&nbsp;40&nbsp;MHz&nbsp;clock&nbsp;on&nbsp;GPIO&nbsp;4<br></code><h3><a name="i2c_block_process_call">i2c_block_process_call<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#data">data</a>)</small></h3>
Writes data bytes to the specified register of the device
associated with handle and reads a device specified number
of bytes of data in return.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br>The SMBus 2.0 documentation states that a minimum of 1 byte may
be sent and a minimum of 1 byte may be received.  The total
number of bytes sent/received must be 32 or less.
<br><br>SMBus 2.0 5.5.8 - Block write-block read.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;len(data)&nbsp;[A]&nbsp;data0&nbsp;[A]&nbsp;...&nbsp;datan&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Count]&nbsp;A&nbsp;[Data]&nbsp;...&nbsp;A&nbsp;P<br></code><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(b,&nbsp;d)&nbsp;=&nbsp;pi.i2c_block_process_call(h,&nbsp;10,&nbsp;b'\x02\x05\x00')<br><br>(b,&nbsp;d)&nbsp;=&nbsp;pi.i2c_block_process_call(h,&nbsp;10,&nbsp;b'abcdr')<br><br>(b,&nbsp;d)&nbsp;=&nbsp;pi.i2c_block_process_call(h,&nbsp;10,&nbsp;"abracad")<br><br>(b,&nbsp;d)&nbsp;=&nbsp;pi.i2c_block_process_call(h,&nbsp;10,&nbsp;[2,&nbsp;5,&nbsp;16])<br></code><h3><a name="i2c_close">i2c_close<small>(<a href="#handle">handle</a>)</small></h3>
Closes the I2C device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.i2c_close(h)<br></code><h3><a name="i2c_open">i2c_open<small>(<a href="#i2c_bus">i2c_bus</a>, <a href="#i2c_address">i2c_address</a>, <a href="#i2c_flags">i2c_flags</a>)</small></h3>
Returns a handle (&gt;=0) for the device at the I2C bus address.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;&nbsp;i2c_bus:=&nbsp;&gt;=0.<br>i2c_address:=&nbsp;0-0x7F.<br>&nbsp;&nbsp;i2c_flags:=&nbsp;0,&nbsp;no&nbsp;flags&nbsp;are&nbsp;currently&nbsp;defined.<br></samp><br><br>Physically buses 0 and 1 are available on the Pi.  Higher
numbered buses will be available if a kernel supported bus
multiplexor is being used.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>SDA</td><td>SCL</td></tr><tr><td>I2C 0</td><td>0</td><td>1</td></tr><tr><td>I2C 1</td><td>2</td><td>3</td></tr></tbody></table><br><br>For the SMBus commands the low level transactions are shown
at the end of the function description.  The following
abbreviations are used:
<br><br><code>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Start&nbsp;bit<br>P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Stop&nbsp;bit<br>Rd/Wr&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Read/Write&nbsp;bit.&nbsp;Rd&nbsp;equals&nbsp;1,&nbsp;Wr&nbsp;equals&nbsp;0.<br>A,&nbsp;NA&nbsp;(1&nbsp;bit)&nbsp;:&nbsp;Accept&nbsp;and&nbsp;not&nbsp;accept&nbsp;bit.<br>Addr&nbsp;&nbsp;(7&nbsp;bits):&nbsp;I2C&nbsp;7&nbsp;bit&nbsp;address.<br>reg&nbsp;&nbsp;&nbsp;(8&nbsp;bits):&nbsp;Command&nbsp;byte,&nbsp;which&nbsp;often&nbsp;selects&nbsp;a&nbsp;register.<br>Data&nbsp;&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;data&nbsp;byte.<br>Count&nbsp;(8&nbsp;bits):&nbsp;A&nbsp;byte&nbsp;defining&nbsp;the&nbsp;length&nbsp;of&nbsp;a&nbsp;block&nbsp;operation.<br><br>[..]:&nbsp;Data&nbsp;sent&nbsp;by&nbsp;the&nbsp;device.<br></code><br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.i2c_open(1,&nbsp;0x53)&nbsp;#&nbsp;open&nbsp;device&nbsp;at&nbsp;address&nbsp;0x53&nbsp;on&nbsp;bus&nbsp;1<br></code><h3><a name="i2c_process_call">i2c_process_call<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#word_val">word_val</a>)</small></h3>
Writes 16 bits of data to the specified register of the device
associated with handle and reads 16 bits of data in return.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>word_val:=&nbsp;0-65535,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></samp><br><br>SMBus 2.0 5.5.6 - Process call.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;word_val_Low&nbsp;[A]&nbsp;word_val_High&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[DataLow]&nbsp;A&nbsp;[DataHigh]&nbsp;NA&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>r&nbsp;=&nbsp;pi.i2c_process_call(h,&nbsp;4,&nbsp;0x1231)<br>r&nbsp;=&nbsp;pi.i2c_process_call(h,&nbsp;6,&nbsp;0)<br></code><h3><a name="i2c_read_block_data">i2c_read_block_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>)</small></h3>
Reads a block of up to 32 bytes from the specified register of
the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br></samp><br><br>SMBus 2.0 5.5.7 - Block read.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Count]&nbsp;A&nbsp;[Data]&nbsp;A&nbsp;[Data]&nbsp;A&nbsp;...&nbsp;A&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><br><br>The amount of returned data is set by the device.
<br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(b,&nbsp;d)&nbsp;=&nbsp;pi.i2c_read_block_data(h,&nbsp;10)<br>if&nbsp;b&nbsp;&gt;=&nbsp;0:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;data<br>else:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;read&nbsp;failure<br></code><h3><a name="i2c_read_byte">i2c_read_byte<small>(<a href="#handle">handle</a>)</small></h3>
Reads a single byte from the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br></samp><br><br>SMBus 2.0 5.5.3 - Receive byte.
<code>S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>b&nbsp;=&nbsp;pi.i2c_read_byte(2)&nbsp;#&nbsp;read&nbsp;a&nbsp;byte&nbsp;from&nbsp;device&nbsp;2<br></code><h3><a name="i2c_read_byte_data">i2c_read_byte_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>)</small></h3>
Reads a single byte from the specified register of the device
associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br></samp><br><br>SMBus 2.0 5.5.5 - Read byte.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>#&nbsp;read&nbsp;byte&nbsp;from&nbsp;reg&nbsp;17&nbsp;of&nbsp;device&nbsp;2<br>b&nbsp;=&nbsp;pi.i2c_read_byte_data(2,&nbsp;17)<br><br>#&nbsp;read&nbsp;byte&nbsp;from&nbsp;reg&nbsp;&nbsp;1&nbsp;of&nbsp;device&nbsp;0<br>b&nbsp;=&nbsp;pi.i2c_read_byte_data(0,&nbsp;1)<br></code><h3><a name="i2c_read_device">i2c_read_device<small>(<a href="#handle">handle</a>, <a href="#count">count</a>)</small></h3>
Returns count bytes read from the raw device associated
with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;count:=&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></samp><br><br><code>S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;A&nbsp;[Data]&nbsp;A&nbsp;...&nbsp;A&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(count,&nbsp;data)&nbsp;=&nbsp;pi.i2c_read_device(h,&nbsp;12)<br></code><h3><a name="i2c_read_i2c_block_data">i2c_read_i2c_block_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#count">count</a>)</small></h3>
Reads count bytes from the specified register of the device
associated with handle .  The count may be 1-32.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>&nbsp;count:=&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></samp><br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[Data]&nbsp;A&nbsp;[Data]&nbsp;A&nbsp;...&nbsp;A&nbsp;[Data]&nbsp;NA&nbsp;P<br></code><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(b,&nbsp;d)&nbsp;=&nbsp;pi.i2c_read_i2c_block_data(h,&nbsp;4,&nbsp;32)<br>if&nbsp;b&nbsp;&gt;=&nbsp;0:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;data<br>else:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;read&nbsp;failure<br></code><h3><a name="i2c_read_word_data">i2c_read_word_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>)</small></h3>
Reads a single 16 bit word from the specified register of the
device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br></samp><br><br>SMBus 2.0 5.5.5 - Read word.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;S&nbsp;Addr&nbsp;Rd&nbsp;[A]&nbsp;[DataLow]&nbsp;A&nbsp;[DataHigh]&nbsp;NA&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>#&nbsp;read&nbsp;word&nbsp;from&nbsp;reg&nbsp;2&nbsp;of&nbsp;device&nbsp;3<br>w&nbsp;=&nbsp;pi.i2c_read_word_data(3,&nbsp;2)<br><br>#&nbsp;read&nbsp;word&nbsp;from&nbsp;reg&nbsp;7&nbsp;of&nbsp;device&nbsp;2<br>w&nbsp;=&nbsp;pi.i2c_read_word_data(2,&nbsp;7)<br></code><h3><a name="i2c_write_block_data">i2c_write_block_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#data">data</a>)</small></h3>
Writes up to 32 bytes to the specified register of the device
associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br>SMBus 2.0 5.5.7 - Block write.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;len(data)&nbsp;[A]&nbsp;data0&nbsp;[A]&nbsp;data1&nbsp;[A]&nbsp;...&nbsp;[A]<br>&nbsp;&nbsp;&nbsp;datan&nbsp;[A]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>pi.i2c_write_block_data(4,&nbsp;5,&nbsp;b'hello')<br><br>pi.i2c_write_block_data(4,&nbsp;5,&nbsp;"data&nbsp;bytes")<br><br>pi.i2c_write_block_data(5,&nbsp;0,&nbsp;b'\x00\x01\x22')<br><br>pi.i2c_write_block_data(6,&nbsp;2,&nbsp;[0,&nbsp;1,&nbsp;0x22])<br></code><h3><a name="i2c_write_byte">i2c_write_byte<small>(<a href="#handle">handle</a>, <a href="#byte_val">byte_val</a>)</small></h3>
Sends a single byte to the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>byte_val:=&nbsp;0-255,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></samp><br><br>SMBus 2.0 5.5.2 - Send byte.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;byte_val&nbsp;[A]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>pi.i2c_write_byte(1,&nbsp;17)&nbsp;&nbsp;&nbsp;#&nbsp;send&nbsp;byte&nbsp;&nbsp;&nbsp;17&nbsp;to&nbsp;device&nbsp;1<br>pi.i2c_write_byte(2,&nbsp;0x23)&nbsp;#&nbsp;send&nbsp;byte&nbsp;0x23&nbsp;to&nbsp;device&nbsp;2<br></code><h3><a name="i2c_write_byte_data">i2c_write_byte_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#byte_val">byte_val</a>)</small></h3>
Writes a single byte to the specified register of the device
associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>byte_val:=&nbsp;0-255,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></samp><br><br>SMBus 2.0 5.5.4 - Write byte.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;byte_val&nbsp;[A]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>#&nbsp;send&nbsp;byte&nbsp;0xC5&nbsp;to&nbsp;reg&nbsp;2&nbsp;of&nbsp;device&nbsp;1<br>pi.i2c_write_byte_data(1,&nbsp;2,&nbsp;0xC5)<br><br>#&nbsp;send&nbsp;byte&nbsp;9&nbsp;to&nbsp;reg&nbsp;4&nbsp;of&nbsp;device&nbsp;2<br>pi.i2c_write_byte_data(2,&nbsp;4,&nbsp;9)<br></code><h3><a name="i2c_write_device">i2c_write_device<small>(<a href="#handle">handle</a>, <a href="#data">data</a>)</small></h3>
Writes the data bytes to the raw device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;data0&nbsp;[A]&nbsp;data1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;datan&nbsp;[A]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>pi.i2c_write_device(h,&nbsp;b"\x12\x34\xA8")<br><br>pi.i2c_write_device(h,&nbsp;b"help")<br><br>pi.i2c_write_device(h,&nbsp;'help')<br><br>pi.i2c_write_device(h,&nbsp;[23,&nbsp;56,&nbsp;231])<br></code><h3><a name="i2c_write_i2c_block_data">i2c_write_i2c_block_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#data">data</a>)</small></h3>
Writes data bytes to the specified register of the device
associated with handle .  1-32 bytes may be written.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br><code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;data0&nbsp;[A]&nbsp;data1&nbsp;[A]&nbsp;...&nbsp;[A]&nbsp;datan&nbsp;[NA]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>pi.i2c_write_i2c_block_data(4,&nbsp;5,&nbsp;'hello')<br><br>pi.i2c_write_i2c_block_data(4,&nbsp;5,&nbsp;b'hello')<br><br>pi.i2c_write_i2c_block_data(5,&nbsp;0,&nbsp;b'\x00\x01\x22')<br><br>pi.i2c_write_i2c_block_data(6,&nbsp;2,&nbsp;[0,&nbsp;1,&nbsp;0x22])<br></code><h3><a name="i2c_write_quick">i2c_write_quick<small>(<a href="#handle">handle</a>, <a href="#bit">bit</a>)</small></h3>
Sends a single bit to the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;bit:=&nbsp;0&nbsp;or&nbsp;1,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></samp><br><br>SMBus 2.0 5.5.1 - Quick command.
<code>S&nbsp;Addr&nbsp;bit&nbsp;[A]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>pi.i2c_write_quick(0,&nbsp;1)&nbsp;#&nbsp;send&nbsp;1&nbsp;to&nbsp;device&nbsp;0<br>pi.i2c_write_quick(3,&nbsp;0)&nbsp;#&nbsp;send&nbsp;0&nbsp;to&nbsp;device&nbsp;3<br></code><h3><a name="i2c_write_word_data">i2c_write_word_data<small>(<a href="#handle">handle</a>, <a href="#reg">reg</a>, <a href="#word_val">word_val</a>)</small></h3>
Writes a single 16 bit word to the specified register of the
device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg:=&nbsp;&gt;=0,&nbsp;the&nbsp;device&nbsp;register.<br>word_val:=&nbsp;0-65535,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></samp><br><br>SMBus 2.0 5.5.4 - Write word.
<code>S&nbsp;Addr&nbsp;Wr&nbsp;[A]&nbsp;reg&nbsp;[A]&nbsp;word_val_Low&nbsp;[A]&nbsp;word_val_High&nbsp;[A]&nbsp;P<br></code><br><br><b><small>Example</small></b><br><br><code>#&nbsp;send&nbsp;word&nbsp;0xA0C5&nbsp;to&nbsp;reg&nbsp;5&nbsp;of&nbsp;device&nbsp;4<br>pi.i2c_write_word_data(4,&nbsp;5,&nbsp;0xA0C5)<br><br>#&nbsp;send&nbsp;word&nbsp;2&nbsp;to&nbsp;reg&nbsp;2&nbsp;of&nbsp;device&nbsp;5<br>pi.i2c_write_word_data(5,&nbsp;2,&nbsp;23)<br></code><h3><a name="i2c_zip">i2c_zip<small>(<a href="#handle">handle</a>, <a href="#data">data</a>)</small></h3>
This function executes a sequence of I2C operations.  The
operations to be performed are specified by the contents of data
which contains the concatenated command codes and associated data.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#i2c_open">i2c_open</a>).<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;concatenated&nbsp;I2C&nbsp;commands,&nbsp;see&nbsp;below<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(count,&nbsp;data)&nbsp;=&nbsp;pi.i2c_zip(h,&nbsp;[4,&nbsp;0x53,&nbsp;7,&nbsp;1,&nbsp;0x32,&nbsp;6,&nbsp;6,&nbsp;0])<br></code><br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>End</td><td>0</td><td>No more commands</td></tr><tr><td>Escape</td><td>1</td><td>Next P is two bytes</td></tr><tr><td>On</td><td>2</td><td>Switch combined flag on</td></tr><tr><td>Off</td><td>3</td><td>Switch combined flag off</td></tr><tr><td>Address</td><td>4 P</td><td>Set I2C address to P</td></tr><tr><td>Flags</td><td>5 lsb msb</td><td>Set I2C flags to lsb + (msb &lt;&lt; 8)</td></tr><tr><td>Read</td><td>6 P</td><td>Read P bytes of data</td></tr><tr><td>Write</td><td>7 P ...</td><td>Write P bytes of data</td></tr></tbody></table><br><br>The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).
<br><br>The address defaults to that associated with the handle.
The flags default to 0.  The address and flags maintain their
previous value until updated.
<br><br>Any read I2C data is concatenated in the returned bytearray.
<br><br><b><small>Example</small></b><br><br><code>Set&nbsp;address&nbsp;0x53,&nbsp;write&nbsp;0x32,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x1E,&nbsp;write&nbsp;0x03,&nbsp;read&nbsp;6&nbsp;bytes<br>Set&nbsp;address&nbsp;0x68,&nbsp;write&nbsp;0x1B,&nbsp;read&nbsp;8&nbsp;bytes<br>End<br><br>0x04&nbsp;0x53&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x32&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x1E&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x03&nbsp;&nbsp;&nbsp;0x06&nbsp;0x06<br>0x04&nbsp;0x68&nbsp;&nbsp;&nbsp;0x07&nbsp;0x01&nbsp;0x1B&nbsp;&nbsp;&nbsp;0x06&nbsp;0x08<br>0x00<br></code><h3><a name="notify_begin">notify_begin<small>(<a href="#handle">handle</a>, <a href="#bits">bits</a>)</small></h3>
Starts notifications on a handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#notify_open">notify_open</a>)<br>&nbsp;&nbsp;bits:=&nbsp;a&nbsp;32&nbsp;bit&nbsp;mask&nbsp;indicating&nbsp;the&nbsp;GPIO&nbsp;to&nbsp;be&nbsp;notified.<br></samp><br><br>The notification sends state changes for each GPIO whose
corresponding bit in bits is set.
<br><br>The following code starts notifications for GPIO 1, 4,
6, 7, and 10 (1234 = 0x04D2 = 0b0000010011010010).
<br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.notify_open()<br>if&nbsp;h&nbsp;&gt;=&nbsp;0:<br>&nbsp;&nbsp;&nbsp;pi.notify_begin(h,&nbsp;1234)<br></code><h3><a name="notify_close">notify_close<small>(<a href="#handle">handle</a>)</small></h3>
Stops notifications on a handle and releases the handle for reuse.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#notify_open">notify_open</a>)<br></samp><br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.notify_open()<br>if&nbsp;h&nbsp;&gt;=&nbsp;0:<br>&nbsp;&nbsp;&nbsp;pi.notify_begin(h,&nbsp;1234)<br>&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;pi.notify_close(h)<br>&nbsp;&nbsp;&nbsp;...<br></code><h3><a name="notify_open">notify_open<small>()</small></h3>
Returns a notification handle (&gt;=0).
<br><br>A notification is a method for being notified of GPIO state
changes via a pipe.
<br><br>Pipes are only accessible from the local machine so this
function serves no purpose if you are using Python from a
remote machine.  The in-built (socket) notifications
provided by <a href="#callback">callback</a> should be used instead.
<br><br>Notifications for handle x will be available at the pipe
named /dev/pigpiox (where x is the handle number).
<br><br>E.g. if the function returns 15 then the notifications must be
read from /dev/pigpio15.
<br><br>Notifications have the following structure:
<br><br><code>H&nbsp;seqno<br>H&nbsp;flags<br>I&nbsp;tick<br>I&nbsp;level<br></code><br><br>seqno: starts at 0 each time the handle is opened and then
increments by one for each report.
<br><br>flags: three flags are defined, PI_NTFY_FLAGS_WDOG,
PI_NTFY_FLAGS_ALIVE, and PI_NTFY_FLAGS_EVENT.
<br><br>If bit 5 is set (PI_NTFY_FLAGS_WDOG) then bits 0-4 of the
flags indicate a GPIO which has had a watchdog timeout.
<br><br>If bit 6 is set (PI_NTFY_FLAGS_ALIVE) this indicates a keep
alive signal on the pipe/socket and is sent once a minute
in the absence of other notification activity.
<br><br>If bit 7 is set (PI_NTFY_FLAGS_EVENT) then bits 0-4 of the
flags indicate an event which has been triggered.
<br><br>tick: the number of microseconds since system boot.  It wraps
around after 1h12m.
<br><br>level: indicates the level of each GPIO.  If bit 1&lt;&lt;x is set
then GPIO x is high.
<br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.notify_open()<br>if&nbsp;h&nbsp;&gt;=&nbsp;0:<br>&nbsp;&nbsp;&nbsp;pi.notify_begin(h,&nbsp;1234)<br></code><h3><a name="notify_pause">notify_pause<small>(<a href="#handle">handle</a>)</small></h3>
Pauses notifications on a handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#notify_open">notify_open</a>)<br></samp><br><br>Notifications for the handle are suspended until
<a href="#notify_begin">notify_begin</a> is called again.
<br><br><b><small>Example</small></b><br><br><code>h&nbsp;=&nbsp;pi.notify_open()<br>if&nbsp;h&nbsp;&gt;=&nbsp;0:<br>&nbsp;&nbsp;&nbsp;pi.notify_begin(h,&nbsp;1234)<br>&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;pi.notify_pause(h)<br>&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;pi.notify_begin(h,&nbsp;1234)<br>&nbsp;&nbsp;&nbsp;...<br></code><h3><a name="read">read<small>(<a href="#gpio">gpio</a>)</small></h3>
Returns the GPIO level.
<br><br><b><small>Parameters</small></b><br><br><samp>gpio:=&nbsp;0-53.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.set_mode(23,&nbsp;pigpio.INPUT)<br><br>pi.set_pull_up_down(23,&nbsp;pigpio.PUD_DOWN)<br>print(pi.read(23))<br>0<br><br>pi.set_pull_up_down(23,&nbsp;pigpio.PUD_UP)<br>print(pi.read(23))<br>1<br></code><h3><a name="read_bank_1">read_bank_1<small>()</small></h3>
Returns the levels of the bank 1 GPIO (GPIO 0-31).
<br><br>The returned 32 bit integer has a bit set if the corresponding
GPIO is high.  GPIO n has bit value (1&lt;&lt;n).
<br><br><b><small>Example</small></b><br><br><code>print(bin(pi.read_bank_1()))<br>0b10010100000011100100001001111<br></code><h3><a name="read_bank_2">read_bank_2<small>()</small></h3>
Returns the levels of the bank 2 GPIO (GPIO 32-53).
<br><br>The returned 32 bit integer has a bit set if the corresponding
GPIO is high.  GPIO n has bit value (1&lt;&lt;(n-32)).
<br><br><b><small>Example</small></b><br><br><code>print(bin(pi.read_bank_2()))<br>0b1111110000000000000000<br></code><h3><a name="run_script">run_script<small>(<a href="#script_id">script_id</a>, <a href="#params">params</a>)</small></h3>
Runs a stored script.
<br><br><b><small>Parameters</small></b><br><br><samp>script_id:=&nbsp;id&nbsp;of&nbsp;stored&nbsp;script.<br>&nbsp;&nbsp;&nbsp;params:=&nbsp;up&nbsp;to&nbsp;10&nbsp;parameters&nbsp;required&nbsp;by&nbsp;the&nbsp;script.<br></samp><br><br><b><small>Example</small></b><br><br><code>s&nbsp;=&nbsp;pi.run_script(sid,&nbsp;[par1,&nbsp;par2])<br><br>s&nbsp;=&nbsp;pi.run_script(sid)<br><br>s&nbsp;=&nbsp;pi.run_script(sid,&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10])<br></code><h3><a name="script_status">script_status<small>(<a href="#script_id">script_id</a>)</small></h3>
Returns the run status of a stored script as well as the
current values of parameters 0 to 9.
<br><br><b><small>Parameters</small></b><br><br><samp>script_id:=&nbsp;id&nbsp;of&nbsp;stored&nbsp;script.<br></samp><br><br>The run status may be
<br><br><code>PI_SCRIPT_INITING<br>PI_SCRIPT_HALTED<br>PI_SCRIPT_RUNNING<br>PI_SCRIPT_WAITING<br>PI_SCRIPT_FAILED<br></code><br><br>The return value is a tuple of run status and a list of
the 10 parameters.  On error the run status will be negative
and the parameter list will be empty.
<br><br><b><small>Example</small></b><br><br><code>(s,&nbsp;pars)&nbsp;=&nbsp;pi.script_status(sid)<br></code><h3><a name="serial_close">serial_close<small>(<a href="#handle">handle</a>)</small></h3>
Closes the serial device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>).<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.serial_close(h1)<br></code><h3><a name="serial_data_available">serial_data_available<small>(<a href="#handle">handle</a>)</small></h3>
Returns the number of bytes available to be read from the
device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>).<br></samp><br><br><b><small>Example</small></b><br><br><code>rdy&nbsp;=&nbsp;pi.serial_data_available(h1)<br><br>if&nbsp;rdy&nbsp;&gt;&nbsp;0:<br>&nbsp;&nbsp;&nbsp;(b,&nbsp;d)&nbsp;=&nbsp;pi.serial_read(h1,&nbsp;rdy)<br></code><h3><a name="serial_open">serial_open<small>(<a href="#tty">tty</a>, <a href="#baud">baud</a>, <a href="#ser_flags">ser_flags</a>)</small></h3>
Returns a handle for the serial tty device opened
at baud bits per second.  The device name must start
with /dev/tty or /dev/serial.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tty:=&nbsp;the&nbsp;serial&nbsp;device&nbsp;to&nbsp;open.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:=&nbsp;baud&nbsp;rate&nbsp;in&nbsp;bits&nbsp;per&nbsp;second,&nbsp;see&nbsp;below.<br>ser_flags:=&nbsp;0,&nbsp;no&nbsp;flags&nbsp;are&nbsp;currently&nbsp;defined.<br></samp><br><br>Normally you would only use the <a href="#serial_*">serial_*</a> functions if
you are or will be connecting to the Pi over a network.  If
you will always run on the local Pi use the standard serial
module instead.
<br><br>The baud rate must be one of 50, 75, 110, 134, 150,
200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200,
38400, 57600, 115200, or 230400.
<br><br><b><small>Example</small></b><br><br><code>h1&nbsp;=&nbsp;pi.serial_open("/dev/ttyAMA0",&nbsp;300)<br><br>h2&nbsp;=&nbsp;pi.serial_open("/dev/ttyUSB1",&nbsp;19200,&nbsp;0)<br><br>h3&nbsp;=&nbsp;pi.serial_open("/dev/serial0",&nbsp;9600)<br></code><h3><a name="serial_read">serial_read<small>(<a href="#handle">handle</a>, <a href="#count">count</a>)</small></h3>
Reads up to count bytes from the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>).<br>&nbsp;count:=&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read&nbsp;(defaults&nbsp;to&nbsp;1000).<br></samp><br><br>The returned value is a tuple of the number of bytes read and
a bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br>If no data is ready a bytes read of zero is returned.
<b><small>Example</small></b><br><br><code>(b,&nbsp;d)&nbsp;=&nbsp;pi.serial_read(h2,&nbsp;100)<br>if&nbsp;b&nbsp;&gt;&nbsp;0:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;read&nbsp;data<br></code><h3><a name="serial_read_byte">serial_read_byte<small>(<a href="#handle">handle</a>)</small></h3>
Returns a single byte from the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>).<br></samp><br><br>If no data is ready a negative error code will be returned.
<br><br><b><small>Example</small></b><br><br><code>b&nbsp;=&nbsp;pi.serial_read_byte(h1)<br></code><h3><a name="serial_write">serial_write<small>(<a href="#handle">handle</a>, <a href="#data">data</a>)</small></h3>
Writes the data bytes to the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>).<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.serial_write(h1,&nbsp;b'\x02\x03\x04')<br><br>pi.serial_write(h2,&nbsp;b'help')<br><br>pi.serial_write(h2,&nbsp;"hello")<br><br>pi.serial_write(h1,&nbsp;[2,&nbsp;3,&nbsp;4])<br></code><h3><a name="serial_write_byte">serial_write_byte<small>(<a href="#handle">handle</a>, <a href="#byte_val">byte_val</a>)</small></h3>
Writes a single byte to the device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#serial_open">serial_open</a>).<br>byte_val:=&nbsp;0-255,&nbsp;the&nbsp;value&nbsp;to&nbsp;write.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.serial_write_byte(h1,&nbsp;23)<br><br>pi.serial_write_byte(h1,&nbsp;ord('Z'))<br></code><h3><a name="set_PWM_dutycycle">set_PWM_dutycycle<small>(<a href="#user_gpio">user_gpio</a>, <a href="#dutycycle">dutycycle</a>)</small></h3>
Starts (non-zero dutycycle) or stops (0) PWM pulses on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br>dutycycle:=&nbsp;0-range&nbsp;(range&nbsp;defaults&nbsp;to&nbsp;255).<br></samp><br><br>The <a href="#set_PWM_range">set_PWM_range</a> function can change the default range of 255.
<br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_dutycycle(4,&nbsp;&nbsp;&nbsp;0)&nbsp;#&nbsp;PWM&nbsp;off<br>pi.set_PWM_dutycycle(4,&nbsp;&nbsp;64)&nbsp;#&nbsp;PWM&nbsp;1/4&nbsp;on<br>pi.set_PWM_dutycycle(4,&nbsp;128)&nbsp;#&nbsp;PWM&nbsp;1/2&nbsp;on<br>pi.set_PWM_dutycycle(4,&nbsp;192)&nbsp;#&nbsp;PWM&nbsp;3/4&nbsp;on<br>pi.set_PWM_dutycycle(4,&nbsp;255)&nbsp;#&nbsp;PWM&nbsp;full&nbsp;on<br></code><h3><a name="set_PWM_frequency">set_PWM_frequency<small>(<a href="#user_gpio">user_gpio</a>, <a href="#frequency">frequency</a>)</small></h3>
Sets the frequency (in Hz) of the PWM to be used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br>frequency:=&nbsp;&gt;=0&nbsp;Hz<br></samp><br><br>Returns the numerically closest frequency if OK, otherwise
PI_BAD_USER_GPIO or PI_NOT_PERMITTED.
<br><br>If PWM is currently active on the GPIO it will be switched
off and then back on at the new frequency.
<br><br>Each GPIO can be independently set to one of 18 different
PWM frequencies.
<br><br>The selectable frequencies depend upon the sample rate which
may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).  The
sample rate is set when the pigpio daemon is started.
<br><br>The frequencies for each sample rate are:
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hertz<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;40000&nbsp;20000&nbsp;10000&nbsp;8000&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1600<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1250&nbsp;&nbsp;1000&nbsp;&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;20000&nbsp;10000&nbsp;&nbsp;5000&nbsp;4000&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;800<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;625&nbsp;&nbsp;&nbsp;500&nbsp;&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;10000&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;2000&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;400<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;313&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;125&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13<br>sample<br>&nbsp;rate<br>&nbsp;(us)&nbsp;&nbsp;5:&nbsp;&nbsp;8000&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;1600&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;320<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;250&nbsp;&nbsp;&nbsp;200&nbsp;&nbsp;&nbsp;160&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8:&nbsp;&nbsp;5000&nbsp;&nbsp;2500&nbsp;&nbsp;1250&nbsp;1000&nbsp;&nbsp;625&nbsp;&nbsp;500&nbsp;&nbsp;313&nbsp;&nbsp;250&nbsp;&nbsp;200<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;156&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;6<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10:&nbsp;&nbsp;4000&nbsp;&nbsp;2000&nbsp;&nbsp;1000&nbsp;&nbsp;800&nbsp;&nbsp;500&nbsp;&nbsp;400&nbsp;&nbsp;250&nbsp;&nbsp;200&nbsp;&nbsp;160<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;125&nbsp;&nbsp;&nbsp;100&nbsp;&nbsp;&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;5<br></code><br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_frequency(4,0)<br>print(pi.get_PWM_frequency(4))<br>10<br><br>pi.set_PWM_frequency(4,100000)<br>print(pi.get_PWM_frequency(4))<br>8000<br></code><h3><a name="set_PWM_range">set_PWM_range<small>(<a href="#user_gpio">user_gpio</a>, <a href="#range_">range_</a>)</small></h3>
Sets the range of PWM values to be used on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;range_:=&nbsp;25-40000.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.set_PWM_range(9,&nbsp;100)&nbsp;&nbsp;#&nbsp;now&nbsp;&nbsp;25&nbsp;1/4,&nbsp;&nbsp;&nbsp;50&nbsp;1/2,&nbsp;&nbsp;&nbsp;75&nbsp;3/4&nbsp;on<br>pi.set_PWM_range(9,&nbsp;500)&nbsp;&nbsp;#&nbsp;now&nbsp;125&nbsp;1/4,&nbsp;&nbsp;250&nbsp;1/2,&nbsp;&nbsp;375&nbsp;3/4&nbsp;on<br>pi.set_PWM_range(9,&nbsp;3000)&nbsp;#&nbsp;now&nbsp;750&nbsp;1/4,&nbsp;1500&nbsp;1/2,&nbsp;2250&nbsp;3/4&nbsp;on<br></code><h3><a name="set_bank_1">set_bank_1<small>(<a href="#bits">bits</a>)</small></h3>
Sets GPIO 0-31 if the corresponding bit in bits is set.
<br><br><b><small>Parameters</small></b><br><br><samp>bits:=&nbsp;a&nbsp;32&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;set.<br></samp><br><br>A returned status of PI_SOME_PERMITTED indicates that the user
is not allowed to write to one or more of the GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi.set_bank_1(int("111110010000",2))<br></code><h3><a name="set_bank_2">set_bank_2<small>(<a href="#bits">bits</a>)</small></h3>
Sets GPIO 32-53 if the corresponding bit (0-21) in bits is set.
<br><br><b><small>Parameters</small></b><br><br><samp>bits:=&nbsp;a&nbsp;32&nbsp;bit&nbsp;mask&nbsp;with&nbsp;1&nbsp;set&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;GPIO&nbsp;is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;be&nbsp;set.<br></samp><br><br>A returned status of PI_SOME_PERMITTED indicates that the user
is not allowed to write to one or more of the GPIO.
<br><br><b><small>Example</small></b><br><br><code>pi.set_bank_2(0x303)<br></code><h3><a name="set_glitch_filter">set_glitch_filter<small>(<a href="#user_gpio">user_gpio</a>, <a href="#steady">steady</a>)</small></h3>
Sets a glitch filter on a GPIO.
<br><br>Level changes on the GPIO are not reported unless the level
has been stable for at least <a href="#steady">steady</a> microseconds.  The
level is then reported.  Level changes of less than <a href="#steady">steady</a>
microseconds are ignored.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;steady:=&nbsp;0-300000<br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.
<br><br>This filter affects the GPIO samples returned to callbacks set up
with <a href="#callback">callback</a> and <a href="#wait_for_edge">wait_for_edge</a>.
<br><br>It does not affect levels read by <a href="#read">read</a>,
<a href="#read_bank_1">read_bank_1</a>, or <a href="#read_bank_2">read_bank_2</a>.
<br><br>Each (stable) edge will be timestamped <a href="#steady">steady</a>
microseconds after it was first detected.
<br><br><b><small>Example</small></b><br><br><code>pi.set_glitch_filter(23,&nbsp;100)<br></code><h3><a name="set_mode">set_mode<small>(<a href="#gpio">gpio</a>, <a href="#mode">mode</a>)</small></h3>
Sets the GPIO mode.
<br><br><b><small>Parameters</small></b><br><br><samp>gpio:=&nbsp;0-53.<br>mode:=&nbsp;INPUT,&nbsp;OUTPUT,&nbsp;ALT0,&nbsp;ALT1,&nbsp;ALT2,&nbsp;ALT3,&nbsp;ALT4,&nbsp;ALT5.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.set_mode(&nbsp;4,&nbsp;pigpio.INPUT)&nbsp;&nbsp;#&nbsp;GPIO&nbsp;&nbsp;4&nbsp;as&nbsp;input<br>pi.set_mode(17,&nbsp;pigpio.OUTPUT)&nbsp;#&nbsp;GPIO&nbsp;17&nbsp;as&nbsp;output<br>pi.set_mode(24,&nbsp;pigpio.ALT2)&nbsp;&nbsp;&nbsp;#&nbsp;GPIO&nbsp;24&nbsp;as&nbsp;ALT2<br></code><h3><a name="set_noise_filter">set_noise_filter<small>(<a href="#user_gpio">user_gpio</a>, <a href="#steady">steady</a>, <a href="#active">active</a>)</small></h3>
Sets a noise filter on a GPIO.
<br><br>Level changes on the GPIO are ignored until a level which has
been stable for <a href="#steady">steady</a> microseconds is detected.  Level
changes on the GPIO are then reported for <a href="#active">active</a>
microseconds after which the process repeats.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;0-31<br>&nbsp;&nbsp;&nbsp;steady:=&nbsp;0-300000<br>&nbsp;&nbsp;&nbsp;active:=&nbsp;0-1000000<br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_USER_GPIO, or PI_BAD_FILTER.
<br><br>This filter affects the GPIO samples returned to callbacks set up
with <a href="#callback">callback</a> and <a href="#wait_for_edge">wait_for_edge</a>.
<br><br>It does not affect levels read by <a href="#read">read</a>,
<a href="#read_bank_1">read_bank_1</a>, or <a href="#read_bank_2">read_bank_2</a>.
<br><br>Level changes before and after the active period may
be reported.  Your software must be designed to cope with
such reports.
<br><br><b><small>Example</small></b><br><br><code>pi.set_noise_filter(23,&nbsp;1000,&nbsp;5000)<br></code><h3><a name="set_pad_strength">set_pad_strength<small>(<a href="#pad">pad</a>, <a href="#pad_strength">pad_strength</a>)</small></h3>
This function sets the pad drive strength in mA.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pad:=&nbsp;0-2,&nbsp;the&nbsp;pad&nbsp;to&nbsp;set.<br>pad_strength:=&nbsp;1-16&nbsp;mA.<br></samp><br><br>Returns 0 if OK, otherwise PI_BAD_PAD, or PI_BAD_STRENGTH.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>pi.set_pad_strength(2,&nbsp;14)&nbsp;#&nbsp;Set&nbsp;pad&nbsp;2&nbsp;to&nbsp;14&nbsp;mA.<br></code><h3><a name="set_pull_up_down">set_pull_up_down<small>(<a href="#gpio">gpio</a>, <a href="#pud">pud</a>)</small></h3>
Sets or clears the internal GPIO pull-up/down resistor.
<br><br><b><small>Parameters</small></b><br><br><samp>gpio:=&nbsp;0-53.<br>&nbsp;pud:=&nbsp;PUD_UP,&nbsp;PUD_DOWN,&nbsp;PUD_OFF.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.set_pull_up_down(17,&nbsp;pigpio.PUD_OFF)<br>pi.set_pull_up_down(23,&nbsp;pigpio.PUD_UP)<br>pi.set_pull_up_down(24,&nbsp;pigpio.PUD_DOWN)<br></code><h3><a name="set_servo_pulsewidth">set_servo_pulsewidth<small>(<a href="#user_gpio">user_gpio</a>, <a href="#pulsewidth">pulsewidth</a>)</small></h3>
Starts (500-2500) or stops (0) servo pulses on the GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;user_gpio:=&nbsp;0-31.<br>pulsewidth:=&nbsp;0&nbsp;(off),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500&nbsp;(most&nbsp;anti-clockwise)&nbsp;-&nbsp;2500&nbsp;(most&nbsp;clockwise).<br></samp><br><br>The selected pulsewidth will continue to be transmitted until
changed by a subsequent call to set_servo_pulsewidth.
<br><br>The pulsewidths supported by servos varies and should probably
be determined by experiment. A value of 1500 should always be
safe and represents the mid-point of rotation.
<br><br>You can DAMAGE a servo if you command it to move beyond its
limits.
<br><br><b><small>Example</small></b><br><br><code>pi.set_servo_pulsewidth(17,&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;off<br>pi.set_servo_pulsewidth(17,&nbsp;1000)&nbsp;#&nbsp;safe&nbsp;anti-clockwise<br>pi.set_servo_pulsewidth(17,&nbsp;1500)&nbsp;#&nbsp;centre<br>pi.set_servo_pulsewidth(17,&nbsp;2000)&nbsp;#&nbsp;safe&nbsp;clockwise<br></code><h3><a name="set_watchdog">set_watchdog<small>(<a href="#user_gpio">user_gpio</a>, <a href="#wdog_timeout">wdog_timeout</a>)</small></h3>
Sets a watchdog timeout for a GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;user_gpio:=&nbsp;0-31.<br>wdog_timeout:=&nbsp;0-60000.<br></samp><br><br>The watchdog is nominally in milliseconds.
<br><br>Only one watchdog may be registered per GPIO.
<br><br>The watchdog may be cancelled by setting timeout to 0.
<br><br>Once a watchdog has been started callbacks for the GPIO
will be triggered every timeout interval after the last
GPIO activity.
<br><br>The callback will receive the special level TIMEOUT.
<br><br><b><small>Example</small></b><br><br><code>pi.set_watchdog(23,&nbsp;1000)&nbsp;#&nbsp;1000&nbsp;ms&nbsp;watchdog&nbsp;on&nbsp;GPIO&nbsp;23<br>pi.set_watchdog(23,&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;cancel&nbsp;watchdog&nbsp;on&nbsp;GPIO&nbsp;23<br></code><h3><a name="shell">shell<small>(<a href="#shellscr">shellscr</a>, <a href="#pstring">pstring</a>)</small></h3>
This function uses the system call to execute a shell script
with the given string as its parameter.
<br><br><b><small>Parameters</small></b><br><br><samp>shellscr:=&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;script,&nbsp;only&nbsp;alphanumerics,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'-'&nbsp;and&nbsp;'_'&nbsp;are&nbsp;allowed&nbsp;in&nbsp;the&nbsp;name<br>pstring&nbsp;:=&nbsp;the&nbsp;parameter&nbsp;string&nbsp;to&nbsp;pass&nbsp;to&nbsp;the&nbsp;script<br></samp><br><br>The exit status of the system call is returned if OK,
otherwise PI_BAD_SHELL_STATUS.
<br><br><a href="#shellscr">shellscr</a> must exist in /opt/pigpio/cgi and must be executable.
<br><br>The returned exit status is normally 256 times that set by
the shell script exit function.  If the script can't be
found 32512 will be returned.
<br><br>The following table gives some example returned statuses:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Script exit status</td><td>Returned system call status</td></tr><tr><td>1</td><td>256</td></tr><tr><td>5</td><td>1280</td></tr><tr><td>10</td><td>2560</td></tr><tr><td>200</td><td>51200</td></tr><tr><td>script not found</td><td>32512</td></tr></tbody></table><br><br><b><small>Example</small></b><br><br><code>//&nbsp;pass&nbsp;two&nbsp;parameters,&nbsp;hello&nbsp;and&nbsp;world<br>status&nbsp;=&nbsp;pi.shell("scr1",&nbsp;"hello&nbsp;world");<br><br>//&nbsp;pass&nbsp;three&nbsp;parameters,&nbsp;hello,&nbsp;string&nbsp;with&nbsp;spaces,&nbsp;and&nbsp;world<br>status&nbsp;=&nbsp;pi.shell("scr1",&nbsp;"hello&nbsp;'string&nbsp;with&nbsp;spaces'&nbsp;world");<br><br>//&nbsp;pass&nbsp;one&nbsp;parameter,&nbsp;hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world<br>status&nbsp;=&nbsp;pi.shell("scr1",&nbsp;"\"hello&nbsp;string&nbsp;with&nbsp;spaces&nbsp;world\"");<br></code><h3><a name="spi_close">spi_close<small>(<a href="#handle">handle</a>)</small></h3>
Closes the SPI device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>).<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.spi_close(h)<br></code><h3><a name="spi_open">spi_open<small>(<a href="#spi_channel">spi_channel</a>, <a href="#baud">baud</a>, <a href="#spi_flags">spi_flags</a>)</small></h3>
Returns a handle for the SPI device on the channel.  Data
will be transferred at baud bits per second.  The flags
may be used to modify the default behaviour of 4-wire
operation, mode 0, active low chip select.
<br><br>The Pi has two SPI peripherals: main and auxiliary.
<br><br>The main SPI has two chip selects (channels), the auxiliary
has three.
<br><br>The auxiliary SPI is available on all models but the A and B.
<br><br>The GPIO used are given in the following table.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td></td><td>MISO</td><td>MOSI</td><td>SCLK</td><td>CE0</td><td>CE1</td><td>CE2</td></tr><tr><td>Main SPI</td><td>9</td><td>10</td><td>11</td><td>8</td><td>7</td><td>-</td></tr><tr><td>Aux SPI</td><td>19</td><td>20</td><td>21</td><td>18</td><td>17</td><td>16</td></tr></tbody></table><br><br><b><small>Parameters</small></b><br><br><samp>spi_channel:=&nbsp;0-1&nbsp;(0-2&nbsp;for&nbsp;the&nbsp;auxiliary&nbsp;SPI).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:=&nbsp;32K-125M&nbsp;(values&nbsp;above&nbsp;30M&nbsp;are&nbsp;unlikely&nbsp;to&nbsp;work).<br>&nbsp;&nbsp;spi_flags:=&nbsp;see&nbsp;below.<br></samp><br><br>spi_flags consists of the least significant 22 bits.
<br><br><code>21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;b&nbsp;&nbsp;R&nbsp;&nbsp;T&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;n&nbsp;&nbsp;W&nbsp;&nbsp;A&nbsp;u2&nbsp;u1&nbsp;u0&nbsp;p2&nbsp;p1&nbsp;p0&nbsp;&nbsp;m&nbsp;&nbsp;m<br></code><br><br>mm defines the SPI mode.
<br><br>WARNING: modes 1 and 3 do not appear to work on
the auxiliary SPI.
<br><br><code>Mode&nbsp;POL&nbsp;PHA<br>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;0<br>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;1<br>&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0<br>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1<br></code><br><br>px is 0 if CEx is active low (default) and 1 for active high.
<br><br>ux is 0 if the CEx GPIO is reserved for SPI (default)
and 1 otherwise.
<br><br>A is 0 for the main SPI, 1 for the auxiliary SPI.
<br><br>W is 0 if the device is not 3-wire, 1 if the device is 3-wire.
Main SPI only.
<br><br>nnnn defines the number of bytes (0-15) to write before
switching the MOSI line to MISO to read data.  This field
is ignored if W is not set.  Main SPI only.
<br><br>T is 1 if the least significant bit is transmitted on MOSI
first, the default (0) shifts the most significant bit out
first.  Auxiliary SPI only.
<br><br>R is 1 if the least significant bit is received on MISO
first, the default (0) receives the most significant bit
first.  Auxiliary SPI only.
<br><br>bbbbbb defines the word size in bits (0-32).  The default (0)
sets 8 bits per word.  Auxiliary SPI only.
<br><br>The <a href="#spi_read">spi_read</a>, <a href="#spi_write">spi_write</a>, and <a href="#spi_xfer">spi_xfer</a> functions
transfer data packed into 1, 2, or 4 bytes according to
the word size in bits.
<br><br>For bits 1-8 there will be one byte per character.
For bits 9-16 there will be two bytes per character.
For bits 17-32 there will be four bytes per character.
<br><br>Multi-byte transfers are made in least significant byte
first order.
<br><br>E.g. to transfer 32 11-bit words data should
contain 64 bytes.
<br><br>E.g. to transfer the 14 bit value 0x1ABC send the
bytes 0xBC followed by 0x1A.
<br><br>The other bits in flags should be set to zero.
<br><br><b><small>Example</small></b><br><br><code>#&nbsp;open&nbsp;SPI&nbsp;device&nbsp;on&nbsp;channel&nbsp;1&nbsp;in&nbsp;mode&nbsp;3&nbsp;at&nbsp;50000&nbsp;bits&nbsp;per&nbsp;second<br><br>h&nbsp;=&nbsp;pi.spi_open(1,&nbsp;50000,&nbsp;3)<br></code><h3><a name="spi_read">spi_read<small>(<a href="#handle">handle</a>, <a href="#count">count</a>)</small></h3>
Reads count bytes from the SPI device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>).<br>&nbsp;count:=&nbsp;&gt;0,&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;read.<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(b,&nbsp;d)&nbsp;=&nbsp;pi.spi_read(h,&nbsp;60)&nbsp;#&nbsp;read&nbsp;60&nbsp;bytes&nbsp;from&nbsp;device&nbsp;h<br>if&nbsp;b&nbsp;==&nbsp;60:<br>&nbsp;&nbsp;&nbsp;#&nbsp;process&nbsp;read&nbsp;data<br>else:<br>&nbsp;&nbsp;&nbsp;#&nbsp;error&nbsp;path<br></code><h3><a name="spi_write">spi_write<small>(<a href="#handle">handle</a>, <a href="#data">data</a>)</small></h3>
Writes the data bytes to the SPI device associated with handle.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>).<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br><b><small>Example</small></b><br><br><code>pi.spi_write(0,&nbsp;b'\x02\xc0\x80')&nbsp;#&nbsp;write&nbsp;3&nbsp;bytes&nbsp;to&nbsp;device&nbsp;0<br><br>pi.spi_write(0,&nbsp;b'defgh')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;write&nbsp;5&nbsp;bytes&nbsp;to&nbsp;device&nbsp;0<br><br>pi.spi_write(0,&nbsp;"def")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;write&nbsp;3&nbsp;bytes&nbsp;to&nbsp;device&nbsp;0<br><br>pi.spi_write(1,&nbsp;[2,&nbsp;192,&nbsp;128])&nbsp;&nbsp;&nbsp;#&nbsp;write&nbsp;3&nbsp;bytes&nbsp;to&nbsp;device&nbsp;1<br></code><h3><a name="spi_xfer">spi_xfer<small>(<a href="#handle">handle</a>, <a href="#data">data</a>)</small></h3>
Writes the data bytes to the SPI device associated with handle,
returning the data bytes read from the device.
<br><br><b><small>Parameters</small></b><br><br><samp>handle:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#spi_open">spi_open</a>).<br>&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br></samp><br><br>The returned value is a tuple of the number of bytes read and a
bytearray containing the bytes.  If there was an error the
number of bytes read will be less than zero (and will contain
the error code).
<br><br><b><small>Example</small></b><br><br><code>(count,&nbsp;rx_data)&nbsp;=&nbsp;pi.spi_xfer(h,&nbsp;b'\x01\x80\x00')<br><br>(count,&nbsp;rx_data)&nbsp;=&nbsp;pi.spi_xfer(h,&nbsp;[1,&nbsp;128,&nbsp;0])<br><br>(count,&nbsp;rx_data)&nbsp;=&nbsp;pi.spi_xfer(h,&nbsp;b"hello")<br><br>(count,&nbsp;rx_data)&nbsp;=&nbsp;pi.spi_xfer(h,&nbsp;"hello")<br></code><h3><a name="stop">stop<small>()</small></h3>
Release pigpio resources.
<br><br><b><small>Example</small></b><br><br><code>pi.stop()<br></code><h3><a name="stop_script">stop_script<small>(<a href="#script_id">script_id</a>)</small></h3>
Stops a running script.
<br><br><b><small>Parameters</small></b><br><br><samp>script_id:=&nbsp;id&nbsp;of&nbsp;stored&nbsp;script.<br></samp><br><br><b><small>Example</small></b><br><br><code>status&nbsp;=&nbsp;pi.stop_script(sid)<br></code><h3><a name="store_script">store_script<small>(<a href="#script">script</a>)</small></h3>
Store a script for later execution.
<br><br>See <a href="http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts">http://abyz.me.uk/rpi/pigpio/pigs.html#Scripts</a> for
details.
<br><br><b><small>Parameters</small></b><br><br><samp>script:=&nbsp;the&nbsp;script&nbsp;text&nbsp;as&nbsp;a&nbsp;series&nbsp;of&nbsp;bytes.<br></samp><br><br>Returns a &gt;=0 script id if OK.
<br><br><b><small>Example</small></b><br><br><code>sid&nbsp;=&nbsp;pi.store_script(<br>&nbsp;&nbsp;&nbsp;b'tag&nbsp;0&nbsp;w&nbsp;22&nbsp;1&nbsp;mils&nbsp;100&nbsp;w&nbsp;22&nbsp;0&nbsp;mils&nbsp;100&nbsp;dcr&nbsp;p0&nbsp;jp&nbsp;0')<br></code><h3><a name="update_script">update_script<small>(<a href="#script_id">script_id</a>, <a href="#params">params</a>)</small></h3>
Sets the parameters of a script.  The script may or
may not be running.  The first parameters of the script are
overwritten with the new values.
<br><br><b><small>Parameters</small></b><br><br><samp>script_id:=&nbsp;id&nbsp;of&nbsp;stored&nbsp;script.<br>&nbsp;&nbsp;&nbsp;params:=&nbsp;up&nbsp;to&nbsp;10&nbsp;parameters&nbsp;required&nbsp;by&nbsp;the&nbsp;script.<br></samp><br><br><b><small>Example</small></b><br><br><code>s&nbsp;=&nbsp;pi.update_script(sid,&nbsp;[par1,&nbsp;par2])<br><br>s&nbsp;=&nbsp;pi.update_script(sid,&nbsp;[1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;7,&nbsp;8,&nbsp;9,&nbsp;10])<br></code><h3><a name="wait_for_edge">wait_for_edge<small>(<a href="#user_gpio">user_gpio</a>, <a href="#edge">edge</a>, <a href="#wait_timeout">wait_timeout</a>)</small></h3>
Wait for an edge event on a GPIO.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;user_gpio:=&nbsp;0-31.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge:=&nbsp;EITHER_EDGE,&nbsp;RISING_EDGE&nbsp;(default),&nbsp;or<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALLING_EDGE.<br>wait_timeout:=&nbsp;&gt;=0.0&nbsp;(default&nbsp;60.0).<br></samp><br><br>The function returns when the edge is detected or after
the number of seconds specified by timeout has expired.
<br><br>Do not use this function for precise timing purposes,
the edge is only checked 20 times a second. Whenever
you need to know the accurate time of GPIO events use
a <a href="#callback">callback</a> function.
<br><br>The function returns True if the edge is detected,
otherwise False.
<br><br><b><small>Example</small></b><br><br><code>if&nbsp;pi.wait_for_edge(23):<br>&nbsp;&nbsp;&nbsp;print("Rising&nbsp;edge&nbsp;detected")<br>else:<br>&nbsp;&nbsp;&nbsp;print("wait&nbsp;for&nbsp;edge&nbsp;timed&nbsp;out")<br><br>if&nbsp;pi.wait_for_edge(23,&nbsp;pigpio.FALLING_EDGE,&nbsp;5.0):<br>&nbsp;&nbsp;&nbsp;print("Falling&nbsp;edge&nbsp;detected")<br>else:<br>&nbsp;&nbsp;&nbsp;print("wait&nbsp;for&nbsp;falling&nbsp;edge&nbsp;timed&nbsp;out")<br></code><h3><a name="wait_for_event">wait_for_event<small>(<a href="#event">event</a>, <a href="#wait_timeout">wait_timeout</a>)</small></h3>
Wait for an event.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event:=&nbsp;0-31.<br>wait_timeout:=&nbsp;&gt;=0.0&nbsp;(default&nbsp;60.0).<br></samp><br><br>The function returns when the event is signalled or after
the number of seconds specified by timeout has expired.
<br><br>The function returns True if the event is detected,
otherwise False.
<br><br><b><small>Example</small></b><br><br><code>if&nbsp;pi.wait_for_event(23):<br>&nbsp;&nbsp;&nbsp;print("event&nbsp;detected")<br>else:<br>&nbsp;&nbsp;&nbsp;print("wait&nbsp;for&nbsp;event&nbsp;timed&nbsp;out")<br></code><h3><a name="wave_add_generic">wave_add_generic<small>(<a href="#pulses">pulses</a>)</small></h3>
Adds a list of pulses to the current waveform.
<br><br><b><small>Parameters</small></b><br><br><samp>pulses:=&nbsp;list&nbsp;of&nbsp;pulses&nbsp;to&nbsp;add&nbsp;to&nbsp;the&nbsp;waveform.<br></samp><br><br>Returns the new total number of pulses in the current waveform.
<br><br>The pulses are interleaved in time order within the existing
waveform (if any).
<br><br>Merging allows the waveform to be built in parts, that is the
settings for GPIO#1 can be added, and then GPIO#2 etc.
<br><br>If the added waveform is intended to start after or within
the existing waveform then the first pulse should consist
solely of a delay.
<br><br><b><small>Example</small></b><br><br><code>G1=4<br>G2=24<br><br>pi.set_mode(G1,&nbsp;pigpio.OUTPUT)<br>pi.set_mode(G2,&nbsp;pigpio.OUTPUT)<br><br>flash_500=[]&nbsp;#&nbsp;flash&nbsp;every&nbsp;500&nbsp;ms<br>flash_100=[]&nbsp;#&nbsp;flash&nbsp;every&nbsp;100&nbsp;ms<br><br>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OFF&nbsp;&nbsp;DELAY<br><br>flash_500.append(pigpio.pulse(1&lt;&lt;G1,&nbsp;1&lt;&lt;G2,&nbsp;500000))<br>flash_500.append(pigpio.pulse(1&lt;&lt;G2,&nbsp;1&lt;&lt;G1,&nbsp;500000))<br><br>flash_100.append(pigpio.pulse(1&lt;&lt;G1,&nbsp;1&lt;&lt;G2,&nbsp;100000))<br>flash_100.append(pigpio.pulse(1&lt;&lt;G2,&nbsp;1&lt;&lt;G1,&nbsp;100000))<br><br>pi.wave_clear()&nbsp;#&nbsp;clear&nbsp;any&nbsp;existing&nbsp;waveforms<br><br>pi.wave_add_generic(flash_500)&nbsp;#&nbsp;500&nbsp;ms&nbsp;flashes<br>f500&nbsp;=&nbsp;pi.wave_create()&nbsp;#&nbsp;create&nbsp;and&nbsp;save&nbsp;id<br><br>pi.wave_add_generic(flash_100)&nbsp;#&nbsp;100&nbsp;ms&nbsp;flashes<br>f100&nbsp;=&nbsp;pi.wave_create()&nbsp;#&nbsp;create&nbsp;and&nbsp;save&nbsp;id<br><br>pi.wave_send_repeat(f500)<br><br>time.sleep(4)<br><br>pi.wave_send_repeat(f100)<br><br>time.sleep(4)<br><br>pi.wave_send_repeat(f500)<br><br>time.sleep(4)<br><br>pi.wave_tx_stop()&nbsp;#&nbsp;stop&nbsp;waveform<br><br>pi.wave_clear()&nbsp;#&nbsp;clear&nbsp;all&nbsp;waveforms<br></code><h3><a name="wave_add_new">wave_add_new<small>()</small></h3>
Starts a new empty waveform.
<br><br>You would not normally need to call this function as it is
automatically called after a waveform is created with the
<a href="#wave_create">wave_create</a> function.
<br><br><b><small>Example</small></b><br><br><code>pi.wave_add_new()<br></code><h3><a name="wave_add_serial">wave_add_serial<small>(<a href="#user_gpio">user_gpio</a>, <a href="#baud">baud</a>, <a href="#data">data</a>, <a href="#offset">offset</a>, <a href="#bb_bits">bb_bits</a>, <a href="#bb_stop">bb_stop</a>)</small></h3>
Adds a waveform representing serial data to the existing
waveform (if any).  The serial data starts <a href="#offset">offset</a>
microseconds from the start of the waveform.
<br><br><b><small>Parameters</small></b><br><br><samp>user_gpio:=&nbsp;GPIO&nbsp;to&nbsp;transmit&nbsp;data.&nbsp;&nbsp;You&nbsp;must&nbsp;set&nbsp;the&nbsp;GPIO&nbsp;mode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to&nbsp;output.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baud:=&nbsp;50-1000000&nbsp;bits&nbsp;per&nbsp;second.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data:=&nbsp;the&nbsp;bytes&nbsp;to&nbsp;write.<br>&nbsp;&nbsp;&nbsp;offset:=&nbsp;number&nbsp;of&nbsp;microseconds&nbsp;from&nbsp;the&nbsp;start&nbsp;of&nbsp;the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waveform,&nbsp;default&nbsp;0.<br>&nbsp;&nbsp;bb_bits:=&nbsp;number&nbsp;of&nbsp;data&nbsp;bits,&nbsp;default&nbsp;8.<br>&nbsp;&nbsp;bb_stop:=&nbsp;number&nbsp;of&nbsp;stop&nbsp;half&nbsp;bits,&nbsp;default&nbsp;2.<br></samp><br><br>Returns the new total number of pulses in the current waveform.
<br><br>The serial data is formatted as one start bit, <a href="#bb_bits">bb_bits</a>
data bits, and <a href="#bb_stop">bb_stop</a>/2 stop bits.
<br><br>It is legal to add serial data streams with different baud
rates to the same waveform.
<br><br>The bytes required for each character depend upon <a href="#bb_bits">bb_bits</a>.
<br><br>For <a href="#bb_bits">bb_bits</a> 1-8 there will be one byte per character.
For <a href="#bb_bits">bb_bits</a> 9-16 there will be two bytes per character.
For <a href="#bb_bits">bb_bits</a> 17-32 there will be four bytes per character.
<br><br><b><small>Example</small></b><br><br><code>pi.wave_add_serial(4,&nbsp;300,&nbsp;'Hello&nbsp;world')<br><br>pi.wave_add_serial(4,&nbsp;300,&nbsp;b"Hello&nbsp;world")<br><br>pi.wave_add_serial(4,&nbsp;300,&nbsp;b'\x23\x01\x00\x45')<br><br>pi.wave_add_serial(17,&nbsp;38400,&nbsp;[23,&nbsp;128,&nbsp;234],&nbsp;5000)<br></code><h3><a name="wave_chain">wave_chain<small>(<a href="#data">data</a>)</small></h3>
This function transmits a chain of waveforms.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a>
will be cancelled.
<br><br>The waves to be transmitted are specified by the contents
of data which contains an ordered list of <a href="#wave_id">wave_id</a>s
and optional command codes and related data.
<br><br>Returns 0 if OK, otherwise PI_CHAIN_NESTING,
PI_CHAIN_LOOP_CNT, PI_BAD_CHAIN_LOOP, PI_BAD_CHAIN_CMD,
PI_CHAIN_COUNTER, PI_BAD_CHAIN_DELAY, PI_CHAIN_TOO_BIG,
or PI_BAD_WAVE_ID.
<br><br>Each wave is transmitted in the order specified.  A wave
may occur multiple times per chain.
<br><br>A blocks of waves may be transmitted multiple times by
using the loop commands. The block is bracketed by loop
start and end commands.  Loops may be nested.
<br><br>Delays between waves may be added with the delay command.
<br><br>The following command codes are supported:
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Name</td><td>Cmd & Data</td><td>Meaning</td></tr><tr><td>Loop Start</td><td>255 0</td><td>Identify start of a wave block</td></tr><tr><td>Loop Repeat</td><td>255 1 x y</td><td>loop x + y*256 times</td></tr><tr><td>Delay</td><td>255 2 x y</td><td>delay x + y*256 microseconds</td></tr><tr><td>Loop Forever</td><td>255 3</td><td>loop forever</td></tr></tbody></table><br><br>If present Loop Forever must be the last entry in the chain.
<br><br>The code is currently dimensioned to support a chain with
roughly 600 entries and 20 loop counters.
<br><br><b><small>Example</small></b><br><br><code>#!/usr/bin/env&nbsp;python<br><br>import&nbsp;time<br>import&nbsp;pigpio<br><br>WAVES=5<br>GPIO=4<br><br>wid=[0]*WAVES<br><br>pi&nbsp;=&nbsp;pigpio.pi()&nbsp;#&nbsp;Connect&nbsp;to&nbsp;local&nbsp;Pi.<br><br>pi.set_mode(GPIO,&nbsp;pigpio.OUTPUT);<br><br>for&nbsp;i&nbsp;in&nbsp;range(WAVES):<br>&nbsp;&nbsp;&nbsp;pi.wave_add_generic([<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pigpio.pulse(1&lt;&lt;GPIO,&nbsp;0,&nbsp;20),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pigpio.pulse(0,&nbsp;1&lt;&lt;GPIO,&nbsp;(i+1)*200)]);<br><br>&nbsp;&nbsp;&nbsp;wid[i]&nbsp;=&nbsp;pi.wave_create();<br><br>pi.wave_chain([<br>&nbsp;&nbsp;&nbsp;wid[4],&nbsp;wid[3],&nbsp;wid[2],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;4+3+2<br>&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[0],&nbsp;wid[0],&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[1],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;0+1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;2,&nbsp;0x88,&nbsp;0x13,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;delay&nbsp;5000us<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;30,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;30&nbsp;times)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[2],&nbsp;wid[3],&nbsp;wid[0],&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;2+3+0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wid[3],&nbsp;wid[1],&nbsp;wid[2],&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;3+1+2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;10,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;10&nbsp;times)<br>&nbsp;&nbsp;&nbsp;255,&nbsp;1,&nbsp;5,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;loop&nbsp;end&nbsp;(repeat&nbsp;5&nbsp;times)<br>&nbsp;&nbsp;&nbsp;wid[4],&nbsp;wid[4],&nbsp;wid[4],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;4+4+4<br>&nbsp;&nbsp;&nbsp;255,&nbsp;2,&nbsp;0x20,&nbsp;0x4E,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;delay&nbsp;20000us<br>&nbsp;&nbsp;&nbsp;wid[0],&nbsp;wid[0],&nbsp;wid[0],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;transmit&nbsp;waves&nbsp;0+0+0<br>&nbsp;&nbsp;&nbsp;])<br><br>while&nbsp;pi.wave_tx_busy():<br>&nbsp;&nbsp;&nbsp;time.sleep(0.1);<br><br>for&nbsp;i&nbsp;in&nbsp;range(WAVES):<br>&nbsp;&nbsp;&nbsp;pi.wave_delete(wid[i])<br><br>pi.stop()<br></code><h3><a name="wave_clear">wave_clear<small>()</small></h3>
Clears all waveforms and any data added by calls to the
<a href="#wave_add_*">wave_add_*</a> functions.
<br><br><b><small>Example</small></b><br><br><code>pi.wave_clear()<br></code><h3><a name="wave_create">wave_create<small>()</small></h3>
Creates a waveform from the data provided by the prior calls
to the <a href="#wave_add_*">wave_add_*</a> functions.
<br><br>Returns a wave id (&gt;=0) if OK,  otherwise PI_EMPTY_WAVEFORM,
PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.
<br><br>The data provided by the <a href="#wave_add_*">wave_add_*</a> functions is consumed by
this function.
<br><br>As many waveforms may be created as there is space available.
The wave id is passed to <a href="#wave_send_*">wave_send_*</a> to specify the waveform
to transmit.
<br><br>Normal usage would be
<br><br>Step 1. <a href="#wave_clear">wave_clear</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#wave_add_*">wave_add_*</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#wave_create">wave_create</a> to create the waveform and get a unique id
<br><br>Repeat steps 2 and 3 as needed.
<br><br>Step 4. <a href="#wave_send_*">wave_send_*</a> with the id of the waveform to transmit.
<br><br>A waveform comprises one or more pulses.
<br><br>A pulse specifies
<br><br>1) the GPIO to be switched on at the start of the pulse.
2) the GPIO to be switched off at the start of the pulse.
3) the delay in microseconds before the next pulse.
<br><br>Any or all the fields can be zero.  It doesn't make any sense
to set all the fields to zero (the pulse will be ignored).
<br><br>When a waveform is started each pulse is executed in order with
the specified delay between the pulse and the next.
<br><br><b><small>Example</small></b><br><br><code>wid&nbsp;=&nbsp;pi.wave_create()<br></code><h3><a name="wave_create_and_pad">wave_create_and_pad<small>(<a href="#percent">percent</a>)</small></h3>
This function creates a waveform like <a href="#wave_create">wave_create</a> but pads the consumed
resources. Where percent gives the percentage of the resources to use
(in terms of the theoretical maximum, not the current amount free).
This allows the reuse of deleted waves while a transmission is active.
<br><br>Upon success a wave id greater than or equal to 0 is returned, otherwise
PI_EMPTY_WAVEFORM, PI_TOO_MANY_CBS, PI_TOO_MANY_OOL, or PI_NO_WAVEFORM_ID.
<br><br><code>pi:&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;<a href="#pigpio_start">pigpio_start</a>).<br></code><br><br>The data provided by the <a href="#wave_add_*">wave_add_*</a> functions are consumed by this
function.
<br><br>As many waveforms may be created as there is space available. The
wave id is passed to <a href="#wave_send_*">wave_send_*</a> to specify the waveform to transmit.
<br><br>A usage would be the creation of two waves where one is filled while the other
is being transmitted. Each wave is assigned 50% of the available resources.
This buffer structure allows the transmission of infinite wave sequences.
<br><br>Normal usage:
<br><br>Step 1. <a href="#wave_clear">wave_clear</a> to clear all waveforms and added data.
<br><br>Step 2. <a href="#wave_add_*">wave_add_*</a> calls to supply the waveform data.
<br><br>Step 3. <a href="#wave_create_and_pad">wave_create_and_pad</a> to create a waveform of uniform size.
<br><br>Step 4. <a href="#wave_send_*">wave_send_*</a> with the id of the waveform to transmit.
<br><br>Repeat steps 2-4 as needed.
<br><br>Step 5. Any wave id can now be deleted and another wave of the same size
        can be created in its place.
<br><br><b><small>Example</small></b><br><br><code>wid&nbsp;=&nbsp;pi.wave_create(50)<br></code><h3><a name="wave_delete">wave_delete<small>(<a href="#wave_id">wave_id</a>)</small></h3>
This function deletes the waveform with id wave_id.
<br><br><b><small>Parameters</small></b><br><br><samp>wave_id:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#wave_create">wave_create</a>).<br></samp><br><br>Wave ids are allocated in order, 0, 1, 2, etc.
<br><br>The wave is flagged for deletion.  The resources used by the wave
will only be reused when either of the following apply.
<br><br>- all waves with higher numbered wave ids have been deleted or have
been flagged for deletion.
<br><br>- a new wave is created which uses exactly the same resources as
the current wave (see the C source for gpioWaveCreate for details).
<br><br><b><small>Example</small></b><br><br><code>pi.wave_delete(6)&nbsp;#&nbsp;delete&nbsp;waveform&nbsp;with&nbsp;id&nbsp;6<br><br>pi.wave_delete(0)&nbsp;#&nbsp;delete&nbsp;waveform&nbsp;with&nbsp;id&nbsp;0<br></code><h3><a name="wave_get_cbs">wave_get_cbs<small>()</small></h3>
Returns the length in DMA control blocks of the current
waveform.
<br><br><b><small>Example</small></b><br><br><code>cbs&nbsp;=&nbsp;pi.wave_get_cbs()<br></code><h3><a name="wave_get_max_cbs">wave_get_max_cbs<small>()</small></h3>
Returns the maximum possible size of a waveform in DMA
control blocks.
<br><br><b><small>Example</small></b><br><br><code>cbs&nbsp;=&nbsp;pi.wave_get_max_cbs()<br></code><h3><a name="wave_get_max_micros">wave_get_max_micros<small>()</small></h3>
Returns the maximum possible size of a waveform in microseconds.
<br><br><b><small>Example</small></b><br><br><code>micros&nbsp;=&nbsp;pi.wave_get_max_micros()<br></code><h3><a name="wave_get_max_pulses">wave_get_max_pulses<small>()</small></h3>
Returns the maximum possible size of a waveform in pulses.
<br><br><b><small>Example</small></b><br><br><code>pulses&nbsp;=&nbsp;pi.wave_get_max_pulses()<br></code><h3><a name="wave_get_micros">wave_get_micros<small>()</small></h3>
Returns the length in microseconds of the current waveform.
<br><br><b><small>Example</small></b><br><br><code>micros&nbsp;=&nbsp;pi.wave_get_micros()<br></code><h3><a name="wave_get_pulses">wave_get_pulses<small>()</small></h3>
Returns the length in pulses of the current waveform.
<br><br><b><small>Example</small></b><br><br><code>pulses&nbsp;=&nbsp;pi.wave_get_pulses()<br></code><h3><a name="wave_send_once">wave_send_once<small>(<a href="#wave_id">wave_id</a>)</small></h3>
Transmits the waveform with id wave_id.  The waveform is sent
once.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will
be cancelled.
<br><br><b><small>Parameters</small></b><br><br><samp>wave_id:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#wave_create">wave_create</a>).<br></samp><br><br>Returns the number of DMA control blocks used in the waveform.
<br><br><b><small>Example</small></b><br><br><code>cbs&nbsp;=&nbsp;pi.wave_send_once(wid)<br></code><h3><a name="wave_send_repeat">wave_send_repeat<small>(<a href="#wave_id">wave_id</a>)</small></h3>
Transmits the waveform with id wave_id.  The waveform repeats
until wave_tx_stop is called or another call to <a href="#wave_send_*">wave_send_*</a>
is made.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will
be cancelled.
<br><br><b><small>Parameters</small></b><br><br><samp>wave_id:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#wave_create">wave_create</a>).<br></samp><br><br>Returns the number of DMA control blocks used in the waveform.
<br><br><b><small>Example</small></b><br><br><code>cbs&nbsp;=&nbsp;pi.wave_send_repeat(wid)<br></code><h3><a name="wave_send_using_mode">wave_send_using_mode<small>(<a href="#wave_id">wave_id</a>, <a href="#mode">mode</a>)</small></h3>
Transmits the waveform with id wave_id using mode mode.
<br><br><b><small>Parameters</small></b><br><br><samp>wave_id:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#wave_create">wave_create</a>).<br>&nbsp;&nbsp;&nbsp;mode:=&nbsp;WAVE_MODE_ONE_SHOT,&nbsp;WAVE_MODE_REPEAT,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WAVE_MODE_ONE_SHOT_SYNC,&nbsp;or&nbsp;WAVE_MODE_REPEAT_SYNC.<br></samp><br><br>WAVE_MODE_ONE_SHOT: same as <a href="#wave_send_once">wave_send_once</a>.
<br><br>WAVE_MODE_REPEAT same as <a href="#wave_send_repeat">wave_send_repeat</a>.
<br><br>WAVE_MODE_ONE_SHOT_SYNC same as <a href="#wave_send_once">wave_send_once</a> but tries
to sync with the previous waveform.
<br><br>WAVE_MODE_REPEAT_SYNC same as <a href="#wave_send_repeat">wave_send_repeat</a> but tries
to sync with the previous waveform.
<br><br>WARNING: bad things may happen if you delete the previous
waveform before it has been synced to the new waveform.
<br><br>NOTE: Any hardware PWM started by <a href="#hardware_PWM">hardware_PWM</a> will
be cancelled.
<br><br><b><small>Parameters</small></b><br><br><samp>wave_id:=&nbsp;&gt;=0&nbsp;(as&nbsp;returned&nbsp;by&nbsp;a&nbsp;prior&nbsp;call&nbsp;to&nbsp;<a href="#wave_create">wave_create</a>).<br></samp><br><br>Returns the number of DMA control blocks used in the waveform.
<br><br><b><small>Example</small></b><br><br><code>cbs&nbsp;=&nbsp;pi.wave_send_using_mode(wid,&nbsp;WAVE_MODE_REPEAT_SYNC)<br></code><h3><a name="wave_tx_at">wave_tx_at<small>()</small></h3>
Returns the id of the waveform currently being
transmitted.
<br><br>Returns the waveform id or one of the following special
values:
<br><br>WAVE_NOT_FOUND (9998) - transmitted wave not found.
NO_TX_WAVE (9999) - no wave being transmitted.
<br><br><b><small>Example</small></b><br><br><code>wid&nbsp;=&nbsp;pi.wave_tx_at()<br></code><h3><a name="wave_tx_busy">wave_tx_busy<small>()</small></h3>
Returns 1 if a waveform is currently being transmitted,
otherwise 0.
<br><br><b><small>Example</small></b><br><br><code>pi.wave_send_once(0)&nbsp;#&nbsp;send&nbsp;first&nbsp;waveform<br><br>while&nbsp;pi.wave_tx_busy():&nbsp;#&nbsp;wait&nbsp;for&nbsp;waveform&nbsp;to&nbsp;be&nbsp;sent<br>&nbsp;&nbsp;&nbsp;time.sleep(0.1)<br><br>pi.wave_send_once(1)&nbsp;#&nbsp;send&nbsp;next&nbsp;waveform<br></code><h3><a name="wave_tx_repeat">wave_tx_repeat<small>()</small></h3>
This function is deprecated and has beeen removed.
<br><br>Use <a href="#wave_create">wave_create</a>/<a href="#wave_send_*">wave_send_*</a> instead.
<h3><a name="wave_tx_start">wave_tx_start<small>()</small></h3>
This function is deprecated and has been removed.
<br><br>Use <a href="#wave_create">wave_create</a>/<a href="#wave_send_*">wave_send_*</a> instead.
<h3><a name="wave_tx_stop">wave_tx_stop<small>()</small></h3>
Stops the transmission of the current waveform.
<br><br>This function is intended to stop a waveform started with
wave_send_repeat.
<br><br><b><small>Example</small></b><br><br><code>pi.wave_send_repeat(3)<br><br>time.sleep(5)<br><br>pi.wave_tx_stop()<br></code><h3><a name="write">write<small>(<a href="#gpio">gpio</a>, <a href="#level">level</a>)</small></h3>
Sets the GPIO level.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;GPIO:=&nbsp;0-53.<br>level:=&nbsp;0,&nbsp;1.<br></samp><br><br>If PWM or servo pulses are active on the GPIO they are
switched off.
<br><br><b><small>Example</small></b><br><br><code>pi.set_mode(17,&nbsp;pigpio.OUTPUT)<br><br>pi.write(17,0)<br>print(pi.read(17))<br>0<br><br>pi.write(17,1)<br>print(pi.read(17))<br>1<br></code><h2>    class pulse
</h2><h3><a name="pigpio.pulse">pigpio.pulse<small>(<a href="#gpio_on">gpio_on</a>, <a href="#gpio_off">gpio_off</a>, <a href="#delay">delay</a>)</small></h3>
Initialises a pulse.
<br><br><b><small>Parameters</small></b><br><br><samp>&nbsp;gpio_on:=&nbsp;the&nbsp;GPIO&nbsp;to&nbsp;switch&nbsp;on&nbsp;at&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;pulse.<br>gpio_off:=&nbsp;the&nbsp;GPIO&nbsp;to&nbsp;switch&nbsp;off&nbsp;at&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;pulse.<br>&nbsp;&nbsp;&nbsp;delay:=&nbsp;the&nbsp;delay&nbsp;in&nbsp;microseconds&nbsp;before&nbsp;the&nbsp;next&nbsp;pulse.<br></samp><h2>FUNCTIONS</h2><h3><a name="pigpio.error_text">pigpio.error_text<small>(<a href="#errnum">errnum</a>)</small></h3>
Returns a text description of a pigpio error.
<br><br><b><small>Parameters</small></b><br><br><samp>errnum:=&nbsp;&lt;0,&nbsp;the&nbsp;error&nbsp;number<br></samp><br><br><b><small>Example</small></b><br><br><code>print(pigpio.error_text(-5))<br>level&nbsp;not&nbsp;0-1<br></code><h3><a name="pigpio.tickDiff">pigpio.tickDiff<small>(<a href="#t1">t1</a>, <a href="#t2">t2</a>)</small></h3>
Returns the microsecond difference between two ticks.
<br><br><b><small>Parameters</small></b><br><br><samp>t1:=&nbsp;the&nbsp;earlier&nbsp;tick<br>t2:=&nbsp;the&nbsp;later&nbsp;tick<br></samp><br><br><b><small>Example</small></b><br><br><code>print(pigpio.tickDiff(4294967272,&nbsp;12))<br>36<br></code><h3><a name="pigpio.u2i">pigpio.u2i<small>(<a href="#uint32">uint32</a>)</small></h3>
Converts a 32 bit unsigned number to signed.
<br><br><b><small>Parameters</small></b><br><br><samp>uint32:=&nbsp;an&nbsp;unsigned&nbsp;32&nbsp;bit&nbsp;number<br></samp><br><br><b><small>Example</small></b><br><br><code>print(u2i(4294967272))<br>-24<br>print(u2i(37))<br>37<br></code><h2>PARAMETERS</h2><h3><a name="active"></a>active: 0-1000000</h3>The number of microseconds level changes are reported for once
a noise filter has been triggered (by <a href="#steady">steady</a> microseconds of
a stable level).
<h3><a name="arg1"></a>arg1: </h3>An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.
<h3><a name="arg2"></a>arg2: </h3>An unsigned argument passed to a user customised function.  Its
meaning is defined by the customiser.
<h3><a name="argx"></a>argx: </h3>An array of bytes passed to a user customised function.
Its meaning and content is defined by the customiser.
<h3><a name="baud"></a>baud: </h3>The speed of serial communication (I2C, SPI, serial link, waves)
in bits per second.
<h3><a name="bb_bits"></a>bb_bits: 1-32</h3>The number of data bits to be used when adding serial data to a
waveform.
<h3><a name="bb_stop"></a>bb_stop: 2-8</h3>The number of (half) stop bits to be used when adding serial data
to a waveform.
<h3><a name="bit"></a>bit: 0-1</h3>A value of 0 or 1.
<h3><a name="bits"></a>bits: 32 bit number</h3>A mask used to select GPIO to be operated on.  If bit n is set
then GPIO n is selected.  A convenient way of setting bit n is to
bit or in the value (1&lt;&lt;n).
<br><br>To select GPIO 1, 7, 23
<br><br>bits = (1&lt;&lt;1) | (1&lt;&lt;7) | (1&lt;&lt;23)
<h3><a name="bsc_control"></a>bsc_control: </h3><code>22&nbsp;21&nbsp;20&nbsp;19&nbsp;18&nbsp;17&nbsp;16&nbsp;15&nbsp;14&nbsp;13&nbsp;12&nbsp;11&nbsp;10&nbsp;&nbsp;9&nbsp;&nbsp;8&nbsp;&nbsp;7&nbsp;&nbsp;6&nbsp;&nbsp;5&nbsp;&nbsp;4&nbsp;&nbsp;3&nbsp;&nbsp;2&nbsp;&nbsp;1&nbsp;&nbsp;0<br>&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;a&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;IT&nbsp;HC&nbsp;TF&nbsp;IR&nbsp;RE&nbsp;TE&nbsp;BK&nbsp;EC&nbsp;ES&nbsp;PL&nbsp;PH&nbsp;I2&nbsp;SP&nbsp;EN<br></code><br><br>aaaaaaa defines the I2C slave address (only relevant in I2C mode)
<br><br>Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document.
<h3><a name="byte_val"></a>byte_val: 0-255</h3>A whole number.
<h3><a name="clkfreq"></a>clkfreq: 4689-250M (13184-375M for the BCM2711)</h3>The hardware clock frequency.
<h3><a name="connected"></a>connected: </h3>True if a connection was established, False otherwise.
<h3><a name="count"></a>count: </h3>The number of bytes of data to be transferred.
<h3><a name="CS"></a>CS: </h3>The GPIO used for the slave select signal when bit banging SPI.
<h3><a name="data"></a>data: </h3>Data to be transmitted, a series of bytes.
<h3><a name="delay"></a>delay: &gt;=1</h3>The length of a pulse in microseconds.
<h3><a name="dutycycle"></a>dutycycle: 0-range_</h3>A number between 0 and range_.
<br><br>The dutycycle sets the proportion of time on versus time off during each
PWM cycle.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Dutycycle</td><td>On time</td></tr><tr><td>0</td><td>Off</td></tr><tr><td>range_ * 0.25</td><td>25% On</td></tr><tr><td>range_ * 0.50</td><td>50% On</td></tr><tr><td>range_ * 0.75</td><td>75% On</td></tr><tr><td>range_</td><td>Fully On</td></tr></tbody></table><h3><a name="edge"></a>edge: 0-2</h3><code>EITHER_EDGE&nbsp;=&nbsp;2<br>FALLING_EDGE&nbsp;=&nbsp;1<br>RISING_EDGE&nbsp;=&nbsp;0<br></code><h3><a name="errnum"></a>errnum: &lt;0</h3><code>PI_BAD_USER_GPIO&nbsp;=&nbsp;-2<br>PI_BAD_GPIO&nbsp;=&nbsp;-3<br>PI_BAD_MODE&nbsp;=&nbsp;-4<br>PI_BAD_LEVEL&nbsp;=&nbsp;-5<br>PI_BAD_PUD&nbsp;=&nbsp;-6<br>PI_BAD_PULSEWIDTH&nbsp;=&nbsp;-7<br>PI_BAD_DUTYCYCLE&nbsp;=&nbsp;-8<br>PI_BAD_WDOG_TIMEOUT&nbsp;=&nbsp;-15<br>PI_BAD_DUTYRANGE&nbsp;=&nbsp;-21<br>PI_NO_HANDLE&nbsp;=&nbsp;-24<br>PI_BAD_HANDLE&nbsp;=&nbsp;-25<br>PI_BAD_WAVE_BAUD&nbsp;=&nbsp;-35<br>PI_TOO_MANY_PULSES&nbsp;=&nbsp;-36<br>PI_TOO_MANY_CHARS&nbsp;=&nbsp;-37<br>PI_NOT_SERIAL_GPIO&nbsp;=&nbsp;-38<br>PI_NOT_PERMITTED&nbsp;=&nbsp;-41<br>PI_SOME_PERMITTED&nbsp;=&nbsp;-42<br>PI_BAD_WVSC_COMMND&nbsp;=&nbsp;-43<br>PI_BAD_WVSM_COMMND&nbsp;=&nbsp;-44<br>PI_BAD_WVSP_COMMND&nbsp;=&nbsp;-45<br>PI_BAD_PULSELEN&nbsp;=&nbsp;-46<br>PI_BAD_SCRIPT&nbsp;=&nbsp;-47<br>PI_BAD_SCRIPT_ID&nbsp;=&nbsp;-48<br>PI_BAD_SER_OFFSET&nbsp;=&nbsp;-49<br>PI_GPIO_IN_USE&nbsp;=&nbsp;-50<br>PI_BAD_SERIAL_COUNT&nbsp;=&nbsp;-51<br>PI_BAD_PARAM_NUM&nbsp;=&nbsp;-52<br>PI_DUP_TAG&nbsp;=&nbsp;-53<br>PI_TOO_MANY_TAGS&nbsp;=&nbsp;-54<br>PI_BAD_SCRIPT_CMD&nbsp;=&nbsp;-55<br>PI_BAD_VAR_NUM&nbsp;=&nbsp;-56<br>PI_NO_SCRIPT_ROOM&nbsp;=&nbsp;-57<br>PI_NO_MEMORY&nbsp;=&nbsp;-58<br>PI_SOCK_READ_FAILED&nbsp;=&nbsp;-59<br>PI_SOCK_WRIT_FAILED&nbsp;=&nbsp;-60<br>PI_TOO_MANY_PARAM&nbsp;=&nbsp;-61<br>PI_SCRIPT_NOT_READY&nbsp;=&nbsp;-62<br>PI_BAD_TAG&nbsp;=&nbsp;-63<br>PI_BAD_MICS_DELAY&nbsp;=&nbsp;-64<br>PI_BAD_MILS_DELAY&nbsp;=&nbsp;-65<br>PI_BAD_WAVE_ID&nbsp;=&nbsp;-66<br>PI_TOO_MANY_CBS&nbsp;=&nbsp;-67<br>PI_TOO_MANY_OOL&nbsp;=&nbsp;-68<br>PI_EMPTY_WAVEFORM&nbsp;=&nbsp;-69<br>PI_NO_WAVEFORM_ID&nbsp;=&nbsp;-70<br>PI_I2C_OPEN_FAILED&nbsp;=&nbsp;-71<br>PI_SER_OPEN_FAILED&nbsp;=&nbsp;-72<br>PI_SPI_OPEN_FAILED&nbsp;=&nbsp;-73<br>PI_BAD_I2C_BUS&nbsp;=&nbsp;-74<br>PI_BAD_I2C_ADDR&nbsp;=&nbsp;-75<br>PI_BAD_SPI_CHANNEL&nbsp;=&nbsp;-76<br>PI_BAD_FLAGS&nbsp;=&nbsp;-77<br>PI_BAD_SPI_SPEED&nbsp;=&nbsp;-78<br>PI_BAD_SER_DEVICE&nbsp;=&nbsp;-79<br>PI_BAD_SER_SPEED&nbsp;=&nbsp;-80<br>PI_BAD_PARAM&nbsp;=&nbsp;-81<br>PI_I2C_WRITE_FAILED&nbsp;=&nbsp;-82<br>PI_I2C_READ_FAILED&nbsp;=&nbsp;-83<br>PI_BAD_SPI_COUNT&nbsp;=&nbsp;-84<br>PI_SER_WRITE_FAILED&nbsp;=&nbsp;-85<br>PI_SER_READ_FAILED&nbsp;=&nbsp;-86<br>PI_SER_READ_NO_DATA&nbsp;=&nbsp;-87<br>PI_UNKNOWN_COMMAND&nbsp;=&nbsp;-88<br>PI_SPI_XFER_FAILED&nbsp;=&nbsp;-89<br>PI_NO_AUX_SPI&nbsp;=&nbsp;-91<br>PI_NOT_PWM_GPIO&nbsp;=&nbsp;-92<br>PI_NOT_SERVO_GPIO&nbsp;=&nbsp;-93<br>PI_NOT_HCLK_GPIO&nbsp;=&nbsp;-94<br>PI_NOT_HPWM_GPIO&nbsp;=&nbsp;-95<br>PI_BAD_HPWM_FREQ&nbsp;=&nbsp;-96<br>PI_BAD_HPWM_DUTY&nbsp;=&nbsp;-97<br>PI_BAD_HCLK_FREQ&nbsp;=&nbsp;-98<br>PI_BAD_HCLK_PASS&nbsp;=&nbsp;-99<br>PI_HPWM_ILLEGAL&nbsp;=&nbsp;-100<br>PI_BAD_DATABITS&nbsp;=&nbsp;-101<br>PI_BAD_STOPBITS&nbsp;=&nbsp;-102<br>PI_MSG_TOOBIG&nbsp;=&nbsp;-103<br>PI_BAD_MALLOC_MODE&nbsp;=&nbsp;-104<br>PI_BAD_SMBUS_CMD&nbsp;=&nbsp;-107<br>PI_NOT_I2C_GPIO&nbsp;=&nbsp;-108<br>PI_BAD_I2C_WLEN&nbsp;=&nbsp;-109<br>PI_BAD_I2C_RLEN&nbsp;=&nbsp;-110<br>PI_BAD_I2C_CMD&nbsp;=&nbsp;-111<br>PI_BAD_I2C_BAUD&nbsp;=&nbsp;-112<br>PI_CHAIN_LOOP_CNT&nbsp;=&nbsp;-113<br>PI_BAD_CHAIN_LOOP&nbsp;=&nbsp;-114<br>PI_CHAIN_COUNTER&nbsp;=&nbsp;-115<br>PI_BAD_CHAIN_CMD&nbsp;=&nbsp;-116<br>PI_BAD_CHAIN_DELAY&nbsp;=&nbsp;-117<br>PI_CHAIN_NESTING&nbsp;=&nbsp;-118<br>PI_CHAIN_TOO_BIG&nbsp;=&nbsp;-119<br>PI_DEPRECATED&nbsp;=&nbsp;-120<br>PI_BAD_SER_INVERT&nbsp;=&nbsp;-121<br>PI_BAD_FOREVER&nbsp;=&nbsp;-124<br>PI_BAD_FILTER&nbsp;=&nbsp;-125<br>PI_BAD_PAD&nbsp;=&nbsp;-126<br>PI_BAD_STRENGTH&nbsp;=&nbsp;-127<br>PI_FIL_OPEN_FAILED&nbsp;=&nbsp;-128<br>PI_BAD_FILE_MODE&nbsp;=&nbsp;-129<br>PI_BAD_FILE_FLAG&nbsp;=&nbsp;-130<br>PI_BAD_FILE_READ&nbsp;=&nbsp;-131<br>PI_BAD_FILE_WRITE&nbsp;=&nbsp;-132<br>PI_FILE_NOT_ROPEN&nbsp;=&nbsp;-133<br>PI_FILE_NOT_WOPEN&nbsp;=&nbsp;-134<br>PI_BAD_FILE_SEEK&nbsp;=&nbsp;-135<br>PI_NO_FILE_MATCH&nbsp;=&nbsp;-136<br>PI_NO_FILE_ACCESS&nbsp;=&nbsp;-137<br>PI_FILE_IS_A_DIR&nbsp;=&nbsp;-138<br>PI_BAD_SHELL_STATUS&nbsp;=&nbsp;-139<br>PI_BAD_SCRIPT_NAME&nbsp;=&nbsp;-140<br>PI_BAD_SPI_BAUD&nbsp;=&nbsp;-141<br>PI_NOT_SPI_GPIO&nbsp;=&nbsp;-142<br>PI_BAD_EVENT_ID&nbsp;=&nbsp;-143<br>PI_CMD_INTERRUPTED&nbsp;=&nbsp;-144<br>PI_NOT_ON_BCM2711&nbsp;&nbsp;&nbsp;=&nbsp;-145<br>PI_ONLY_ON_BCM2711&nbsp;&nbsp;=&nbsp;-146<br></code><h3><a name="event"></a>event: 0-31</h3>An event is a signal used to inform one or more consumers
to start an action.
<h3><a name="file_mode"></a>file_mode: </h3>The mode may have the following values
<br><br><code>FILE_READ&nbsp;&nbsp;&nbsp;1<br>FILE_WRITE&nbsp;&nbsp;2<br>FILE_RW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br></code><br><br>The following values can be or'd into the file open mode
<br><br><code>FILE_APPEND&nbsp;4<br>FILE_CREATE&nbsp;8<br>FILE_TRUNC&nbsp;&nbsp;16<br></code><h3><a name="file_name"></a>file_name: </h3>A full file path.  To be accessible the path must match
an entry in /opt/pigpio/access.
<h3><a name="fpattern"></a>fpattern: </h3>A file path which may contain wildcards.  To be accessible the path
must match an entry in /opt/pigpio/access.
<h3><a name="frequency"></a>frequency: 0-40000</h3>Defines the frequency to be used for PWM on a GPIO.
The closest permitted frequency will be used.
<h3><a name="func"></a>func: </h3>A user supplied callback function.
<h3><a name="gpio"></a>gpio: 0-53</h3>A Broadcom numbered GPIO.  All the user GPIO are in the range 0-31.
<br><br>There  are 54 General Purpose Input Outputs (GPIO) named GPIO0
through GPIO53.
<br><br>They are split into two  banks.   Bank  1  consists  of  GPIO0
through GPIO31.  Bank 2 consists of GPIO32 through GPIO53.
<br><br>All the GPIO which are safe for the user to read and write are in
bank 1.  Not all GPIO in bank 1 are safe though.  Type 1 boards
have 17  safe GPIO.  Type 2 boards have 21.  Type 3 boards have 26.
<br><br>See <a href="#get_hardware_revision">get_hardware_revision</a>.
<br><br>The user GPIO are marked with an X in the following table
<br><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15<br>Type&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;25&nbsp;26&nbsp;27&nbsp;28&nbsp;29&nbsp;30&nbsp;31<br>Type&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-<br>Type&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X<br>Type&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;X&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-&nbsp;&nbsp;-<br></code><h3><a name="gpio_off"></a>gpio_off: </h3>A mask used to select GPIO to be operated on.  See <a href="#bits">bits</a>.
<br><br>This mask selects the GPIO to be switched off at the start
of a pulse.
<h3><a name="gpio_on"></a>gpio_on: </h3>A mask used to select GPIO to be operated on.  See <a href="#bits">bits</a>.
<br><br>This mask selects the GPIO to be switched on at the start
of a pulse.
<h3><a name="handle"></a>handle: &gt;=0</h3>A number referencing an object opened by one of the following
<br><br><a href="#file_open">file_open</a>
<a href="#i2c_open">i2c_open</a>
<a href="#notify_open">notify_open</a>
<a href="#serial_open">serial_open</a>
<a href="#spi_open">spi_open</a>
<h3><a name="host"></a>host: </h3>The name or IP address of the Pi running the pigpio daemon.
<h3><a name="i2c_address"></a>i2c_address: 0-0x7F</h3>The address of a device on the I2C bus.
<h3><a name="i2c_bus"></a>i2c_bus: &gt;=0</h3>An I2C bus number.
<h3><a name="i2c_flags"></a>i2c_flags: 0</h3>No I2C flags are currently defined.
<h3><a name="invert"></a>invert: 0-1</h3>A flag used to set normal or inverted bit bang serial data
level logic.
<h3><a name="level"></a>level: 0-1 (2)</h3><code>CLEAR&nbsp;=&nbsp;0<br>HIGH&nbsp;=&nbsp;1<br>LOW&nbsp;=&nbsp;0<br>OFF&nbsp;=&nbsp;0<br>ON&nbsp;=&nbsp;1<br>SET&nbsp;=&nbsp;1<br>TIMEOUT&nbsp;=&nbsp;2&nbsp;#&nbsp;only&nbsp;returned&nbsp;for&nbsp;a&nbsp;watchdog&nbsp;timeout<br></code><h3><a name="MISO"></a>MISO: </h3>The GPIO used for the MISO signal when bit banging SPI.
<h3><a name="mode"></a>mode: </h3>1.The operational mode of a GPIO, normally INPUT or OUTPUT.
<br><br><code>ALT0&nbsp;=&nbsp;4<br>ALT1&nbsp;=&nbsp;5<br>ALT2&nbsp;=&nbsp;6<br>ALT3&nbsp;=&nbsp;7<br>ALT4&nbsp;=&nbsp;3<br>ALT5&nbsp;=&nbsp;2<br>INPUT&nbsp;=&nbsp;0<br>OUTPUT&nbsp;=&nbsp;1<br></code><br><br>2. The mode of waveform transmission.
<br><br><code>WAVE_MODE_ONE_SHOT&nbsp;=&nbsp;0<br>WAVE_MODE_REPEAT&nbsp;=&nbsp;1<br>WAVE_MODE_ONE_SHOT_SYNC&nbsp;=&nbsp;2<br>WAVE_MODE_REPEAT_SYNC&nbsp;=&nbsp;3<br></code><h3><a name="MOSI"></a>MOSI: </h3>The GPIO used for the MOSI signal when bit banging SPI.
<h3><a name="offset"></a>offset: &gt;=0</h3>The offset wave data starts from the beginning of the waveform
being currently defined.
<h3><a name="pad"></a>pad: 0-2</h3>A set of GPIO which share common drivers.
<br><br><table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>Pad</td><td>GPIO</td></tr><tr><td>0</td><td>0-27</td></tr><tr><td>1</td><td>28-45</td></tr><tr><td>2</td><td>46-53</td></tr></tbody></table><h3><a name="pad_strength"></a>pad_strength: 1-16</h3>The mA which may be drawn from each GPIO whilst still guaranteeing the
high and low levels.
<h3><a name="params"></a>params: 32 bit number</h3>When scripts are started they can receive up to 10 parameters
to define their operation.
<h3><a name="port"></a>port: </h3>The port used by the pigpio daemon, defaults to 8888.
<h3><a name="pstring"></a>pstring: </h3>The string to be passed to a <a href="#shell">shell</a> script to be executed.
<h3><a name="pud"></a>pud: 0-2</h3><code>PUD_DOWN&nbsp;=&nbsp;1<br>PUD_OFF&nbsp;=&nbsp;0<br>PUD_UP&nbsp;=&nbsp;2<br></code><h3><a name="pulse_len"></a>pulse_len: 1-100</h3>The length of the trigger pulse in microseconds.
<h3><a name="pulses"></a>pulses: </h3>A list of class pulse objects defining the characteristics of a
waveform.
<h3><a name="pulsewidth"></a>pulsewidth: </h3>The servo pulsewidth in microseconds.  0 switches pulses off.
<h3><a name="PWMduty"></a>PWMduty: 0-1000000 (1M)</h3>The hardware PWM dutycycle.
<h3><a name="PWMfreq"></a>PWMfreq: 1-125M (1-187.5M for the BCM2711)</h3>The hardware PWM frequency.
<h3><a name="range_"></a>range_: 25-40000</h3>Defines the limits for the <a href="#dutycycle">dutycycle</a> parameter.
<br><br>range_ defaults to 255.
<h3><a name="reg"></a>reg: 0-255</h3>An I2C device register.  The usable registers depend on the
actual device.
<h3><a name="retMax"></a>retMax: &gt;=0</h3>The maximum number of bytes a user customised function
should return, default 8192.
<h3><a name="SCL"></a>SCL: </h3>The user GPIO to use for the clock when bit banging I2C.
<h3><a name="SCLK"></a>SCLK: :</h3>The GPIO used for the SCLK signal when bit banging SPI.
<h3><a name="script"></a>script: </h3>The text of a script to store on the pigpio daemon.
<h3><a name="script_id"></a>script_id: &gt;=0</h3>A number referencing a script created by <a href="#store_script">store_script</a>.
<h3><a name="SDA"></a>SDA: </h3>The user GPIO to use for data when bit banging I2C.
<h3><a name="seek_from"></a>seek_from: 0-2</h3>Direction to seek for <a href="#file_seek">file_seek</a>.
<br><br><code>FROM_START=0<br>FROM_CURRENT=1<br>FROM_END=2<br></code><h3><a name="seek_offset"></a>seek_offset: </h3>The number of bytes to move forward (positive) or backwards
(negative) from the seek position (start, current, or end of file).
<h3><a name="ser_flags"></a>ser_flags: 32 bit</h3>No serial flags are currently defined.
<h3><a name="serial_*"></a>serial_*: </h3>One of the serial_ functions.
<h3><a name="shellscr"></a>shellscr: </h3>The name of a shell script.  The script must exist
in /opt/pigpio/cgi and must be executable.
<h3><a name="show_errors"></a>show_errors: </h3>Controls the display of pigpio daemon connection failures.
The default of True prints the probable failure reasons to
standard output.
<h3><a name="spi_channel"></a>spi_channel: 0-2</h3>A SPI channel.
<h3><a name="spi_flags"></a>spi_flags: 32 bit</h3>See <a href="#spi_open">spi_open</a>.
<h3><a name="steady"></a>steady: 0-300000</h3>The number of microseconds level changes must be stable for
before reporting the level changed (<a href="#set_glitch_filter">set_glitch_filter</a>)
or triggering the active part of a noise filter
(<a href="#set_noise_filter">set_noise_filter</a>).
<h3><a name="t1"></a>t1: </h3>A tick (earlier).
<h3><a name="t2"></a>t2: </h3>A tick (later).
<h3><a name="tty"></a>tty: </h3>A Pi serial tty device, e.g. /dev/ttyAMA0, /dev/ttyUSB0
<h3><a name="uint32"></a>uint32: </h3>An unsigned 32 bit number.
<h3><a name="user_gpio"></a>user_gpio: 0-31</h3>A Broadcom numbered GPIO.
<br><br>All the user GPIO are in the range 0-31.
<br><br>Not all the GPIO within this range are usable, some are reserved
for system use.
<br><br>See <a href="#gpio">gpio</a>.
<h3><a name="wait_timeout"></a>wait_timeout: 0.0 -</h3>The number of seconds to wait in <a href="#wait_for_edge">wait_for_edge</a> before timing out.
<h3><a name="wave_add_*"></a>wave_add_*: </h3>One of the following
<br><br><a href="#wave_add_new">wave_add_new</a>
<a href="#wave_add_generic">wave_add_generic</a>
<a href="#wave_add_serial">wave_add_serial</a>
<h3><a name="wave_id"></a>wave_id: &gt;=0</h3>A number referencing a wave created by <a href="#wave_create">wave_create</a>.
<h3><a name="wave_send_*"></a>wave_send_*: </h3>One of the following
<br><br><a href="#wave_send_once">wave_send_once</a>
<a href="#wave_send_repeat">wave_send_repeat</a>
<h3><a name="wdog_timeout"></a>wdog_timeout: 0-60000</h3>Defines a GPIO watchdog timeout in milliseconds.  If no level
change is detected on the GPIO for timeout millisecond a watchdog
timeout report is issued (with level TIMEOUT).
<h3><a name="word_val"></a>word_val: 0-65535</h3>A whole number.
<br><br>