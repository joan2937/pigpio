
." Process this file with
." groff -man -Tascii foo.1
."
.TH pigs 1 2012-2015 Linux "pigpio archive"
.SH NAME
pigs - command line socket access to the pigpio daemon.

/dev/pigpio - command line pipe access to the pigpio daemon.

.SH SYNOPSIS

.B sudo pigpiod

then

.B pigs {command}+

or

.B "echo {command}+ >/dev/pigpio"

.SH DESCRIPTION

.ad l

.nh


.br
The socket and pipe interfaces allow control of the GPIO by passing
messages to the running pigpio library.

.br
The normal way to start the pigpio library would be as a daemon during boot.

.br

.EX
sudo pigpiod
.br

.EE

.br
pigs is a program and internally uses the socket interface to pigpio
whereas /dev/pigpio uses the pipe interface.

.br
.SS Features
.br
o hardware timed PWM on any of GPIO 0-31

.br
o hardware timed servo pulses on any of GPIO 0-31

.br
o reading/writing all of the GPIO in a bank as one operation

.br
o individually setting GPIO modes, reading and writing

.br
o notifications when any of GPIO 0-31 change state

.br
o the construction of output waveforms with microsecond timing

.br
o I2C, SPI, and serial link wrappers

.br
o creating and running scripts on the pigpio daemon

.br
.SS GPIO
.br
ALL GPIO are identified by their Broadcom number.

.br
.SS Usage
.br
pigs and the socket interface share the same commands and are invoked in
a similar fashion from the command line.

.br
The pigpio library must be running, either by running a program linked
with the library or starting the pigpio daemon (sudo pigpiod).

.br
pigs {command}+

.br
echo "{command}+" >/dev/pigpio

.br
pigs will show the result of the command on screen.

.br
The results of /dev/pigpio commands need to be read from /dev/pigout,
e.g. cat /dev/pigout (try cat /dev/pigout& so that all subsequent
results are shown on screen).

.br
In both cases if an error was detected a message will have been written
to /dev/pigerr (try cat /dev/pigerr&).  This is likely to be more
informative than the message returned by pigs or the error code
returned by the pipe interface.

.br
Several commands may be entered on a line.  If present PROC and PARSE must
be the last command on a line.

.br
E.g.

.br

.EX
pigs w 22 1 mils 1000 w 22 0
.br

.EE

.br
is equivalent to

.br

.EX
pigs w 22 1
.br
pigs mils 1000
.br
pigs w 22 0
.br

.EE

.br
and

.br

.EX
echo "m 4 w w 4 0 mils 250 m 4 r r 4" >/dev/pigpio
.br

.EE

.br
is equivalent to

.br

.EX
echo "m 4 w"    >/dev/pigpio
.br
echo "w 4 0"    >/dev/pigpio
.br
echo "mils 250" >/dev/pigpio
.br
echo "m 4 r"    >/dev/pigpio
.br
echo "r 4"      >/dev/pigpio
.br

.EE

.br
.SS Notes
.br
The examples from now on will show the pigs interface but the same
commands will also work on the pipe interface.

.br
pigs does not show the status of successful commands unless the
command itself returns data.  The status (0) will be returned to
pigs but will be discarded.

.br
The status/data of each command sent to the pipe interface should
be read from /dev/pigout.

.br
When a command takes a number as a parameter it may be entered as hex
(precede by 0x), octal (precede by 0), or decimal.

.br
E.g. 23 is 23 decimal, 0x100 is 256 decimal, 070 is 56 decimal.

.br

.SH COMMANDS

.br

.IP "\fBBC1 bits\fP - Clear specified GPIO in bank 1"
.IP "" 4
This command clears (sets low) the GPIO specified by \fBbits\fP in bank 1.
Bank 1 consists of GPIO 0-31.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs bc1 0x400010 # clear GPIO 4 (1<<4) and 22 (1<<22)
.br

.br
$ pigs bc1 32 # clear GPIO 5 (1<<5)
.br
-42
.br
ERROR: no permission to update one or more GPIO
.br

.EE

.br

.IP "\fBBC2 bits\fP - Clear specified GPIO in bank 2"
.IP "" 4
This command clears (sets low) the GPIO specified by \fBbits\fP in bank 2.
Bank 2 consists of GPIO 32-53.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs bc2 0x8000 # clear GPIO 47 (activity LED on A+/B+/Pi2/Pi3)
.br

.br
$ pigs bc2 1 # clear GPIO 32 (first in bank 2)
.br
-42
.br
ERROR: no permission to update one or more GPIO
.br

.EE

.br

.IP "\fBBI2CC sda\fP - Close bit bang I2C"
.IP "" 4
This command signals that bit banging I2C on \fBsda\fP (and \fBscl\fP) is no
longer required.

.br

\fBExample\fP
.br

.EX
$ pigs bi2cc 5
.br

.EE

.br

.IP "\fBBI2CO sda scl b\fP - Open bit bang I2C"
.IP "" 4
This command signals that GPIO \fBsda\fP and \fBscl\fP are to be used
for bit banging I2C at \fBb\fP baud.

.br
Bit banging I2C allows for certain operations which are not possible
with the standard I2C driver.

.br
o baud rates as low as 50
.br
o repeated starts
.br
o clock stretching
.br
o I2C on any pair of spare GPIO

.br
The baud rate may be between 50 and 500000 bits per second.

.br
The GPIO used for SDA and SCL must have pull-ups to 3V3 connected.  As
a guide the hardware pull-ups on pins 3 and 5 are 1k8 in value.

.br

.IP "\fBBI2CZ sda bvs\fP - I2C bit bang multiple transactions"
.IP "" 4
This function executes a sequence of bit banged I2C operations.  The
operations to be performed are specified by the contents of \fBbvs\fP
which contains the concatenated command codes and associated data.

.br
The following command codes are supported:

.br

.EX
Name      Cmd & Data     Meaning
End       0              No more commands
Escape    1              Next P is two bytes
Start     2              Start condition
Stop      3              Stop condition
Address   4 P            Set I2C address to P
Flags     5 lsb msb      Set I2C flags to lsb + (msb << 8)
Read      6 P            Read P bytes of data
Write     7 P ...        Write P bytes of data

.EE

.br
The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).

.br
The address and flags default to 0.  The address and flags maintain
their previous value until updated.

.br
No flags are currently defined.

.br

\fBExample\fP
.br

.EX
Set address 0x53
.br
start, write 0x32, (re)start, read 6 bytes, stop
.br
Set address 0x1E
.br
start, write 0x03, (re)start, read 6 bytes, stop
.br
Set address 0x68
.br
start, write 0x1B, (re)start, read 8 bytes, stop
.br
End
.br

.br
0x04 0x53
.br
0x02 0x07 0x01 0x32   0x02 0x06 0x06 0x03
.br

.br
0x04 0x1E
.br
0x02 0x07 0x01 0x03   0x02 0x06 0x06 0x03
.br

.br
0x04 0x68
.br
0x02 0x07 0x01 0x1B   0x02 0x06 0x08 0x03
.br

.br
0x00
.br

.EE

.br

.IP "\fBBR1 \fP - Read bank 1 GPIO"
.IP "" 4
This command read GPIO 0-31 (bank 1) and returns the levels as a
32-bit hexadecimal value.

.br

\fBExample\fP
.br

.EX
$ pigs br1
.br
1001C1CF
.br

.EE

.br

.IP "\fBBR2 \fP - Read bank 2 GPIO"
.IP "" 4
This command read GPIO 32-53 (bank 2) and returns the levels as a
32-bit hexadecimal value.

.br

\fBExample\fP
.br

.EX
$ pigs br2
.br
003F0000
.br

.EE

.br

.IP "\fBBS1 bits\fP - Set specified GPIO in bank 1"
.IP "" 4
This command sets (sets high) the GPIO specified by \fBbits\fP in bank 1.
Bank 1 consists of GPIO 0-31.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs bs1 16 # set GPIO 4 (1<<4)
.br

.br
$ pigs bs1 1 # set GPIO 1 (1<<0)
.br
-42
.br
ERROR: no permission to update one or more GPIO
.br

.EE

.br

.IP "\fBBS2 bits\fP - Set specified GPIO in bank 2"
.IP "" 4
This command sets (sets high) the GPIO specified by \fBbits\fP in bank 2.
Bank 2 consists of GPIO 32-53.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs bs2 0x40 # set GPIO 38 (enable high current mode A+/B+/Pi2/Pi3)
.br

.br
$ pigs bs2 1 # set GPIO 32 (first in bank 2)
.br
-42
.br
ERROR: no permission to update one or more GPIO
.br

.EE

.br

.IP "\fBBSCX bctl bvs\fP - BSC I2C/SPI transfer"
.IP "" 4

.br
This command performs a BSC I2C/SPI slave transfer as defined by
\fBbctl\fP with data \fBbvs\fP.

.br
I can't get SPI to work properly.  I tried with a
control word of 0x303 and swapped MISO and MOSI.

.br
The command sets the BSC mode and writes any data \fBbvs\fP
to the BSC transmit FIFO.  It returns the data count (at least 1
for the status word), the status word, followed by any data bytes
read from the BSC receive FIFO.

.br
Note that the control word sets the BSC mode.  The BSC will stay in
that mode until a different control word is sent.

.br
For I2C use a control word of (I2C address << 16) + 0x305.

.br
E.g. to talk as I2C slave with address 0x13 use 0x130305.

.br
The BSC peripheral uses GPIO 18 (SDA) and 19 (SCL) in I2C mode
and GPIO 18 (MOSI), 19 (SCLK), 20 (MISO), and 21 (CE) in SPI mode.  You
need to swap MISO/MOSI between master and slave.

.br
When a zero control word is received GPIO 18-21 will be reset
to INPUT mode.

.br
The control word consists of the following bits.

.br

.EX
22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 a  a  a  a  a  a  a  -  - IT HC TF IR RE TE BK EC ES PL PH I2 SP EN
.br

.EE

.br
Bits 0-13 are copied unchanged to the BSC CR register.  See
pages 163-165 of the Broadcom peripherals document for full
details.

.br

.EX
aaaaaaa   defines the I2C slave address (only relevant in I2C mode)
IT        invert transmit status flags
HC        enable host control
TF        enable test FIFO
IR        invert receive status flags
RE        enable receive
TE        enable transmit
BK        abort operation and clear FIFOs
EC        send control register as first I2C byte
ES        send status register as first I2C byte
PL        set SPI polarity high
PH        set SPI phase high
I2        enable I2C mode
SP        enable SPI mode
EN        enable BSC peripheral

.EE

.br
The returned status has the following format

.br

.EX
20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 S  S  S  S  S  R  R  R  R  R  T  T  T  T  T RB TE RF TF RE TB
.br

.EE

.br
Bits 0-15 are copied unchanged from the BSC FR register.  See
pages 165-166 of the Broadcom peripherals document for full
details.

.br

.EX
SSSSS   number of bytes successfully copied to transmit FIFO
RRRRR   number of bytes in receieve FIFO
TTTTT   number of bytes in transmit FIFO
RB      receive busy
TE      transmit FIFO empty
RF      receive FIFO full
TF      transmit FIFO full
RE      receive FIFO empty
TB      transmit busy

.EE

.br
This example assumes that GPIO 2/3 are connected to GPIO 18/19.

.br

\fBExample\fP
.br

.EX
$ pigs bscx 0x130305 # start BSC as I2C slave 0x13
.br
1 18
.br

.br
$ i2cdetect -y 1
.br
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
.br
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
.br
10: -- -- -- 13 -- -- -- -- -- -- -- -- -- -- -- --
.br
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
.br
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
.br
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
.br
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
.br
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
.br
70: -- -- -- -- -- -- -- --
.br

.br
$ pigs i2co 1 0x13 0 # get handle for device 0x13 on bus 1
.br
0
.br

.br
$ pigs i2cwd 0 90 87 51 9 23 # write 5 bytes
.br

.br
$ pigs bscx 0x130305 # check for data
.br
6 18 90 87 51 9 23
.br

.br
$ pigs bscx 0x130305 11 13 15 17 # check for data and send 4 bytes
.br
1 262338
.br

.br
$ pigs i2crd 0 4 # read 4 bytes
.br
4 11 13 15 17
.br

.br
$ pigs i2cwd 0 90 87 51 9 23 # write 5 bytes
.br
$ pigs bscx 0x130305 11 13 15 17 # check for data and send 4 bytes
.br
6 262338 90 87 51 9 23
.br

.br
$ pigs i2crd 0 4
.br
4 11 13 15 17
.br

.br
$ pigs bscx 0x130305 22 33 44 55 66
.br
1 327938
.br
$ pigs i2crd 0 5
.br
5 22 33 44 55 66
.br

.EE

.br

.IP "\fBBSPIC cs\fP - Close bit bang SPI"
.IP "" 4

.br
This command stops bit banging SPI on a set of GPIO
opened with \fBBSPIO\fP.

.br
The set of GPIO is specifed by \fBcs\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs bspic 10
.br

.br
$ pigs bspic 10
.br
-142
.br
ERROR: no bit bang SPI in progress on GPIO
.br

.EE

.br

.IP "\fBBSPIO cs miso mosi sclk b spf\fP - Open bit bang SPI"
.IP "" 4

.br
This command starts bit banging SPI on a group of GPIO with slave
select \fBcs\fP, MISO \fBmiso\fP, MOSI \fBmosi\fP, and clock \fBsclk\fP.

.br
Data will be transferred at baud \fBb\fP bits per second (which may
be set in the range 50-250000).

.br
The flags \fBspf\fP may be used to modify the default behaviour of
mode 0, active low chip select.

.br
The flags consists of the least significant 22 bits.

.br

.EX
21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 0  0  0  0  0  0  R  T  0  0  0  0  0  0  0  0  0  0  0  p  m  m
.br

.EE

.br
mm defines the SPI mode.

.br

.EX
Mode POL PHA
.br
 0    0   0
.br
 1    0   1
.br
 2    1   0
.br
 3    1   1
.br

.EE

.br
p is 0 if CS is active low (default) and 1 for active high.

.br
T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.

.br
R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.

.br
The other bits in flags should be set to zero.

.br
Upon success 0 is returned.  On error a negative status code
will be returned.

.br
If more than one device is connected to the SPI bus (defined by
SCLK, MOSI, and MISO) each must have its own CS.

.br

\fBExample\fP
.br

.EX
$ pigs bspio  9 11 12 13 50000 0
.br

.br
$ pigs bspio 10 11 12 13 50000 0
.br

.br
$ pigs bspio 29 19 20 21 50000 0 # GPIO 29 not avaialble on this Pi
.br
-41
.br
ERROR: no permission to update GPIO
.br

.EE

.br

.IP "\fBBSPIX cs bvs\fP - SPI bit bang transfer"
.IP "" 4

.br
This command writes bytes \fBbvs\fP to the bit bang SPI device
associated with slave select \fBcs\fP.  It returns the same
number of bytes read from the device.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs bspio 5 13 19 12 10000 0 # MCP4251 DAC
.br
$ pigs bspio 6 13 19 12 20000 3 # MCP3008 ADC
.br

.br
$ pigs bspix 5 0 16             # set DAC to 16
.br
2 255 255
.br

.br
$ pigs bspix 5 12 0             # read back DAC
.br
2 254 16
.br

.br
$ pigs bspix 6 1 128 0          # read ADC input 0
.br
3 0 3 184                       # 952
.br

.br
$ pigs bspix 5 0 240            # set DAC to 240
.br
2 255 255
.br

.br
$ pigs bspix 5 12 0             # read back DAC
.br
2 254 240
.br

.br
$ pigs bspix 6 1 128 0          # read ADC input 0
.br
3 0 0 63                        # 63
.br

.br
$ pigs bspix 5 0 128            # set DAC to 128
.br
2 255 255
.br

.br
$ pigs bspix 5 12 0             # read back DAC
.br
2 254 128
.br

.br
$ pigs bspix 6 1 128 0          # read ADC input 0
.br
3 0 1 255                       # 511
.br

.br
$ pigs bspic 5                  # close SPI CS 5
.br
$ pigs bspic 6                  # close SPI CS 6
.br

.br
$ pigs bspic 5                  # try to close SPI CS 5 again
.br
-142
.br
ERROR: no bit bang SPI in progress on GPIO
.br

.EE

.br

.br

.IP "\fBCF1 uvs\fP - Custom function 1"
.IP "" 4

.br
This command calls a user customised function.  The meaning of
any paramaters and the returned value is defined by the
customiser.

.br

.IP "\fBCF2 uvs\fP - Custom function 2"
.IP "" 4

.br
This command calls a user customised function.  The meaning of
any paramaters and the returned value is defined by the
customiser.

.br

.IP "\fBCGI \fP - Configuration get internals"
.IP "" 4
This command returns the value of the internal library
configuration settings.

.br

.IP "\fBCSI v\fP - Configuration set internals"
.IP "" 4
This command sets the value of the internal library
configuration settings to \fBv\fP.

.br

.IP "\fBEVM h bits\fP - Set events to monitor"
.IP "" 4
This command starts event reporting on handle \fBh\fP (returned by
a prior call to \fBNO\fP).

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The notification gets reports for each event specified by \fBbits\fP.

.br

\fBExample\fP
.br

.EX
$ pigs evm 0 -1 # Shorthand for events 0-31.
.br
$ pigs evm 0 0xf0 # Get notifications for events 4-7.
.br

.br
$ pigs evm 1 0xf
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBEVT event\fP - Trigger event"
.IP "" 4
This command triggers event \fBevent\fP.

.br
One event, number 31, is predefined.  This event is
auto generated on BSC slave activity.

.br

\fBExample\fP
.br

.EX
$ pigs evt 12
.br
$ pigs evt 5
.br

.br
$ pigs evt 32
.br
-143
.br
ERROR: bad event id
.br

.EE

.br

.IP "\fBFC h\fP - Close file handle"
.IP "" 4
This command closes a file handle \fBh\fP previously opened with \fBFO\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs fc 0 # First close okay.
.br

.br
$ pigs fc 0 # Second fails.
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBFG u stdy\fP - Set a glitch filter on a GPIO"
.IP "" 4

.br
Level changes on the GPIO \fBu\fP are not reported unless the level
has been stable for at least \fBstdy\fP microseconds.  The
level is then reported.  Level changes of less than \fBstdy\fP
microseconds are ignored.

.br
Note, each (stable) edge will be timestamped \fBstdy\fP microseconds
after it was first detected.

.br

\fBExample\fP
.br

.EX
$ pigs fg 4 250
.br

.br
$ pigs fg 4 1000000
.br
-125
.br
ERROR: bad filter parameter
.br

.EE

.br

.IP "\fBFL pat num\fP - List files which match pattern"
.IP "" 4
This command returns a list of the files matching \fBpat\fP. Up
to \fBnum\fP bytes may be returned.

.br
Upon success the count of returned bytes followed by the matching
files is returned.  On error a negative status code will be returned.

.br
A newline (0x0a) character separates each file name.

.br
Only files which have a matching entry in /opt/pigpio/access may
be listed.

.br
Suppose /opt/pigpio/access contains

.br
/sys/bus/w1/devices/28*/w1_slave r

.br

\fBExample\fP
.br

.EX
$ pigs -a fl "/sys/bus/w1/devices/28*/w1_slave" 5000
.br
90 /sys/bus/w1/devices/28-000005d34cd2/w1_slave
.br
/sys/bus/w1/devices/28-001414abbeff/w1_slave
.br

.br
$ pigs -a fl "/sys/bus/*" 5000
.br
ERROR: no permission to access file
.br
-137
.br

.EE

.br

.IP "\fBFN u stdy actv\fP - Set a noise filter on a GPIO"
.IP "" 4

.br
Level changes on the GPIO \fBu\fP are ignored until a level which has
been stable for \fBstdy\fP microseconds is detected.  Level
changes on the GPIO are then reported for \fBactv\fP microseconds
after which the process repeats.

.br
Note, level changes before and after the active period may
be reported.  Your software must be designed to cope with
such reports.

.br

\fBExample\fP
.br

.EX
$ pigs fn 7 250 1000
.br

.br
$ pigs fn 7 2500000 1000
.br
-125
.br
ERROR: bad filter parameter
.br

.EE

.br

.IP "\fBFO file mode\fP - Open a file in mode"
.IP "" 4
This function returns a handle to a file \fBfile\fP opened
in a specified mode \fBmode\fP.

.br
Upon success a handle (>=0) is returned.  On error a negative status code
will be returned.

.br
File

.br
A file may only be opened if permission is granted by an entry in
/opt/pigpio/access.  This is intended to allow remote access to files
in a more or less controlled manner.

.br
Each entry in /opt/pigpio/access takes the form of a file path
which may contain wildcards followed by a single letter permission.
The permission may be R for read, W for write, U for read/write,
and N for no access.

.br
Where more than one entry matches a file the most specific rule
applies.  If no entry matches a file then access is denied.

.br
Suppose /opt/pigpio/access contains the following entries

.br

.EX
/home/* n
.br
/home/pi/shared/dir_1/* w
.br
/home/pi/shared/dir_2/* r
.br
/home/pi/shared/dir_3/* u
.br
/home/pi/shared/dir_1/file.txt n
.br

.EE

.br
Files may be written in directory dir_1 with the exception
of file.txt.

.br
Files may be read in directory dir_2.

.br
Files may be read and written in directory dir_3.

.br
If a directory allows read, write, or read/write access then files may
be created in that directory.

.br
In an attempt to prevent risky permissions the following paths are
ignored in /opt/pigpio/access.

.br

.EX
a path containing ..
.br
a path containing only wildcards (*?)
.br
a path containing less than two non-wildcard parts
.br

.EE

.br
Mode

.br
The mode may have the following values.

.br

.EX
        Value   Meaning
READ      1     open file for reading
WRITE     2     open file for writing
RW        3     open file for reading and writing

.EE

.br
The following values may be or'd into the mode.

.br

.EX
         Value   Meaning
APPEND     4     All writes append data to the end of the file
CREATE     8     The file is created if it doesn't exist
TRUNC     16     The file is truncated

.EE

.br
Newly created files are owned by root with permissions owner read and write.

.br

\fBExample\fP
.br

.EX
$ ls /ram/*.c
.br
/ram/command.c      /ram/pigpiod.c  /ram/pigs.c
.br
/ram/x_pigpiod_if.c /ram/pig2vcd.c  /ram/pigpiod_if2.c
.br
/ram/x_pigpio.c     /ram/x_repeat.c /ram/pigpio.c
.br
/ram/pigpiod_if.c   /ram/x_pigpiod_if2.c
.br

.br
# assumes /opt/pigpio/access contains the following line
.br
# /ram/*.c r
.br

.br
$ pigs fo /ram/pigpio.c 1
.br
0
.br

.br
$ pigs fo /ram/new.c 1
.br
-128
.br
ERROR: file open failed
.br

.br
$ pigs fo /ram/new.c 9
.br
1
.br

.br
$ ls /ram/*.c -l
.br
-rw-r--r-- 1 joan joan  42923 Jul 10 11:22 /ram/command.c
.br
-rw------- 1 root root      0 Jul 10 16:54 /ram/new.c
.br
-rw-r--r-- 1 joan joan   2971 Jul 10 11:22 /ram/pig2vcd.c
.br
-rw------- 1 joan joan 296235 Jul 10 11:22 /ram/pigpio.c
.br
-rw-r--r-- 1 joan joan   9266 Jul 10 11:22 /ram/pigpiod.c
.br
-rw-r--r-- 1 joan joan  37331 Jul 10 11:22 /ram/pigpiod_if2.c
.br
-rw-r--r-- 1 joan joan  33088 Jul 10 11:22 /ram/pigpiod_if.c
.br
-rw-r--r-- 1 joan joan   7990 Jul 10 11:22 /ram/pigs.c
.br
-rw-r--r-- 1 joan joan  19970 Jul 10 11:22 /ram/x_pigpio.c
.br
-rw-r--r-- 1 joan joan  20804 Jul 10 11:22 /ram/x_pigpiod_if2.c
.br
-rw-r--r-- 1 joan joan  19844 Jul 10 11:22 /ram/x_pigpiod_if.c
.br
-rw-r--r-- 1 joan joan  19907 Jul 10 11:22 /ram/x_repeat.c
.br

.EE

.br

.IP "\fBFR h num\fP - Read bytes from file handle"
.IP "" 4
This command returns up to \fBnum\fP bytes of data read from the
file associated with handle \fBh\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs fr 0 10
.br
5 48 49 128 144 255
.br

.br
$ pigs fr 0 10
.br
0
.br

.EE

.br

.IP "\fBFS h num from\fP - Seek to file handle position"
.IP "" 4
This command seeks to a position within the file associated
with handle \fBh\fP.

.br
The number of bytes to move is \fBnum\fP.  Positive offsets
move forward, negative offsets backwards.  The move start
position is determined by \fBfrom\fP as follows.

.br

.EX
    From
0   start
1   current position
2   end

.EE

.br
Upon success the new byte position within the file (>=0) is
returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs fs 0 200 0 # Seek to start of file plus 200
.br
200
.br

.br
$ pigs fs 0 0 1 # Return current position
.br
200
.br

.br
$ pigs fs 0 0 2 # Seek to end of file, return size
.br
296235
.br

.EE

.br

.IP "\fBFW h bvs\fP - Write bytes to file handle"
.IP "" 4
This command writes bytes \fBbvs\fP to the file
associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs fw 0 23 45 67 89
.br

.EE

.br

.IP "\fBGDC u\fP - Get GPIO PWM dutycycle"
.IP "" 4

.br
This command returns the PWM dutycycle in use on GPIO \fBu\fP.

.br
Upon success the dutycycle is returned.  On error a negative
status code will be returned.

.br
For normal PWM the dutycycle will be out of the defined range
for the GPIO (see \fBPRG\fP).

.br
If a hardware clock is active on the GPIO the reported
dutycycle will be 500000 (500k) out of 1000000 (1M).

.br
If hardware PWM is active on the GPIO the reported dutycycle
will be out of a 1000000 (1M).

.br

\fBExample\fP
.br

.EX
$ pigs p 4 129
.br
$ pigs gdc 4
.br
129
.br

.br
pigs gdc 5
.br
-92
.br
ERROR: GPIO is not in use for PWM
.br

.EE

.br

.IP "\fBGPW u\fP - Get GPIO servo pulsewidth"
.IP "" 4

.br
This command returns the servo pulsewidth in use on GPIO \fBu\fP.

.br
Upon success the servo pulsewidth is returned.  On error a negative
status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs s 4 1235
.br
$ pigs gpw 4
.br
1235
.br

.br
$ pigs gpw 9
.br
-93
.br
ERROR: GPIO is not in use for servo pulses
.br

.EE

.br

.IP "\fBH/HELP \fP - Display command help"
.IP "" 4
This command displays a brief list of the commands and their parameters.

.br

\fBExample\fP
.br

.EX
$ pigs h
.br

.br
$ pigs help
.br

.EE

.br

.IP "\fBHC g cf\fP - Set hardware clock frequency"
.IP "" 4
This command sets the hardware clock associated with GPIO \fBg\fP to
frequency \fBcf\fP. Frequencies above 30MHz are unlikely to work.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs hc 4 5000 # start a 5 KHz clock on GPIO 4 (clock 0)
.br

.br
$ pigs hc 5 5000000 # start a 5 MHz clcok on GPIO 5 (clock 1)
.br
-99
.br
ERROR: need password to use hardware clock 1
.br

.EE

.br
The same clock is available on multiple GPIO.  The latest
frequency setting will be used by all GPIO which share a clock.

.br
The GPIO must be one of the following.

.br

.EX
4   clock 0  All models
5   clock 1  All models but A and B (reserved for system use)
6   clock 2  All models but A and B
20  clock 0  All models but A and B
21  clock 1  All models but A and B (Rev. 2) (reserved for system use)

.EE

.br

.EX
32  clock 0  Compute module only
34  clock 0  Compute module only
42  clock 1  Compute module only (reserved for system use)
43  clock 2  Compute module only
44  clock 1  Compute module only (reserved for system use)

.EE

.br
Access to clock 1 is protected by a password as its use will
likely crash the Pi.  The password is given by or'ing 0x5A000000
with the GPIO number.

.br

.IP "\fBHP g pf pdc\fP - Set hardware PWM frequency and dutycycle"
.IP "" 4
This command sets the hardware PWM associated with GPIO \fBg\fP to
frequency \fBpf\fP with dutycycle \fBpdc\fP. Frequencies above 30MHz
are unlikely to work.

.br
NOTE: Any waveform started by \fBWVTX\fP, \fBWVTXR\fP, or \fBWVCHA\fP
will be cancelled.

.br
This function is only valid if the pigpio main clock is PCM.  The
main clock defaults to PCM but may be overridden when the pigpio
daemon is started (option -t).

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

.EX
$ pigs hp 18 100 800000 # 80% dutycycle
.br

.br
$ pigs hp 19 100 200000 # 20% dutycycle
.br

.br
$ pigs hp 19 125000001 100000
.br
-96
.br
ERROR: hardware PWM frequency not 1-125M
.br

.EE

.br
The same PWM channel is available on multiple GPIO.  The latest
frequency and dutycycle setting will be used by all GPIO which
share a PWM channel.

.br
The GPIO must be one of the following.

.br

.EX
12  PWM channel 0  All models but A and B
13  PWM channel 1  All models but A and B
18  PWM channel 0  All models
19  PWM channel 1  All models but A and B

.EE

.br

.EX
40  PWM channel 0  Compute module only
41  PWM channel 1  Compute module only
45  PWM channel 1  Compute module only
52  PWM channel 0  Compute module only
53  PWM channel 1  Compute module only

.EE

.br
The actual number of steps beween off and fully on is the
integral part of 250 million divided by \fBpf\fP.

.br
The actual frequency set is 250 million / steps.

.br
There will only be a million steps for a \fBpf\fP of 250.
Lower frequencies will have more steps and higher
frequencies will have fewer steps.  \fBpdc\fP is
automatically scaled to take this into account.

.br

.IP "\fBHWVER \fP - Get hardware version"
.IP "" 4
This command returns the hardware revision of the Pi.

.br
The hardware revision is found in the last 4 characters on the revision
line of /proc/cpuinfo.

.br
If the hardware revision can not be found or is not a valid hexadecimal
number the command returns 0.

.br
The revision number can be used to determine the assignment of GPIO
to pins (see \fBg\fP).

.br
There are currently three types of board.

.br
Type 1 boards have hardware revision numbers of 2 and 3.

.br
Type 2 boards have hardware revision numbers of 4, 5, 6, and 15.

.br
Type 3 boards have hardware revision numbers of 16 or greater.

.br
for "Revision : 0002" the command returns 2.

.br
for "Revision : 000f" the command returns 15.

.br
for "Revision : 000g" the command returns 0.

.br

\fBExample\fP
.br

.EX
$ pigs hwver # On a B+
.br
16
.br

.EE

.br

.IP "\fBI2CC h\fP - Close I2C handle"
.IP "" 4
This command closes an I2C handle \fBh\fP previously opened with \fBI2CO\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cc 0 # First close okay.
.br

.br
$ pigs i2cc 0 # Second fails.
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBI2CO ib id if\fP - Open I2C bus and device with flags"
.IP "" 4
This command returns a handle to access device \fBid\fP on I2C bus \fBib\fP.
The device is opened with flags \fBif\fP.

.br
Physically buses 0 and 1 are available on the Pi.  Higher
numbered buses will be available if a kernel supported bus
multiplexor is being used.

.br
No flags are currently defined.  The parameter \fBif\fP should be 0.

.br
Upon success the next free handle (>=0) is returned.  On error a
negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2co 1 0x70 0 # Bus 1, device 0x70, flags 0.
.br
0
.br

.br
$ pigs i2co 1 0x53 0 # Bus 1, device 0x53, flags 0.
.br
1
.br

.EE

.br

.IP "\fBI2CPC h r wv\fP - smb Process Call: exchange register with word"
.IP "" 4
This command writes \fBwv\fP to register \fBr\fP of the I2C device
associated with handle \fBh\fP and returns a 16-bit word read from the
device.

.br
Upon success a value between 0 and 65535 will be returned.  On error
a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cpc 0 37 43210
.br
39933
.br

.br
$ pigs i2cpc 0 256 43210
.br
ERROR: bad i2c/spi/ser parameter
.br
-81
.br

.EE

.br

.IP "\fBI2CPK h r bvs\fP - smb Block Process Call: exchange data bytes with register"
.IP "" 4

.br
This command writes the data bytes \fBbvs\fP to register \fBr\fP of the I2C device
associated with handle \fBh\fP and returns a device specific number of bytes.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cpk 0 0 0x11 0x12
.br
6 0 0 0 0 0 0
.br

.EE

.br

.IP "\fBI2CRB h r\fP - smb Read Byte Data: read byte from register"
.IP "" 4

.br
This command returns a single byte read from register \fBr\fP of the I2C device
associated with handle \fBh\fP.

.br
Upon success a value between 0 and 255 will be returned.  On error
a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2crb 0 0
.br
6
.br

.EE

.br

.IP "\fBI2CRD h num\fP - i2c Read bytes"
.IP "" 4

.br
This command returns \fBnum\fP bytes read from the I2C device associated with
handle \fBh\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br
This command operates on the raw I2C device.  The maximum value of the
parameter \fBnum\fP is dependent on the I2C drivers and the device
itself. pigs imposes a limit of about 8000 bytes.

.br

\fBExample\fP
.br

.EX
$ pigs i2crd 0 16
.br
16 6 24 0 0 0 0 0 0 0 0 0 0 0 0 32 78
.br

.EE

.br

.IP "\fBI2CRI h r num\fP - smb Read I2C Block Data: read bytes from register"
.IP "" 4

.br
This command returns \fBnum\fP bytes from register \fBr\fP of the I2C device
associated with handle \fBh\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br
The parameter \fBnum\fP may be 1-32.

.br

\fBExample\fP
.br

.EX
$ pigs i2cri 0 0 16
.br
16 237 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155
.br

.EE

.br

.IP "\fBI2CRK h r\fP - smb Read Block Data: read data from register"
.IP "" 4

.br
This command returns between 1 and 32 bytes read from register \fBr\fP of
the I2C device associated with handle \fBh\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br
The number of bytes of returned data is specific to the device and
register.

.br

\fBExample\fP
.br

.EX
$ pigs i2crk 0 0
.br
6 0 0 0 0 0 0
.br

.br
$ pigs i2crk 0 1
.br
24 0 0 0 0 0 0 0 0 0 0 0 0 120 222 105 215 128 87 195 217 0 0 0 0
.br

.EE

.br

.IP "\fBI2CRS h\fP - smb Read Byte: read byte"
.IP "" 4

.br
This command returns a single byte read from the I2C device
associated with handle \fBh\fP.

.br
Upon success a value between 0 and 255 will be returned.  On error
a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2crs 0
.br
0
.br

.EE

.br

.IP "\fBI2CRW h r\fP - smb Read Word Data: read word from register"
.IP "" 4

.br
This command returns a single 16 bit word read from register \fBr\fP of
the I2C device associated with handle \fBh\fP.

.br
Upon success a value between 0 and 65535 will be returned.  On error
a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2crw 0 0
.br
6150
.br

.EE

.br

.IP "\fBI2CWB h r bv\fP - smb Write Byte Data: write byte to register"
.IP "" 4

.br
This command writes a single byte \fBbv\fP to register \fBr\fP of the
I2C device associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cwb 0 10 0x54
.br

.EE

.br

.IP "\fBI2CWD h bvs\fP - i2c Write data"
.IP "" 4

.br
This command writes a block of bytes \fBbvs\fP to the I2C device
associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The number of bytes which may be written in one transaction is
dependent on the I2C drivers and the device itself.  pigs imposes
a limit of about 500 bytes.

.br
This command operates on the raw I2C device.

.br

\fBExample\fP
.br

.EX
$ pigs i2cwd 0 0x01 0x02 0x03 0x04
.br

.EE

.br

.IP "\fBI2CWI h r bvs\fP - smb Write I2C Block Data"
.IP "" 4

.br
This command writes between 1 and 32 bytes \fBbvs\fP to register \fBr\fP of
the I2C device associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cwi 0 4 0x01 0x04 0xc0
.br

.EE

.br

.IP "\fBI2CWK h r bvs\fP - smb Write Block Data: write data to register"
.IP "" 4

.br
This command writes between 1 and 32 bytes \fBbvs\fP to register \fBr\fP of
the I2C device associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
pigs i2cwk 0 4 0x01 0x04 0xc0
.br

.EE

.br

.IP "\fBI2CWQ h bit\fP - smb Write Quick: write bit"
.IP "" 4

.br
This command writes a single \fBbit\fP to the I2C device associated
with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cwq 0 1
.br

.EE

.br

.IP "\fBI2CWS h bv\fP - smb Write Byte: write byte"
.IP "" 4

.br
This command writes a single byte \fBbv\fP to the I2C device associated
with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cws 0 0x12
.br

.br
$ pigs i2cws 0 0xff
.br
-82
.br
ERROR: I2C write failed
.br

.EE

.br

.IP "\fBI2CWW h r wv\fP - smb Write Word Data: write word to register"
.IP "" 4

.br
This command writes a single 16 bit word \fBwv\fP to register \fBr\fP of
the I2C device associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs i2cww 0 0 0xffff
.br

.EE

.br

.IP "\fBI2CZ h bvs\fP - Performs multiple I2C transactions"
.IP "" 4
This command executes a sequence of I2C operations.  The
operations to be performed are specified by the contents of \fBbvs\fP
which contains the concatenated command codes and associated data.

.br
The following command codes are supported:

.br

.EX
Name      Cmd & Data   Meaning
End       0            No more commands
Escape    1            Next P is two bytes
On        2            Switch combined flag on
Off       3            Switch combined flag off
Address   4 P          Set I2C address to P
Flags     5 lsb msb    Set I2C flags to lsb + (msb << 8)
Read      6 P          Read P bytes of data
Write     7 P ...      Write P bytes of data

.EE

.br
The address, read, and write commands take a parameter P.
Normally P is one byte (0-255).  If the command is preceded by
the Escape command then P is two bytes (0-65535, least significant
byte first).

.br
The address defaults to that associated with the handle \fBh\fP.
The flags default to 0.  The address and flags maintain their
previous value until updated.

.br

\fBExample\fP
.br

.EX
Set address 0x53, write 0x32, read 6 bytes
.br
Set address 0x1E, write 0x03, read 6 bytes
.br
Set address 0x68, write 0x1B, read 8 bytes
.br
End
.br

.br
0x04 0x53   0x07 0x01 0x32   0x06 0x06
.br
0x04 0x1E   0x07 0x01 0x03   0x06 0x06
.br
0x04 0x68   0x07 0x01 0x1B   0x06 0x08
.br
0x00
.br

.EE

.br

.br

.IP "\fBM/MODES g m\fP - Set GPIO mode"
.IP "" 4

.br
This command sets GPIO \fBg\fP to mode \fBm\fP, typically input (read)
or output (write).

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
Each GPIO can be configured to be in one of 8 different modes. The modes
are named Input, Output, ALT0, ALT1, ALT2, ALT3, ALT4, and ALT5.

.br
To set the mode use the code for the mode.

.br

.EX
Mode  Input Output ALT0 ALT1 ALT2 ALT3 ALT4 ALT5
Code      R      W    0    1    2    3    4    5

.EE

.br

\fBExample\fP
.br

.EX
$ pigs m 4 r # Input (read)
.br
$ pigs m 4 w # Output (write)
.br
$ pigs m 4 0 # ALT 0
.br
$ pigs m 4 5 # ALT 5
.br

.EE

.br

.IP "\fBMG/MODEG g\fP - Get GPIO mode"
.IP "" 4

.br
This command returns the current mode of GPIO \fBg\fP.

.br
Upon success the value of the GPIO mode is returned.
On error a negative status code will be returned.

.br

.EX
Value      0      1    2    3    4    5    6    7
Mode   Input Output ALT5 ALT4 ALT0 ALT1 ALT2 ALT3

.EE

.br

\fBExample\fP
.br

.EX
$ pigs mg 4
.br
1
.br

.EE

.br

.IP "\fBMICS v\fP - Microseconds delay"
.IP "" 4
This command delays execution for \fBv\fP microseconds.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The main use of this command is expected to be within \fBScripts\fP.

.br

\fBExample\fP
.br

.EX
$ pigs mics 20 # Delay 20 microseconds.
.br
$ pigs mics 1000000 # Delay 1 second.
.br

.br
$ pigs mics 2000000
.br
-64
.br
ERROR: bad MICS delay (too large)
.br

.EE

.br

.IP "\fBMILS v\fP - Milliseconds delay"
.IP "" 4

.br
This command delays execution for \fBv\fP milliseconds.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs mils 2000 # Delay 2 seconds.
.br

.br
$ pigs mils 61000
.br
-65
.br
ERROR: bad MILS delay (too large)
.br

.EE

.br

.IP "\fBNB h bits\fP - Start notification"
.IP "" 4

.br
This command starts notifications on handle \fBh\fP returned by
a prior call to \fBNO\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The notification gets state changes for each GPIO specified by \fBbits\fP.

.br

\fBExample\fP
.br

.EX
$ pigs nb 0 -1 # Shorthand for GPIO 0-31.
.br
$ pigs nb 0 0xf0 # Get notifications for GPIO 4-7.
.br

.br
$ pigs nb 1 0xf
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBNC h\fP - Close notification"
.IP "" 4

.br
This command stops notifications on handle \fBh\fP returned by
a prior call to \fBNO\fP and releases the handle for reuse.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs nc 0 # First call succeeds.
.br

.br
$ pigs nc 1 # Second call fails.
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBNO \fP - Request a notification"
.IP "" 4

.br
This command requests a free notification handle.

.br
A notification is a method for being notified of GPIO state changes via a pipe.

.br
Upon success the command returns a handle greater than or equal to zero.
On error a negative status code will be returned.

.br
Notifications for handle x will be available at the pipe named /dev/pigpiox
(where x is the handle number).

.br
E.g. if the command returns 15 then the notifications must be read
from /dev/pigpio15.

.br

\fBExample\fP
.br

.EX
$ pigs no
.br
0
.br

.EE

.br

.IP "\fBNP h\fP - Pause notification"
.IP "" 4

.br
This command pauses notifications on handle \fBh\fP returned by
a prior call to \fBNO\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
Notifications for the handle are suspended until a new \fBNB\fP command
is given for the handle.

.br

\fBExample\fP
.br

.EX
$ pigs np 0
.br

.EE

.br

.IP "\fBP/PWM u v\fP - Set GPIO PWM value"
.IP "" 4

.br
This command starts PWM on GPIO \fBu\fP with dutycycle \fBv\fP.  The dutycycle
varies from 0 (off) to range (fully on).  The range defaults to 255.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
This and the servo functionality use the DMA and PWM or PCM peripherals
to control and schedule the pulsewidths and dutycycles.

.br
The \fBPRS\fP command may be used to change the default range of 255.

.br

\fBExample\fP
.br

.EX
$ pigs p 4 64  # Start PWM on GPIO 4 with 25% dutycycle
.br
$ pigs p 4 128 # 50%
.br
$ pigs p 4 192 # 75%
.br
$ pigs p 4 255 # 100%
.br

.EE

.br

.IP "\fBPADG pad\fP - Get pad drive strength"
.IP "" 4

.br
This command gets the \fBpad\fP drive strength \fBpadma\fP in mA.

.br
Returns the pad drive strength if OK.  On error a negative status code
will be returned.

.br

.EX
Pad   GPIO
0     0-27
1     28-45
2     46-53

.EE

.br

\fBExample\fP
.br

.EX
$ pigs padg 0
.br
8
.br
$ pigs pads 0 16
.br
$ pigs padg 0
.br
16
.br
pigs padg 3
.br
-126
.br
ERROR: bad pad number
.br

.EE

.br

.IP "\fBPADS pad padma\fP - Set pad drive strength"
.IP "" 4

.br
This command sets the \fBpad\fP drive strength \fBpadma\fP in mA.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

.EX
Pad   GPIO
0     0-27
1     28-45
2     46-53

.EE

.br

\fBExample\fP
.br

.EX
$ pigs pads 0 16
.br
$ pigs padg 0
.br
16
.br
$ pigs pads 0 17
.br
-127
.br
ERROR: bad pad drive strength
.br

.EE

.br

.IP "\fBPARSE t\fP - Validate script"
.IP "" 4

.br
Validates the text \fBt\fP of a script without storing the script.

.br
Upon success nothing is returned.  On error a list of detected
script errors will be given.

.br
See \fBScripts\fP.

.br
This command may be used to find script syntax faults.

.br

\fBExample\fP
.br

.EX
$ pigs parse tag 100 w 22 1 mils 200 w 22 0 mils 800 jmp 100
.br

.br
$ pigs parse tag 0 w 22 1 mills 50 w 22 0 dcr p10 jp 99
.br
Unknown command: mills
.br
Unknown command: 50
.br
Bad parameter to dcr
.br
Can't resolve tag 99
.br

.EE

.br

.IP "\fBPFG u\fP - Get GPIO PWM frequency"
.IP "" 4

.br
This command returns the PWM frequency in Hz used for GPIO \fBu\fP.

.br
Upon success the PWM frequency is returned.  On error a negative
status code will be returned.

.br
For normal PWM the frequency will be that defined for the GPIO
by \fBPFS\fP.

.br
If a hardware clock is active on the GPIO the reported frequency
will be that set by \fBHC\fP.

.br
If hardware PWM is active on the GPIO the reported frequency
will be that set by \fBHP\fP.

.br

\fBExample\fP
.br

.EX
$ pigs pfg 4
.br
800
.br

.br
$ pigs pfg 34
.br
ERROR: GPIO not 0-31
.br
-2
.br

.EE

.br

.IP "\fBPFS u v\fP - Set GPIO PWM frequency"
.IP "" 4
This command sets the PWM frequency \fBv\fP to be used for GPIO \fBu\fP.

.br
The numerically closest frequency to \fBv\fP will be selected.

.br
Upon success the new frequency is returned.  On error a negative status code
will be returned.

.br
If PWM is currently active on the GPIO it will be
switched off and then back on at the new frequency.

.br
Each GPIO can be independently set to one of 18 different PWM
frequencies.

.br
The selectable frequencies depend upon the sample rate which
may be 1, 2, 4, 5, 8, or 10 microseconds (default 5).  The
sample rate is set when the pigpio daemon is started.

.br
The frequencies for each sample rate are:

.br

.EX
                       Hertz
.br

.br
       1: 40000 20000 10000 8000 5000 4000 2500 2000 1600
.br
           1250  1000   800  500  400  250  200  100   50
.br

.br
       2: 20000 10000  5000 4000 2500 2000 1250 1000  800
.br
            625   500   400  250  200  125  100   50   25
.br

.br
       4: 10000  5000  2500 2000 1250 1000  625  500  400
.br
            313   250   200  125  100   63   50   25   13
.br
sample
.br
 rate
.br
 (us)  5:  8000  4000  2000 1600 1000  800  500  400  320
.br
            250   200   160  100   80   50   40   20   10
.br

.br
       8:  5000  2500  1250 1000  625  500  313  250  200
.br
            156   125   100   63   50   31   25   13    6
.br

.br
      10:  4000  2000  1000  800  500  400  250  200  160
.br
            125   100    80   50   40   25   20   10    5
.br

.EE

.br

\fBExample\fP
.br

.EX
pigs pfs 4 0 # 0 selects the lowest frequency.
.br
10
.br

.br
$ pigs pfs 4 1000 # Set 1000Hz PWM.
.br
1000
.br

.br
$ pigs pfs 4 100000 # Very big number selects the highest frequency.
.br
8000
.br

.EE

.br

.IP "\fBPIGPV \fP - Get pigpio library version"
.IP "" 4

.br
This command returns the pigpio library version.

.br

\fBExample\fP
.br

.EX
$ pigs pigpv
.br
17
.br

.EE

.br

.IP "\fBPRG u\fP - Get GPIO PWM range"
.IP "" 4

.br
This command returns the dutycycle range for GPIO \fBu\fP.

.br
Upon success the range is returned.  On error a negative status code
will be returned.

.br
If a hardware clock or hardware PWM is active on the GPIO the reported
range will be 1000000 (1M).

.br

\fBExample\fP
.br

.EX
$ pigs prg 4
.br
255
.br

.EE

.br

.IP "\fBPROC t\fP - Store script"
.IP "" 4

.br
This command stores a script \fBt\fP for later execution.

.br
If the script is valid a script id (>=0) is returned which is passed
to the other script commands. On error a negative status code
will be returned.

.br
See \fBScripts\fP.

.br

\fBExample\fP
.br

.EX
$ pigs proc tag 123 w 4 0 mils 200 w 4 1 mils 300 dcr p0 jp 123
.br
0
.br

.br
$ pigs proc tag 123 w 4 0 mils 5 w 4 1 mils 5 jmp 12
.br
ERROR: script has unresolved tag
.br
-63
.br

.EE

.br

.IP "\fBPROCD sid\fP - Delete script"
.IP "" 4

.br
This command deletes script \fBsid\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
See \fBScripts\fP.

.br

\fBExample\fP
.br

.EX
$ pigs procd 1
.br

.br
$ pigs procd 1
.br
ERROR: unknown script id
.br
-48
.br

.EE

.br

.IP "\fBPROCP sid\fP - Get script status and parameters"
.IP "" 4

.br
This command returns the status of script \fBsid\fP as well as the
current value of its 10 parameters.

.br
Upon success the script status and parameters are  returned.
On error a negative status code will be returned.

.br
The script status may be one of

.br

.EX
0   being initialised
1   halted
2   running
3   waiting
4   failed

.EE

.br
See \fBScripts\fP.

.br

\fBExample\fP
.br

.EX
$ pigs procp 0
.br
1 0 0 0 0 0 0 0 0 0 0
.br

.EE

.br

.IP "\fBPROCR sid pars\fP - Run script"
.IP "" 4

.br
This command runs stored script \fBsid\fP passing it up to 10 optional
parameters.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
See \fBScripts\fP.

.br

\fBExample\fP
.br

.EX
$ pigs proc tag 123 w 4 0 mils 200 w 4 1 mils 300 dcr p0 jp 123
.br
0
.br

.br
$ pigs procr 0 50 # Run script 0 with parameter 0 of 50.
.br

.br
$ pigs procp 0
.br
2 44 0 0 0 0 0 0 0 0 0
.br
$ pigs procp 0
.br
2 37 0 0 0 0 0 0 0 0 0
.br
$ pigs procp 0
.br
2 10 0 0 0 0 0 0 0 0 0
.br
$ pigs procp 0
.br
2 5 0 0 0 0 0 0 0 0 0
.br
$ pigs procp 0
.br
2 2 0 0 0 0 0 0 0 0 0
.br
$ pigs procp 0
.br
1 -1 0 0 0 0 0 0 0 0 0
.br

.EE

.br

.IP "\fBPROCS sid\fP - Stop script"
.IP "" 4

.br
This command stops a running script \fBsid\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
See \fBScripts\fP.

.br

\fBExample\fP
.br

.EX
$ pigs procs 0
.br

.br
$ pigs procs 1
.br
-48
.br
ERROR: unknown script id
.br

.EE

.br

.IP "\fBPRRG u\fP - Get GPIO PWM real range"
.IP "" 4

.br
This command returns the real underlying range used by GPIO \fBu\fP.

.br
If a hardware clock is active on the GPIO the reported
real range will be 1000000 (1M).

.br
If hardware PWM is active on the GPIO the reported real range
will be approximately 250M divided by the set PWM frequency.

.br
On error a negative status code will be returned.

.br
See \fBPRS\fP.

.br

\fBExample\fP
.br

.EX
$ pigs prrg 17
.br
250
.br

.br
$ pigs pfs 17 0
.br
10
.br
$ pigs prrg 17
.br
20000
.br

.br
$ pigs pfs 17 100000
.br
8000
.br
$ pigs prrg 17
.br
25
.br

.EE

.br

.IP "\fBPRS u v\fP - Set GPIO PWM range"
.IP "" 4

.br
This command sets the dutycycle range \fBv\fP to be used for GPIO \fBu\fP.
Subsequent uses of command \fBP/PWM\fP will use a dutycycle between 0 (off)
and \fBv\fP (fully on).

.br
Upon success the real underlying range used by the GPIO is returned.
On error a negative status code will be returned.

.br
If PWM is currently active on the GPIO its dutycycle will be scaled to
reflect the new range.

.br
The real range, the number of steps between fully off and fully on
for each frequency, is given in the following table.

.br

.EX
 #1   #2   #3   #4   #5   #6   #7    #8    #9
 25   50  100  125  200  250  400   500   625
                                        
#10  #11  #12  #13  #14  #15  #16   #17   #18
800 1000 1250 2000 2500 4000 5000 10000 20000

.EE

.br
The real value set by \fBPRS\fP is (dutycycle * real range) / range.

.br
See \fBPRRG\fP

.br

\fBExample\fP
.br

.EX
$ pigs prs 18 1000
.br
250
.br

.EE

.br

.IP "\fBPUD g p\fP - Set GPIO pull up/down"
.IP "" 4

.br
This command sets the internal pull/up down for GPIO \fBg\fP to mode \fBp\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The mode may be pull-down (D), pull-up (U), or off (O).

.br

\fBExample\fP
.br

.EX
$ pigs pud 4 d # Set pull-down on GPIO 4.
.br
$ pigs pud 4 u # Set pull-up on GPIO 4.
.br
$ pigs pud 4 o # No pull-up/down on GPIO 4.
.br

.EE

.br

.IP "\fBR/READ g\fP - Read GPIO level"
.IP "" 4

.br
This reads the current level of GPIO \fBg\fP.

.br
Upon success the current level is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs r 17 # Get level of GPIO 17.
.br
0
.br

.br
$ pigs r 4 # Get level of GPIO 4.
.br
1
.br

.EE

.br

.IP "\fBS/SERVO u v\fP - Set GPIO servo pulsewidth"
.IP "" 4

.br
This command starts servo pulses of \fBv\fP microseconds on GPIO \fBu\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The servo pulsewidth may be 0 (off), 500 (most anti-clockwise)
to 2500 (most clockwise).

.br
The range supported by servos varies and should probably be determined
by experiment. Generally values between 1000-2000 should be safe.
A value of 1500 should always be safe and represents
the mid-point of rotation.

.br
You can DAMAGE a servo if you command it to move beyond its limits.

.br

\fBExample\fP
.br

.EX
$ pigs SERVO 17 1500
.br

.EE

.br
This example causes an on pulse of 1500 microseconds duration to be
transmitted on GPIO 17 at a rate of 50 times per second.

.br
This will command a servo connected to GPIO 17 to rotate to its mid-point.

.br

\fBExample\fP
.br

.EX
pigs s 17 0 # Switch servo pulses off.
.br

.EE

.br

.IP "\fBSERC h\fP - Close serial handle"
.IP "" 4

.br
This command closes a serial handle \fBh\fP previously opened with \fBSERO\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs serc 0 # First close okay.
.br

.br
$ pigs serc 0 # Second close gives error.
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBSERDA h\fP - Check for serial data ready to read"
.IP "" 4

.br
This command returns the number of bytes of data available
to be read from the serial device associated with handle \fBh\fP.

.br
Upon success the count of bytes available to be read is
returned (which may be 0).  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs serda 0
.br
0
.br

.EE

.br

.IP "\fBSERO dev b sef\fP - Open serial device dev at baud b with flags"
.IP "" 4

.br
This command opens the serial \fBdev\fP at \fBb\fP bits per second.

.br
No flags are currently defined.  \fBsef\fP should be set to zero.

.br
Upon success a handle (>=0) is returned.  On error a negative status code
will be returned.

.br
The device name must start with /dev/tty or /dev/serial.

.br

.br
The baud rate must be one of 50, 75, 110, 134, 150,
200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200,
38400, 57600, 115200, or 230400.

.br

\fBExample\fP
.br

.EX
$ pigs sero /dev/ttyAMA0 9600 0
.br
0
.br

.br
$ pigs sero /dev/tty1 38400 0
.br
1
.br

.EE

.br

.IP "\fBSERR h num\fP - Read bytes from serial handle"
.IP "" 4

.br
This command returns up to \fBnum\fP bytes of data read from the
serial device associated with handle \fBh\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs serr 0 10
.br
5 48 49 128 144 255
.br

.br
$ pigs serr 0 10
.br
0
.br

.EE

.br

.IP "\fBSERRB \fP - Read byte from serial handle"
.IP "" 4

.br
This command returns a byte of data read from the serial
device associated with handle \fBh\fP.

.br
Upon success a number between 0 and 255 is returned.
On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs serrb 0
.br
23
.br
$ pigs serrb 0
.br
45
.br

.EE

.br

.IP "\fBSERW h bvs\fP - Write bytes to serial handle"
.IP "" 4

.br
This command writes bytes \fBbvs\fP to the serial device
associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs serw 0 23 45 67 89
.br

.EE

.br

.IP "\fBSERWB h bv\fP - Write byte to serial handle"
.IP "" 4

.br
This command writes a single byte \fBbv\fP to the serial device
associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs serwb 0 23
.br
$ pigs serwb 0 0xf0
.br

.EE

.br

.IP "\fBSHELL name str\fP - Execute a shell command"
.IP "" 4

.br
This command uses the system call to execute a shell script \fBname\fP
with the given string \fBstr\fP as its parameter.

.br
The exit status of the system call is returned if OK, otherwise
PI_BAD_SHELL_STATUS.

.br
\fBname\fP must exist in /opt/pigpio/cgi and must be executable.

.br
The returned exit status is normally 256 times that set
by the shell script exit function.  If the script can't
be found 32512 will be returned.

.br
The following table gives some example returned statuses.

.br

.EX
Script exit status   Returned system call status
1                    256
5                    1280
10                   2560
200                  51200
script not found     32512

.EE

.br

\fBExample\fP
.br

.EX
# pass two parameters, hello and world
.br
$ pigs shell scr1 hello world
.br
256
.br

.br
# pass three parameters, hello, string with spaces, and world
.br
$ pigs shell scr1 "hello 'string with spaces' world"
.br
256
.br

.br
# pass one parameter, hello string with spaces world
.br
$ pigs shell scr1 "\"hello string with spaces world\""
.br
256
.br

.br
# non-existent script
.br
$ pigs shell scr78 par1
.br
32512
.br

.EE

.br

.IP "\fBSLR u num\fP - Read bit bang serial data from GPIO"
.IP "" 4

.br
This command returns up to \fBnum\fP bytes of bit bang serial data
read from GPIO \fBu\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br
The GPIO \fBu\fP should have been initialised with the \fBSLRO\fP command.

.br
The bytes returned for each character depend upon the number of
data bits \fBdb\fP specified in the \fBSLRO\fP command.

.br
For \fBdb\fP 1-8 there will be one byte per character.
.br
For \fBdb\fP 9-16 there will be two bytes per character.
.br
For \fBdb\fP 17-32 there will be four bytes per character.

.br

\fBExample\fP
.br

.EX
$ pigs slr 15 20
.br
6 1 0 23 45 89 0
.br

.EE

.br

.IP "\fBSLRC u\fP - Close GPIO for bit bang serial data"
.IP "" 4

.br
This command closes GPIO \fBu\fP for reading bit bang serial data.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs slrc 23
.br

.br
$ pigs slrc 23
.br
-38
.br
ERROR: no serial read in progress on GPIO
.br

.EE

.br

.IP "\fBSLRI u v\fP - Sets bit bang serial data logic levels"
.IP "" 4

.br
This command sets the logic level for reading bit bang serial data
on GPIO \fBu\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The invert parameter \fBv\fP is 1 for inverted signal, 0 for normal.

.br

\fBExample\fP
.br

.EX
$ pigs slri 17 1 # invert logic on GPIO 17
.br

.br
$ pigs slri 23 0 # use normal logic on GPIO 23
.br

.EE

.br

.IP "\fBSLRO u b db\fP - Open GPIO for bit bang serial data"
.IP "" 4

.br
This command opens GPIO \fBu\fP for reading bit bang serial data
at \fBb\fP baud and \fBdb\fP data bits.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The baud rate may be between 50 and 250000 bits per second.

.br
The received data is held in a cyclic buffer.

.br
It is the user's responsibility to read the data (with \fBSLR\fP)
in a timely fashion.

.br

\fBExample\fP
.br

.EX
$ pigs slro 23 19200 8
.br

.br
$ pigs slro 23 19200 8
.br
-50
.br
ERROR: GPIO already in use
.br

.EE

.br

.IP "\fBSPIC h\fP - SPI close handle"
.IP "" 4

.br
This command closes the SPI handle \fBh\fP returned by a prior
call to \fBSPIO\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs spic 1
.br

.br
$ pigs spic 1
.br
-25
.br
ERROR: unknown handle
.br

.EE

.br

.IP "\fBSPIO c b spf\fP - SPI open channel at baud b with flags"
.IP "" 4

.br
This command returns a handle to a SPI device on channel \fBc\fP.

.br
Data will be transferred at \fBb\fP bits per second.  The flags \fBspf\fP
may be used to modify the default behaviour of 4-wire operation,
mode 0, active low chip select.

.br
Speeds between 32kbps and 125Mbps are allowed.  Speeds above 30Mbps
are unlikely to work.

.br
An auxiliary SPI device is available on all models but the
A and B and may be selected by setting the A bit in the
flags.  The auxiliary device has 3 chip selects and a
selectable word size in bits.

.br
The flags consists of the least significant 22 bits.

.br

.EX
21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
.br
 b  b  b  b  b  b  R  T  n  n  n  n  W  A u2 u1 u0 p2 p1 p0  m  m
.br

.EE

.br
mm defines the SPI mode.

.br
Warning:  modes 1 and 3 do not appear to work on the auxiliary device.

.br

.EX
Mode POL PHA
.br
 0    0   0
.br
 1    0   1
.br
 2    1   0
.br
 3    1   1
.br

.EE

.br
px is 0 if CEx is active low (default) and 1 for active high.

.br
ux is 0 if the CEx GPIO is reserved for SPI (default) and 1 otherwise.

.br
A is 0 for the standard SPI device, 1 for the auxiliary SPI.

.br
W is 0 if the device is not 3-wire, 1 if the device is 3-wire.  Standard
SPI device only.

.br
nnnn defines the number of bytes (0-15) to write before switching
the MOSI line to MISO to read data.  This field is ignored
if W is not set.  Standard SPI device only.

.br
T is 1 if the least significant bit is transmitted on MOSI first, the
default (0) shifts the most significant bit out first.  Auxiliary SPI
device only.

.br
R is 1 if the least significant bit is received on MISO first, the
default (0) receives the most significant bit first.  Auxiliary SPI
device only.

.br
bbbbbb defines the word size in bits (0-32).  The default (0)
sets 8 bits per word.  Auxiliary SPI device only.

.br
The \fBSPIR\fP, \fBSPIW\fP, and \fBSPIX\fP commands transfer data
packed into 1, 2, or 4 bytes according to the word size in bits.

.br
For bits 1-8 there will be one byte per character.
.br
For bits 9-16 there will be two bytes per character.
.br
For bits 17-32 there will be four bytes per character.

.br
E.g. 32 12-bit words will be transferred in 64 bytes.

.br
The other bits in flags should be set to zero.

.br
Upon success a handle (>=0) is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs spio 0 100000 3 # Open channel 0 at 100kbps in mode 3.
.br
0
.br

.br
$ pigs spio 0 32000 256 # Open channel 0 of auxiliary spi at 32kbps.
.br
1
.br

.EE

.br

.IP "\fBSPIR h num\fP - SPI read bytes from handle"
.IP "" 4

.br
This command returns \fBnum\fP bytes read from the SPI device
associated with handle \fBh\fP.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs spir 0 10 # Read 10 bytes from the SPI device.
.br
10 0 0 0 0 0 0 0 0 0 0
.br

.EE

.br

.IP "\fBSPIW h bvs\fP - SPI write bytes to handle"
.IP "" 4

.br
This command writes bytes \fBbvs\fP to the SPI device
associated with handle \fBh\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs spiw 0 0x22 0x33 0xcc 0xff
.br

.EE

.br

.IP "\fBSPIX h bvs\fP - SPI transfer bytes to handle"
.IP "" 4

.br
This command writes bytes \fBbvs\fP to the SPI device
associated with handle \fBh\fP.  It returns the same
number of bytes read from the device.

.br
Upon success the count of returned bytes followed by the bytes themselves
is returned.  On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs spix 0 0x22 0x33 0xcc 0xff
.br
4 0 0 0 0
.br

.EE

.br

.IP "\fBT/TICK \fP - Get current tick"
.IP "" 4

.br
This command returns the current system tick.

.br
Tick is the number of microseconds since system boot.

.br
As tick is an unsigned 32 bit quantity it wraps around after 2^32 microseconds,
which is approximately 1 hour 12 minutes.

.br

\fBExample\fP
.br

.EX
$ pigs t mils 1000 t
.br
3691823946
.br
3692833987
.br

.EE

.br

.IP "\fBTRIG u pl L\fP - Send a trigger pulse"
.IP "" 4

.br
This command sends a trigger pulse of \fBpl\fP microseconds at level \fBL\fP
to GPIO \fBu\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The GPIO is set to not level at the end of the pulse.

.br

\fBExample\fP
.br

.EX
$ pigs trig 4 10 1
.br

.br
$ pigs trig 4 51 1
.br
-46
.br
ERROR: trigger pulse > 50 microseconds
.br

.EE

.br

.IP "\fBW/WRITE g L\fP - Write GPIO level"
.IP "" 4

.br
This command sets GPIO \fBg\fP to level \fBL\fP.  The level may be 0
(low, off, clear) or 1 (high, on, set).

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs w 23 0
.br
$ pigs w 23 1
.br

.br
$ pigs w 23 2
.br
-5
.br
ERROR: level not 0-1
.br

.EE

.br

.IP "\fBWDOG u v\fP - Set GPIO watchdog"
.IP "" 4

.br
This command sets a watchdog of \fBv\fP milliseconds on GPIO \fBu\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br
The watchdog is nominally in milliseconds.

.br
One watchdog may be registered per GPIO.

.br
The watchdog may be cancelled by setting timeout to 0.

.br
If no level change has been detected for the GPIO for timeout milliseconds:-

.br
any notification for the GPIO has a report written to the fifo with
the flags set to indicate a watchdog timeout.

.br

\fBExample\fP
.br

.EX
$ pigs wdog 23 90000
.br
-15
.br
ERROR: timeout not 0-60000
.br

.br
$ pigs wdog 23 9000
.br

.EE

.br
This example causes a report to be written to any notification pipes
listening on GPIO 23 whenever GPIO 23 changes state or approximately
every 9000 ms.

.br

.IP "\fBWVAG trips\fP - Add generic pulses to waveform"
.IP "" 4

.br
This command adds 1 one or more triplets \fBtrips\fP of GPIO on, GPIO off,
delay to the existing waveform (if any).

.br
Upon success the total number of pulses in the waveform so far is
returned.  On error a negative status code will be returned.

.br
The triplets will be added at the start of the existing waveform.  If
they are to start offset from the start then the first triplet should
consist solely of a delay i.e. 0 0 offset.

.br

\fBExample\fP
.br

.EX
$ pigs wvag 0x10 0x80 1000 0x80 0x10 9000
.br
2
.br

.br
$ pigs wvag 0 0 10000 0x10 0x80 1000 0x80 0x10 9000
.br
4
.br

.EE

.br

.IP "\fBWVAS u b db sb o bvs\fP - Add serial data to waveform"
.IP "" 4

.br
This command adds a waveform representing serial data \fBbvs\fP to
GPIO \fBu\fP at \fBb\fP baud to the existing waveform (if any).
The serial data starts \fBo\fP microseconds from the start of the
waveform.

.br
Upon success the total number of pulses in the waveform so far is
returned.  On error a negative status code will be returned.

.br
The serial data is formatted as one start bit, \fBdb\fP data bits, and
\fBsb\fP/2 stop bits.

.br
The baud rate may be between 50 and 1000000 bits per second.

.br
It is legal to add serial data streams with different baud rates to
the same waveform.

.br
The bytes required for each character depend upon \fBdb\fP.

.br
For \fBdb\fP 1-8 there will be one byte per character.
.br
For \fBdb\fP 9-16 there will be two bytes per character.
.br
For \fBdb\fP 17-32 there will be four bytes per character.

.br

\fBExample\fP
.br

.EX
$ pigs wvas 4 9600 8 2 0 0x30 0x31 0x32 0x33
.br
23
.br

.br
$ pigs wvas 7 38400 8 2 0 0x41 0x42
.br
35
.br

.EE

.br

.IP "\fBWVTAT \fP - Returns the current transmitting waveform"
.IP "" 4

.br
This command returns the id of the waveform currently
being transmitted.

.br
Returns the waveform id or one of the following special
values:

.br
9998 - transmitted wave not found
.br
9999 - no wave being transmitted

.br

\fBExample\fP
.br

.EX
$ pigs wvtat
.br
9999
.br

.EE

.br

.IP "\fBWVBSY \fP - Check if waveform is being transmitted"
.IP "" 4

.br
This command checks to see if a waveform is currently being transmitted.

.br
Returns 1 if a waveform is currently being transmitted, otherwise 0.

.br

\fBExample\fP
.br

.EX
$ pigs wvbsy
.br
0
.br

.EE

.br

.IP "\fBWVCHA bvs\fP - Transmits a chain of waveforms"
.IP "" 4

.br
This command transmits a chain of waveforms.

.br
NOTE: Any hardware PWM started by \fBHP\fP will
be cancelled.

.br
The waves to be transmitted are specified by the contents of
\fBbvs\fP which contains an ordered list of wave_ids and optional
command codes and related data.

.br
Upon success 0 is returned.  On error a negative status code
will be returned.

.br
Each wave is transmitted in the order specified.  A wave may
occur multiple times per chain.

.br
A blocks of waves may be transmitted multiple times by using
the loop commands. The block is bracketed by loop start and
end commands.  Loops may be nested.

.br
Delays between waves may be added with the delay command.

.br
The following command codes are supported:

.br

.EX
Name           Cmd & Data   Meaning
Loop Start     255 0        Identify start of a wave block
Loop Repeat    255 1 x y    loop x + y*256 times
Delay          255 2 x y    delay x + y*256 microseconds
Loop Forever   255 3        loop forever

.EE

.br
If present Loop Forever must be the last entry in the chain.

.br
The code is currently dimensioned to support a chain with roughly
600 entries and 20 loop counters.

.br

\fBExample\fP
.br

.EX
#!/bin/bash
.br

.br
GPIO=4
.br
WAVES=5
.br

.br
pigs m $GPIO w
.br

.br
for ((i=0; i<$WAVES; i++))
.br
do
.br
   pigs wvag $((1<<GPIO)) 0 20 0 $((1<<GPIO)) $(((i+1)*200))
.br
   w[i]=$(pigs wvcre)
.br
done
.br

.br
# transmit waves 4+3+2
.br
# loop start
.br
#    transmit waves 0+0+0
.br
#    loop start
.br
#       transmit waves 0+1
.br
#       delay 5000us
.br
#    loop end (repeat 30 times)
.br
#    loop start
.br
#       transmit waves 2+3+0
.br
#       transmit waves 3+1+2
.br
#    loop end (repeat 10 times)
.br
# loop end (repeat 5 times)
.br
# transmit waves 4+4+4
.br
# delay 20000us
.br
# transmit waves 0+0+0
.br

.br
pigs wvcha \
.br
   ${w[4]} ${w[3]} ${w[2]} \
.br
   255 0 \
.br
      ${w[0]} ${w[0]} ${w[0]} \
.br
      255 0 \
.br
         ${w[0]} ${w[1]} \
.br
         255 2 0x88 0x13 \
.br
      255 1 30 0 \
.br
      255 0 \
.br
         ${w[2]} ${w[3]} ${w[0]} \
.br
         ${w[3]} ${w[1]} ${w[2]} \
.br
      255 1 10 0 \
.br
   255 1 5 0 \
.br
   ${w[4]} ${w[4]} ${w[4]} \
.br
   255 2 0x20 0x4E \
.br
   ${w[0]} ${w[0]} ${w[0]}
.br

.br
while [[ $(pigs wvbsy) -eq 1 ]]; do sleep 0.1; done
.br

.br
for ((i=0; i<$WAVES; i++)); do echo ${w[i]}; pigs wvdel ${w[i]}; done
.br

.EE

.br

.IP "\fBWVCLR \fP - Clear all waveforms"
.IP "" 4

.br
This command clears all waveforms.

.br
Nothing is returned.

.br

\fBExample\fP
.br

.EX
$ pigs wvclr
.br

.EE

.br

.IP "\fBWVCRE \fP - Create a waveform"
.IP "" 4

.br
This command creates a waveform from the data provided by the prior
calls to the \fBWVAG\fP and \fBWVAS\fP commands.

.br
Upon success a wave id (>=0) is returned.  On error a negative status
code will be returned.

.br
The data provided by the \fBWVAG\fP and \fBWVAS\fP commands is
consumed by this command.

.br
As many waveforms may be created as there is space available.
The wave id is passed to \fBWVTX\fP or \fBWVTXR\fP to specify the
waveform to transmit.

.br
Normal usage would be

.br
Step 1. \fBWVCLR\fP to clear all waveforms and added data.

.br
Step 2. \fBWVAG\fP/\fBWVAS\fP calls to supply the waveform data.

.br
Step 3. \fBWVCRE\fP to create the waveform and get a unique id.

.br
Repeat steps 2 and 3 as needed.

.br
Step 4. \fBWVTX\fP or \fBWVTXR\fP with the id of the waveform to transmit.

.br
A waveform comprises of one or more pulses.

.br
A pulse specifies

.br
1) the GPIO to be switched on at the start of the pulse.
.br
2) the GPIO to be switched off at the start of the pulse.
.br
3) the delay in microseconds before the next pulse.

.br
Any or all the fields can be zero.  It doesn't make any sense to
set all the fields to zero (the pulse will be ignored).

.br
When a waveform is started each pulse is executed in order with
the specified delay between the pulse and the next.

.br

\fBExample\fP
.br

.EX
$ pigs wvas 4 9600 0 23 45 67 89 90
.br
37
.br
$ pigs wvcre
.br
0
.br

.br
$ pigs wvcre
.br
-69
.br
ERROR: attempt to create an empty waveform
.br

.EE

.br

.IP "\fBWVDEL wid\fP - Delete selected waveform"
.IP "" 4

.br
This command deletes the waveform with id \fBwid\fP.

.br
Upon success nothing is returned.  On error a negative status code
will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs wvdel 0
.br

.br
$ pigs wvdel 0
.br
-66
.br
ERROR: non existent wave id
.br

.EE

.br

.IP "\fBWVHLT \fP - Stop waveform"
.IP "" 4

.br
This command aborts the transmission of the current waveform.

.br
Nothing is returned.

.br
This command is intended to stop a waveform started in the repeat mode.

.br

\fBExample\fP
.br

.EX
$ pigs wvhlt
.br

.EE

.br

.IP "\fBWVNEW \fP - Initialise a new waveform"
.IP "" 4

.br
This clears any existing waveform data ready for the creation of a new
waveform.

.br
Nothing is returned.

.br

\fBExample\fP
.br

.EX
$ pigs wvnew
.br

.EE

.br

.IP "\fBWVSC ws\fP - Get waveform DMA CB stats"
.IP "" 4

.br
The statistic requested by \fBws\fP is returned.

.br
\fBws\fP identifies the subcommand as follows.

.br
0 Get Cbs
.br
1 Get High Cbs
.br
2 Get Max Cbs

.br

\fBExample\fP
.br

.EX
$ pigs wvas 4 9600 0 23 45 67 89 90
.br
37
.br

.br
$ pigs wvsc 0
.br
74
.br
$ pigs wvsc 1
.br
74
.br
$ pigs wvsc 2
.br
25016
.br

.EE

.br

.IP "\fBWVSM ws\fP - Get waveform time stats"
.IP "" 4

.br
The statistic requested by \fBws\fP is returned.

.br
\fBws\fP identifies the subcommand as follows.

.br
0 Get Micros
.br
1 Get High Micros
.br
2 Get Max Micros

.br

\fBExample\fP
.br

.EX
$ pigs wvsm 0
.br
5314
.br
$ pigs wvsm 1
.br
5314
.br
$ pigs wvsm 2
.br
1800000000
.br

.EE

.br

.IP "\fBWVSP ws\fP - Get waveform pulse stats"
.IP "" 4

.br
The statistic requested by \fBws\fP is returned.

.br
\fBws\fP identifies the subcommand as follows.

.br
0 Get Pulses
.br
1 Get High Pulses
.br
2 Get Max Pulses

.br

\fBExample\fP
.br

.EX
$ pigs wvsp 0
.br
37
.br
$ pigs wvsp 1
.br
37
.br
$ pigs wvsp 2
.br
12000
.br

.EE

.br

.IP "\fBWVTX wid\fP - Transmits waveform once"
.IP "" 4

.br
This command transmits the waveform with id \fBwid\fP once.

.br
NOTE: Any hardware PWM started by \fBHP\fP will be cancelled.

.br
Upon success the number of DMA control blocks in the waveform is returned.
On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs wvtx 1
.br
75
.br

.br
$ pigs wvtx 2
.br
-66
.br
ERROR: non existent wave id
.br

.EE

.br

.IP "\fBWVTXM wid wmde\fP - Transmits waveform using mode"
.IP "" 4

.br
This command transmits the waveform with id \fBwid\fP using mode \fBwmde\fP.

.br
The mode may be send once (0), send repeatedly (1), send once but
first sync with previous wave (2), or send repeatedly but first
sync with previous wave (3).

.br
WARNING: bad things may happen if you delete the previous
waveform before it has been synced to the new waveform.

.br
NOTE: Any hardware PWM started by \fBHP\fP will be cancelled.

.br
Upon success the number of DMA control blocks in the waveform is returned.
On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs wvtxm 1 3
.br
75
.br

.br
$ pigs wvtxm 2 0
.br
-66
.br
ERROR: non existent wave id
.br

.EE

.br

.IP "\fBWVTXR wid\fP - Transmits waveform repeatedly"
.IP "" 4

.br
This command transmits the waveform with id \fBwid\fP repeatedly.

.br
NOTE: Any hardware PWM started by \fBHP\fP will be cancelled.

.br
Upon success the number of DMA control blocks in the waveform is returned.
On error a negative status code will be returned.

.br

\fBExample\fP
.br

.EX
$ pigs wvtxr 1
.br
75
.br

.br
$ pigs wvtxr 2
.br
-66
.br
ERROR: non existent wave id
.br

.EE

.br

.SH PARAMETERS

.br

.IP "\fBactv\fP - 0-1000000" 0

.br
The number of microseconds level changes are reported for once
a noise filter has been triggered (by \fBstdy\fP microseconds of
a stable level).

.br

.IP "\fBb\fP - baud" 0
The command expects the baud rate in bits per second for
the transmission of serial data (I2C/SPI/serial link, waves).

.br

.IP "\fBbctl\fP - BSC control word" 0
The command expects a BSC control word, see \fBBSCX\fP.

.br

.IP "\fBbit\fP - bit value (0-1)" 0
The command expects 0 or 1.

.br

.IP "\fBbits\fP - a bit mask" 0
A mask is used to select one or more GPIO.  A GPIO is selected
if bit (1<<GPIO) is set in the mask.

.br
E.g. a mask of 6 (binary 110) select GPIO 1 and 2, a mask of
0x103 (binary 100000011) selects GPIO 0, 1, and 8.

.br

.IP "\fBbv\fP - a byte value (0-255)" 0
The command expects a byte value.

.br

.IP "\fBbvs\fP - byte values (0-255)" 0
The command expects one or more byte values.

.br

.IP "\fBc\fP - SPI channel (0-1)" 0
The command expects a SPI channel.

.br

.IP "\fBcf\fP - hardware clock frequency (4689-250M)" 0
The command expects a frequency.

.br

.IP "\fBcs\fP - GPIO (0-31)" 0
The GPIO used for the slave select signal when bit banging SPI.

.br

.IP "\fBdb\fP - serial data bits (1-32)" 0
The command expects the number of data bits per serial character.

.br

.IP "\fBdev\fP - a tty serial device (/dev/tty* or /dev/serial*)" 0
The command expects the name of a tty serial device, e.g.

.br

.EX
/dev/ttyAMA0
.br
/dev/ttyUSB0
.br
/dev/tty0
.br
/dev/serial0
.br

.EE

.br

.IP "\fBevent\fP - 0-31" 0
An event is a signal used to inform one or more consumers
to start an action.

.br

.IP "\fBfile\fP - a file name" 0
The file name must match an entry in /opt/pigpio/access.

.br

.IP "\fBfrom\fP - 0-2" 0
Position to seek from \fBFS\fP.

.br

.EX
    From
0   start
1   current position
2   end

.EE

.br

.IP "\fBg\fP - GPIO (0-53)" 0
The command expects a GPIO.

.br
There are 54 General Purpose Input Outputs (GPIO) named gpio0 through gpio53.

.br
They are split into two banks.  Bank 1 consists of gpio0 through gpio31.
Bank 2 consists of gpio32 through gpio53.

.br
All the GPIO which are safe for the user to read and write are in bank 1.
Not all GPIO in bank 1 are safe though. Type 1 boards have 17 safe GPIO.
Type 2 boards have 21. Type 3 boards have 26.

.br
See \fBHWVER\fP.

.br
The user GPIO are marked with an X in the following table.

.br

.EX
          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
Type 1    X  X  -  -  X  -  -  X  X  X  X  X  -  -  X  X
Type 2    -  -  X  X  X  -  -  X  X  X  X  X  -  -  X  X
Type 3          X  X  X  X  X  X  X  X  X  X  X  X  X  X
                                                      
         16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
Type 1    -  X  X  -  -  X  X  X  X  X  -  -  -  -  -  -
Type 2    -  X  X  -  -  -  X  X  X  X  -  X  X  X  X  X
Type 3    X  X  X  X  X  X  X  X  X  X  X  X  -  -  -  -

.EE

.br
You are not prevented from writing to unsafe GPIO.  The consequences
of doing so range from no effect, to a crash, or corrupted data.

.br

.IP "\fBh\fP - handle (>=0)" 0
The command expects a handle.

.br
A handle is a number referencing an object opened by one of \fBFO\fP,
\fBI2CO\fP, \fBNO\fP, \fBSERO\fP, \fBSPIO\fP.

.br

.IP "\fBib\fP - I2C bus (>=0)" 0
The command expects an I2C bus number.

.br

.IP "\fBid\fP - I2C device (0-0x7F)" 0
The command expects the address of an I2C device.

.br

.IP "\fBif\fP - I2C flags (0)" 0
The command expects an I2C flags value.  No flags are currently defined.

.br

.IP "\fBL\fP - level (0-1)" 0
The command expects a GPIO level.

.br

.IP "\fBm\fP - mode (RW540123)" 0
The command expects a mode character.

.br
Each GPIO can be configured to be in one of 8 different modes. The modes
are named Input, Output, ALT0, ALT1, ALT2, ALT3, ALT4, and ALT5.

.br
To set the mode use the code for the mode.

.br
The value is returned by the mode get command.

.br

.EX
Mode    Input   Output   ALT0   ALT1   ALT2   ALT3   ALT4   ALT5
Code      R        W       0      1      2      3      4      5
Value     0        1       4      5      6      7      3      2

.EE

.br

.IP "\fBmiso\fP - GPIO (0-31)" 0
The GPIO used for the MISO signal when bit banging SPI.

.br

.IP "\fBmode\fP - file open mode" 0
One of the following values.

.br

.EX
        Value   Meaning
READ      1     open file for reading
WRITE     2     open file for writing
RW        3     open file for reading and writing

.EE

.br
The following values can be or'd into the mode.

.br

.EX
         Value   Meaning
APPEND   4       All writes append data to the end of the file
CREATE   8       The file is created if it doesn't exist
TRUNC    16      The file is truncated

.EE

.br

.IP "\fBmosi\fP - GPIO (0-31)" 0
The GPIO used for the MOSI signal when bit banging SPI.

.br

.IP "\fBname\fP - the name of a script" 0
Only alphanumeric characters, '-' and '_' are allowed in the name.

.br

.IP "\fBnum\fP - maximum number of bytes to return (1-)" 0
The command expects the maximum number of bytes to return.

.br
For the I2C and SPI commands the requested number of bytes will always
be returned.

.br
For the serial and file commands the smaller of the number of
bytes available to be read (which may be zero) and \fBnum\fP bytes
will be returned.

.br

.IP "\fBo\fP - offset (>=0)" 0
Serial data is stored offset microseconds from the start of the waveform.

.br

.IP "\fBp\fP - PUD (ODU)" 0
The command expects a PUD character.

.br
Each GPIO can be configured to use or not use an internal pull up or
pull down resistor.  This is useful to provide a default state for inputs.

.br
A pull up will default the input to 1 (high).

.br
A pull down will default the input to 0 (low).

.br
To set the pull up down state use the command character for the state.

.br

.EX
Pull Up Down      Off Pull Down Pull Up
Command Character   O         D       U

.EE

.br
There is no mechanism to read the pull up down state.

.br

.IP "\fBpad\fP - 0-2" 0
A set of GPIO which share common drivers.

.br

.EX
Pad   GPIO
0     0-27
1     28-45
2     46-53

.EE

.br

.IP "\fBpadma\fP - 1-16" 0
The mA which may be drawn from each GPIO whilst still guaranteeing the
high and low levels.

.br

.IP "\fBpars\fP - script parameters" 0
The command expects 0 to 10 numbers as parameters to be passed to the script.

.br

.IP "\fBpat\fP - a file name pattern" 0
A file path which may contain wildcards.  To be accessible the path
must match an entry in /opt/pigpio/access.

.br

.IP "\fBpdc\fP - hardware PWM dutycycle (0-1000000)" 0
The command expects a dutycycle.

.br

.IP "\fBpf\fP - hardware PWM frequency (1-125M)" 0
The command expects a frequency.

.br

.IP "\fBpl\fP - pulse length (1-100)" 0
The command expects a pulse length in microseconds.

.br

.IP "\fBr\fP - register (0-255)" 0
The command expects an I2C register number.

.br

.IP "\fBsb\fP - serial stop (half) bits (2-8)" 0
The command expects the number of stop (half) bits per serial character.

.br

.IP "\fBscl\fP - user GPIO (0-31)" 0
The command expects the number of the GPIO to be used for SCL
when bit banging I2C.

.br

.IP "\fBsclk\fP - user GPIO (0-31)" 0
The GPIO used for the SCLK signal when bit banging SPI.

.br

.IP "\fBsda\fP - user GPIO (0-31)" 0
The command expects the number of the GPIO to be used for SDA
when bit banging I2C.

.br

.IP "\fBsef\fP - serial flags (32 bits)" 0
The command expects a flag value.  No serial flags are currently defined.

.br

.IP "\fBsid\fP - script id (>= 0)" 0
The command expects a script id as returned by a call to \fBPROC\fP.

.br

.IP "\fBspf\fP - SPI flags (32 bits)" 0
See \fBSPIO\fP and \fBBSPIO\fP.

.br

.IP "\fBstdy\fP - 0-300000" 0

.br
The number of microseconds level changes must be stable for
before reporting the level changed (\fBFG\fP) or triggering
the active part of a noise filter (\fBFN\fP).

.br

.IP "\fBstr\fP - a string" 0
The command expects a string.

.br

.IP "\fBt\fP - a string" 0
The command expects a string.

.br

.IP "\fBtrips\fP - triplets" 0
The command expects 1 or more triplets of GPIO on, GPIO off, delay.

.br
E.g. 0x400000 0 100000 0 0x400000 900000 defines two pulses as follows

.br

.EX
     GPIO on           GPIO off           delay
0x400000 (GPIO 22)           0 (None) 100000 (1/10th s)
          0 (None) 0x400000 (GPIO 22) 900000 (9/10th s)

.EE

.br

.IP "\fBu\fP - user GPIO (0-31)" 0
The command expects the number of a user GPIO.

.br
A number of commands are restricted to GPIO in bank 1,
in particular the PWM commands, the servo command,
the watchdog command, and the notification command.

.br
It is your responsibility to ensure that the PWM and servo commands
are only used on safe GPIO.

.br
See \fBg\fP

.br

.IP "\fBuvs\fP - values" 0
The command expects an arbitrary number of >=0 values (possibly none).
Any after the first two must be <= 255.

.br

.IP "\fBv\fP - value" 0
The command expects a number.

.br

.IP "\fBwid\fP - wave id (>=0)" 0
The command expects a wave id.

.br
When a waveform is created it is given an id (0, 1, 2, ...).

.br

.IP "\fBwmde\fP - mode (0-3)" 0
The command expects a wave transmission mode.

.br
0 = send once
.br
1 = send repeatedly
.br
2 = send once but first sync with previous wave
.br
3 = send repeatedly but first sync with previous wave
.br

.br

.IP "\fBws\fP - wave stats sucommand (0-2)" 0
The command expects a subcommand.

.br
0 = current value.
.br
1 = highest value so far.
.br
2 = maximum possible value.

.br

.IP "\fBwv\fP - word value (0-65535)" 0
The command expects a word value.

.br

.SH SCRIPTS

.br
Scripts are programs to be stored and executed by the pigpio daemon.
They are intended to mitigate any performance problems associated with
the pigpio daemon server/client model.

.br
.SS Example
.br
A trivial example might be useful.  Suppose you want to toggle a GPIO
on and off as fast as possible.

.br
From the command line you could write

.br

.EX
for ((i=0; i<1000;i++)); do pigs w 22 1 w 22 0; done
.br

.EE

.br
Timing that you will see it takes about 14 seconds, or roughly
70 toggles per second.

.br
Using the pigpio Python module you could use code such as

.br

.EX
#!/usr/bin/env python
.br

.br
import time
.br

.br
import pigpio
.br

.br
PIN=4
.br

.br
TOGGLE=10000
.br

.br
pi = pigpio.pi() # Connect to local Pi.
.br

.br
s = time.time()
.br

.br
for i in range(TOGGLE):
.br
   pi.write(PIN, 1)
.br
   pi.write(PIN, 0)
.br

.br
e = time.time()
.br

.br
print("pigpio did {} toggles per second".format(int(TOGGLE/(e-s))))
.br

.br
pi.stop()
.br

.EE

.br
Timing that shows a speed improvement to roughly 800 toggles per second.

.br
Now let's use a script.

.br

.EX
pigs proc tag 999 w 22 1 w 22 0 dcr p0 jp 999
.br

.EE

.br
Ignore the details for now.

.br
Let's time the script running.

.br
Again, ignore the details for now.

.br

.EX
time (pigs procr 0 10000000; while a=$(pigs procp 0); [[ ${a::1} -eq 2 ]];\
.br
 do sleep 0.2; done)
.br

.EE

.br
The script takes roughly 12 seconds to complete, or 800,000 toggles per second.

.br
That is the advantage of a stored script.

.br
Some details.

.br

.EX
pigs proc tag 999 w 22 1 w 22 0 dcr p0 jp 999
.br

.EE

.br
proc introduces a script.  Everything after proc is part of the script.
.br
tag 999 names the current position in the script.
.br
w 22 1 writes 1 to GPIO 22.
.br
w 22 0 writes 0 to GPIO 22.
.br
dcr p0 decrements parameter 0.
.br
jp 999 jumps to tag 999 if the result is positive.

.br

.EX
time (pigs procr 0 10000000; while a=$(pigs procp 0); [[ ${a::1} -eq 2 ]];\
.br
 do sleep 0.2; done)
.br

.EE

.br
pigs procr 0 10000000 starts script 0 with parameter 0 of 10 million.

.br
The rest is bash apart from

.br
pigs procp 0 asks for the status and parameters of script 0.
The status will be 2 while the script is running and 1 when it is complete.

.br
.SS Virtual machine
.br
A script runs within a virtual machine with

.br
a 32 bit accumulator A.
.br
a flags register F.
.br
a program counter PC.

.br
Each script has

.br
10 parameters named 0 through 9.
.br
150 variables named 0 through 149.
.br
50 labels which are named by any unique number.

.br
.SS Commands
.br
All the normal pigs commands may be used within a script.  However
commands which return more than an integer will be of little use.

.br
The following commands are only legal within a script.

.br

.EX
Command Description                                   Definition
ADD x   Add x to accumulator                          A+=x; F=A
AND x   And x with accumulator                        A&=x; F=A
CALL L  Call subroutine at tag L                      push(PC+1); PC=L
CMP x   Compare x with accumulator                    F=A-x
DCR y   Decrement register                            --*y; F=*y
DCRA    Decrement accumulator                         --A; F=A
DIV x   Divide x into accumulator                     A/=x; F=A
EVTWT   Wait for an event to occur                    A=wait(x); F=A
HALT    Halt                                          Halt
INR y   Increment register                            ++*y; F=*y
INRA    Increment accumulator                         ++A; F=A
JM L    Jump if minus to tag L                        if (F<0) PC=L
JMP L   Jump to tag L                                 PC=L
JNZ L   Jump if non-zero to tag L                     if (F) PC=L
JP L    Jump if positive to tag L                     if (F>=0) PC=L
JZ L    Jump if zero to tag L                         if (!F) PC=L
LD y x  Load register with x                          *y=x
LDA x   Load accumulator with x                       A=x
MLT x   Multiply x with accumulator                   A*=x; F=A
MOD x   Modulus x with accumulator                    A%=x; F=A
OR x    Or x with accumulator                         A|=x; F=A
POP y   Pop register                                  y=pop()
POPA    Pop accumulator                               A=pop()
PUSH y  Push register                                 push(y)
PUSHA   Push accumulator                              push(A)
RET     Return from subroutine                        PC=pop()
RL y x  Rotate left register x bits                   *y<<=x; F=*y
RLA x   Rotate left accumulator x bits                A<<=x; F=A
RR y x  Rotate right register x bits                  *y>>=x; F=*y
RRA x   Rotate right accumulator x bits               A>>=x; F=A
STA y   Store accumulator in register                 y=A
SUB x   Subtract x from accumulator                   A-=x; F=A
SYS str Run external script (/opt/pigpio/cgi/str)     system(str); F=A
TAG L   Label the current script position             N/A
WAIT x  Wait for a GPIO in x to change state          A=wait(x); F=A
X y1 y2 Exchange contents of registers y1 and y2      t=*y1;*y1=*y2;*y2=t
XA y    Exchange contents of accumulator and register t=A;A=*y;*y=t
XOR x   Xor x with accumulator                        A^=x; F=A

.EE

.br
x may be a constant, a parameter (p0-p9), or a variable (v0-v149).

.br
y may be a parameter (p0-p9), or a variable (v0-v149).  If p or v isn't
specified y is assumed to be a variable.

.br
The EVTWT command parameter is a bit-mask with 1 set for events of interest.

.br
The WAIT command parameter is a bit-mask with 1 set for GPIO of interest.

.br
The SYS script receives two unsigned parameters: the accumulator A and
the current GPIO levels.

.br

.SH SEE ALSO

pigpiod(1), pig2vcd(1), pigpio(3), pigpiod_if(3), pigpiod_if2(3)
.SH AUTHOR

joan@abyz.co.uk
